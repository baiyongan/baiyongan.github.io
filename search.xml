<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《软技能2 —— 软件开发者职业生涯指南》 书摘</title>
      <link href="/2022/02/09/booknote/soft-skills-2nd-edition/"/>
      <url>/2022/02/09/booknote/soft-skills-2nd-edition/</url>
      
        <content type="html"><![CDATA[<div class="douban-card-block"><a class="douban-card" href="https://book.douban.com/subject/35043940"><div class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img3.doubanio.com/view/subject/s/public/s33644540.jpg');"></div><div class="douban-card-left"><div class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img3.doubanio.com/view/subject/s/public/s33644540.jpg');"></div></div><div class="douban-card-right" style="line-height: 1.7;"><div class="douban-card-item"><span>书名: </span><strong>软技能2软件开发者职业生涯指南</strong></div><div class="douban-card-item"><span>作者: </span><span>[美]约翰·森梅兹</span></div><div class="douban-card-item"><span>出版年份: </span><span>2020-5-1</span></div><div class="douban-card-item"><span>评分: </span><span>8.4</span></div></div></a></div><style>.douban-card-block {display: flex;justify-content: center;align-items: center;width: 100%;max-height: 400px;}.douban-card {display: flex;margin: 30px 10px;padding: 15px;border-radius: 10px;position: relative;justify-content: center;align-items: center;overflow: hidden;color: antiquewhite;text-decoration: none;}.douban-card:hover {text-decoration: none;}.douban-card-bgimg {position: absolute;width: 115%;height: 115%;filter: blur(15px) brightness(0.6);background-size: 100%;background-position: center;background-repeat: no-repeat;}.douban-card-img {position: relative;height: 130px;width: 80px;background-size: 100%;background-position: center;background-repeat: no-repeat;}.douban-card-img {position: relative;height: 130px;width: 80px;}.douban-card-left {position: relative;display: flex;flex-direction: column;align-items: center;}.douban-card-right {position: relative;display: flex;flex-direction: column;margin-left: 12px;font-size: 16px;font-family: 'Courier New', Courier, monospace;line-height: 1.3;color: antiquewhite;}.douban-card-item {margin-top: 4px;}</style><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Booknote </category>
          
          <category> 专业技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业发展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令速查系列——文件基本操作</title>
      <link href="/2020/06/01/linux/theme-file-operation/"/>
      <url>/2020/06/01/linux/theme-file-operation/</url>
      
        <content type="html"><![CDATA[<h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><table><thead><tr><th>命令工具</th><th>功能简介</th></tr></thead><tbody><tr><td>ls</td><td>列出目录中的文件和目录的属性</td></tr><tr><td>cp</td><td>复制文件</td></tr><tr><td>mv</td><td>重命名（“移动”）文件</td></tr><tr><td>rm</td><td>删除（“移除”）文件</td></tr><tr><td>ln</td><td>创建文件链接（替代名称）</td></tr></tbody></table><span id="more"></span><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><blockquote><h3 id="ls-options-files"><a href="#ls-options-files" class="headerlink" title="ls [options] [files]"></a>ls [<em>options</em>] [<em>files</em>]</h3></blockquote><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><p><strong>最重要的三个： -a、-l、-d</strong></p><ul><li><p>-a    列出所有的文件，包括文件名以句点开头的文件</p></li><li><p>-l    长列表，包括文件属性。添加-h选项（human-readable的首字母）后，文件大小的显示可增加可读性</p></li></ul><p><strong>各项含义解释</strong></p><ul><li><p>-G    在长列表中，不输出文件的组所有权</p></li><li><p>-F    用意义明确的符号修饰文件名称，从而指示文件的类型。</p><ul><li>斜杠（<code>/</code>）表示目录（或“文件夹”）。</li><li>星号（<code>*</code>）表示可执行文件。这包括二进制文件（编译代码）以及脚本（具有可执行权限的文本文件）。</li><li>符号（<code>@</code>）表示符号链接（或“别名”）。</li><li>等号（<code>=</code>）表示套接字。</li><li>在 BSD 上，百分号（<code>%</code>）表示 <em>涂改(whiteout)</em>（某些文件系统上的文件删除方法）。</li><li>在 GNU 上，尖括号（<code>&gt;</code>）表示 <em>门(door)</em>（Illumos和 Solaris上的进程间通信）。</li><li>竖线（<code>|</code>）表示 FIFO 管道。 这个选项的一个更简单的版本是 <code>-p</code>，它只区分文件和目录。</li></ul></li><li><p>-S    澳门找大小对文件排序</p></li><li><p>-t    按照最近修改时间对文件进行排序</p></li><li><p>-r    反序</p></li><li><p>-R    显示目录时，递归显示其内容</p></li><li><p>-d    显示目录时，不显示其内容，仅显示目录本身的信息</p></li></ul><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><blockquote><h3 id="cp-options-files-file-directory"><a href="#cp-options-files-file-directory" class="headerlink" title="cp [options] files (file | directory)"></a>cp [<em>options<em>] files (</em>file | directory</em>)</h3></blockquote><h3 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><p>-p    不仅复制文件内容，同时复制文件的权限、时间错，权限够的话，还可以复制其属主和用户组</p></li><li><p>-a    递归复制目录的层次结构，保留所有的文件属性和链接</p></li><li><p>-r    递归复制目录的层次结构。该选项不保留文件的属性，如权限和时间戳，但会保留符号链接</p></li><li><p>-i    交互模式，在覆盖目标文件前会询问</p></li><li><p>-f    强制复制，如果目标文件存在，则无条件覆盖</p></li></ul><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><blockquote><h3 id="mv-options-source-target"><a href="#mv-options-source-target" class="headerlink" title="mv [options*] *source target"></a>mv [<em>options*] *source target</em></h3></blockquote><h3 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><p>-i    交互模式，在覆盖目标文件之前，进行询问</p></li><li><p>-f    强制移动，如果目标文件存在，则无条件覆盖</p></li></ul><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><blockquote><h3 id="rm-options-files-directories"><a href="#rm-options-files-directories" class="headerlink" title="rm [options*]  *files | directories"></a>rm [<em>options*]  *files | directories</em></h3></blockquote><h3 id="常用选项-3"><a href="#常用选项-3" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><p>-i    交互式，在删除每个文件之前，进行询问</p></li><li><p>-f     强制删除，忽略任何错误或警告</p></li><li><p>-r    递归删除目录及其内容，慎用，尤其慎用 -rf </p></li></ul><h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><blockquote><h3 id="ln-options-source-target"><a href="#ln-options-source-target" class="headerlink" title="ln [options*]  *source target"></a>ln [<em>options*]  *source target</em></h3></blockquote><h3 id="常用选项-4"><a href="#常用选项-4" class="headerlink" title="常用选项"></a>常用选项</h3><p>直观的讲，链接就是给同一个文件取多个名称，允许将其同时放到两个（或多个）地方。</p><ul><li><p>ln -s myfile mysoftlink     符号链接（软链接）：通过路径来引用另一个文件，类似于windows中的快捷方式。</p></li><li><p>ln myfile myhardlink    硬链接   只是磁盘上物理文件的第二个名称（它指向同一个inode），删除原始文件，该链接仍旧有效。</p></li><li><p>-s    创建一个符号链接</p></li><li><p>-i    交互模式，再覆盖目标文件之前，进行询问</p></li><li><p>-f    强制链接，如果目标文件存在的话，则无条件覆盖</p></li><li><p>-d    创建指向目录的硬链接，（仅限于超级用户）</p></li></ul><p>  <img src="/images/ln.png" alt="ln"></p><p>  注：符号链接，可以指向其他的符号链接，如果要查找出整个链接最终指向的位置，可以使用readlink -f 命令。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@bya ln_test]# touch test_file</span><br><span class="line">[root@bya ln_test]# ln -s test_file test_file_1 #创建符号链接</span><br><span class="line">[root@bya ln_test]# ln -s test_file_1 test_file_2 # 创建第二个符号链接</span><br><span class="line">[root@bya ln_test]# ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root  0 Jun  2 12:19 test_file</span><br><span class="line">lrwxrwxrwx 1 root root  9 Jun  2 12:20 test_file_1 -&gt; test_file</span><br><span class="line">lrwxrwxrwx 1 root root 11 Jun  2 12:20 test_file_2 -&gt; test_file_1</span><br><span class="line">[root@bya ln_test]# readlink -f test_file_2 </span><br><span class="line">/home/baiyongan/linux_practice/ln_test/test_file</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>其中，ls -l 显示的文件属性细节需要补充，或另辟一文</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> cheatsheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 速查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列——文本处理三剑客之一 awk</title>
      <link href="/2020/05/30/linux/command-awk/"/>
      <url>/2020/05/30/linux/command-awk/</url>
      
        <content type="html"><![CDATA[<h1 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h1><p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有很多其他的功能。</p><p>作为一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。<strong>简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</strong>数据可以来自标准输入、外部文件，或者其他命令的输出。awk 同时支持正则表达式和用户自定义函数。</p><p><strong>awk是行处理器</strong>: 相比较屏幕处理的优点，在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息(ctrl+c/v的，未考证😳)。</p><span id="more"></span><h1 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="指定输出列"><a href="#指定输出列" class="headerlink" title="指定输出列"></a>指定输出列</h3><p>awk 处理文件是以记录为单位的，它会一条记录一条记录地遍历文件并进行处理。$0 代表的是一条记录，也就是student.txt 文件中的一整行内容。$1, 和 $3 代表的是第一、三列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ cat student.txt </span><br><span class="line">xiaoqiang05/99henan989697</span><br><span class="line">xiaohong06/99shandong9899100</span><br><span class="line">xiaofang02/99guangdong829089</span><br><span class="line">xiaogang07/99beijing888687</span><br><span class="line">xiaohua05/99anhui909193</span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;&#123;print $0&#125;&#x27; student.txt </span><br><span class="line">xiaoqiang05/99henan989697</span><br><span class="line">xiaohong06/99shandong9899100</span><br><span class="line">xiaofang02/99guangdong829089</span><br><span class="line">xiaogang07/99beijing888687</span><br><span class="line">xiaohua05/99anhui909193</span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;&#123;print $1, $3&#125;&#x27; student.txt</span><br><span class="line">xiaoqiang henan</span><br><span class="line">xiaohong shandong</span><br><span class="line">xiaofang guangdong</span><br><span class="line">xiaogang beijing</span><br><span class="line">xiaohua anhui</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br></pre></td></tr></table></figure><h3 id="修饰表头和表尾"><a href="#修饰表头和表尾" class="headerlink" title="修饰表头和表尾"></a>修饰表头和表尾</h3><p>两个关键字：</p><p>BEGIN：在awk对文件处理之前首先被执行</p><p>END：表示在awk对所有文件处理完后才被执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ awk &#x27;BEGIN &#123;print &quot;Name    province\n----------------------------&quot;&#125; &#123;print $1, $3&#125; END &#123;print &quot;----------------------------&quot;&#125;&#x27; student.txt</span><br><span class="line">Name    province</span><br><span class="line">----------------------------</span><br><span class="line">xiaoqiang henan</span><br><span class="line">xiaohong shandong</span><br><span class="line">xiaofang guangdong</span><br><span class="line">xiaogang beijing</span><br><span class="line">xiaohua anhui</span><br><span class="line">----------------------------</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br></pre></td></tr></table></figure><h3 id="统计功能"><a href="#统计功能" class="headerlink" title="统计功能"></a>统计功能</h3><p>如下：可以用 $4 + $5 + $6 来实现总分的计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ cat student.txt </span><br><span class="line">xiaoqiang05/99henan989697</span><br><span class="line">xiaohong06/99shandong9899100</span><br><span class="line">xiaofang02/99guangdong829089</span><br><span class="line">xiaogang07/99beijing888687</span><br><span class="line">xiaohua05/99anhui909193</span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;BEGIN &#123;print &quot;Name    province\n----------------------------&quot;&#125; &#123;print $1, $3, $4+$5+$6&#125; END &#123;print &quot;---------------------------------&quot;&#125;&#x27; student.txt</span><br><span class="line">Name    province</span><br><span class="line">----------------------------</span><br><span class="line">xiaoqiang henan 291</span><br><span class="line">xiaohong shandong 297</span><br><span class="line">xiaofang guangdong 261</span><br><span class="line">xiaogang beijing 261</span><br><span class="line">xiaohua anhui 274</span><br><span class="line">---------------------------------</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br></pre></td></tr></table></figure><h3 id="筛选功能"><a href="#筛选功能" class="headerlink" title="筛选功能"></a>筛选功能</h3><p>可以使用类似 $3 ~ /beijing/ 的语法筛选出来来自beijing的学生的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ awk &#x27;BEGIN &#123;print &quot;Name    province\n----------------------------&quot;&#125; $3 ~ /beijing/ &#123;print $1, $3, $4+$5+$6&#125; END &#123;print &quot;---------------------------------&quot;&#125;&#x27; student.txt</span><br><span class="line">Name    province</span><br><span class="line">----------------------------</span><br><span class="line">xiaogang beijing 261</span><br><span class="line">---------------------------------</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br></pre></td></tr></table></figure><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><blockquote><p><strong>简版：awk ‘Pattern {Action}’ filename</strong> </p></blockquote><p>其中：</p><ul><li><p>Pattern 用来指定判断条件，比如上面例子中的 $3 ~ /beijing/</p></li><li><p>{} 中包含的是 awk 的动作，也就是 awk 对记录的操作，比如 $4+$5+$6 或者 print</p></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>第一步，awk 读取一条记录（文件中的一行内容）作为输入，并将这条记录赋值给内部变量 $0</li><li>第二步，记录被分隔符分割成多个字段，每一个字段都存储到指定编号的变量中，从 $1 开始。(awk 的内部变量 FS 用来指定字段的分隔符。默认情况下，为空格，包含制表符和空格符，也可以用 - F 来人为指定分隔符 )</li><li>第三步，对每一条记录，按 Pattern 进行匹配，匹配成功，则执行对应 Action，匹配失败，则不执行Action。<ul><li>Pattern 和 Action都可选，但是<strong>必须提供其中一个</strong>。没有指定 Pattern，则对所有的输入行都执行 Action 操作。如果没有指定 Action，则会输出匹配行的内容。</li><li>如果Action 被指定为 {}， 则表示不做任何动作，也不会输出匹配行的内容。</li></ul></li><li>第四步，重复进行上面的 1-3 步直到文件结束。</li></ul><h3 id="更完整的格式与工作流程"><a href="#更完整的格式与工作流程" class="headerlink" title="更完整的格式与工作流程"></a>更完整的格式与工作流程</h3><blockquote><p><strong>详版：awk ‘BEGIN{ commands } Pattern { commands } END{ commands }’</strong></p></blockquote><p><img src="/images/awk.png" alt="awk"></p><ul><li>通过关键字 BEGIN 执行 BEGIN 块的内容，即 BEGIN 后花括号 {} 的内容。</li><li>完成 BEGIN 块的执行，开始执行body块。</li><li>读入有  换行符分割的记录。</li><li>将记录按指定的域分隔符划分域，填充域，$0 则表示所有域(即一行内容)，$1 表示第一个域，$n 表示第 n 个域。</li><li>依次执行各 BODY 块，pattern 部分匹配该行内容成功后，才会执行 awk-commands 的内容。</li><li>循环读取并执行各行直到文件结束，完成body块执行。</li><li>开始 END 块执行，END 块可以输出最终结果。</li></ul><h3 id="awk-脚本编写"><a href="#awk-脚本编写" class="headerlink" title="awk 脚本编写"></a>awk 脚本编写</h3><p>如果需要在Action的部分里写打断的逻辑，建议将器写道一个独立的脚本文件中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ cat student.awk </span><br><span class="line">BEGIN &#123;print &quot;Name  province  total\n-------------------------&quot;&#125;</span><br><span class="line">&#123;print $1, $3, $4+$5+$6&#125;</span><br><span class="line">END &#123;print &quot;-------------------------&quot;&#125;</span><br><span class="line">[baiyongan@bya awk_test]$ cat -n student.awk </span><br><span class="line">     1BEGIN &#123;print &quot;Name  province  total\n-------------------------&quot;&#125;</span><br><span class="line">     2&#123;print $1, $3, $4+$5+$6&#125;</span><br><span class="line">     3END &#123;print &quot;-------------------------&quot;&#125;</span><br><span class="line">[baiyongan@bya awk_test]$ awk -f student.awk student.txt </span><br><span class="line">Name  province  total</span><br><span class="line">-------------------------</span><br><span class="line">xiaoqiang henan 291</span><br><span class="line">xiaohong shandong 297</span><br><span class="line">xiaofang guangdong 261</span><br><span class="line">xiaogang beijing 261</span><br><span class="line">xiaohua anhui 274</span><br><span class="line">-------------------------</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要让awk脚本执行得“更像样子”：可以在awk脚本开头加上如下一句话。#! /bin/awk -f</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ sed -i &#x27;1i\#! /bin/awk -f&#x27; student.awk </span><br><span class="line">[baiyongan@bya awk_test]$ cat student.awk </span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/awk -f</span></span><br><span class="line">BEGIN &#123;print &quot;Name  province  total\n-------------------------&quot;&#125;</span><br><span class="line">&#123;print $1, $3, $4+$5+$6&#125;</span><br><span class="line">END &#123;print &quot;-------------------------&quot;&#125;</span><br><span class="line">[baiyongan@bya awk_test]$ chmod u+x student.awk </span><br><span class="line">[baiyongan@bya awk_test]$ ./student.awk student.txt </span><br><span class="line">Name  province  total</span><br><span class="line">-------------------------</span><br><span class="line">xiaoqiang henan 291</span><br><span class="line">xiaohong shandong 297</span><br><span class="line">xiaofang guangdong 261</span><br><span class="line">xiaogang beijing 261</span><br><span class="line">xiaohua anhui 274</span><br><span class="line">-------------------------</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多行操作"><a href="#多行操作" class="headerlink" title="多行操作"></a>多行操作</h2><h3 id="显示奇数行"><a href="#显示奇数行" class="headerlink" title="显示奇数行"></a>显示奇数行</h3><p>NR 表示行数，如下案例，当行数为偶数时，不输出，当行数为奇数时，输出。</p><blockquote><p><strong>NR          The total number of input records seen so far.</strong></p><p><strong>next</strong>      Stop processing the current input record.  The next input record is read<br>                and  processing  starts  over with the first pattern in the AWK program.<br>                If the end of the input data is reached, the END block(s), if  any,  are<br>                executed.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ cat -n input.txt </span><br><span class="line">     1one</span><br><span class="line">     2two</span><br><span class="line">     3three</span><br><span class="line">     4four</span><br><span class="line">     5five</span><br><span class="line">     6six</span><br><span class="line">     7seven</span><br><span class="line">     8eight</span><br><span class="line">     9nine</span><br><span class="line">    10ten</span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;NR%2==0 &#123;next&#125; &#123;print NR, $0&#125;&#x27; input.txt </span><br><span class="line">1 one</span><br><span class="line">3 three</span><br><span class="line">5 five</span><br><span class="line">7 seven</span><br><span class="line">9 nine</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="固定行数合并"><a href="#固定行数合并" class="headerlink" title="固定行数合并"></a>固定行数合并</h3><p>如果将文件中的每三行数据合并为一行，如何操作呢？ </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ cat -n input.txt </span><br><span class="line">     1one</span><br><span class="line">     2two</span><br><span class="line">     3three</span><br><span class="line">     4four</span><br><span class="line">     5five</span><br><span class="line">     6six</span><br><span class="line">     7seven</span><br><span class="line">     8eight</span><br><span class="line">     9nine</span><br><span class="line">    10ten</span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;NR%3!=0 &#123;T=(T&quot; &quot;$0); next&#125; &#123;print T, $0; T=&quot;&quot;&#125;&#x27; input.txt </span><br><span class="line"> one two three</span><br><span class="line"> four five six</span><br><span class="line"> seven eight nine</span><br><span class="line">[baiyongan@bya awk_test]$</span><br></pre></td></tr></table></figure><p>解释：</p><p><strong>第一部分：NR%3!=0 {T=(T” “$0); next}</strong></p><p><strong>第二部分：{print T, $0; T=””}</strong></p><p>T=(T” “$0) 表示将字符型的变量T，空格和变量 $0，三者的值进行连接，然后再赋值给变量T。也就是说，awk 语句每读取一行都会把这行的内容追加到变量T中。</p><p>next 的作用很关键，表示不再执行第二部分的语句，而是直接进行下一行的处理，这样就保证awk把每三行一组的内容都存储到了变量T中。</p><p>{print T, $0; T=””} 表示输出变量T和$0的内容，并把变量T的内容清空。</p><p>注意：最后一行的数据ten没有输出出来，其实时最后一行没有达到 “3个一组”的条件。如果需要，可以再最后增加END操作，进行收尾</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ awk &#x27;NR%3!=0 &#123;T=(T&quot; &quot;$0); next&#125; &#123;print T, $0; T=&quot;&quot;&#125; END &#123;print T&#125;&#x27; input.txt </span><br><span class="line"> one two three</span><br><span class="line"> four five six</span><br><span class="line"> seven eight nine</span><br><span class="line"> ten</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不定行数合并"><a href="#不定行数合并" class="headerlink" title="不定行数合并"></a>不定行数合并</h3><p>有时候的分组合并场景，并不都是固定行数的合并，不定行数应该怎么办呢？如下，对于不同时间，可以用worktime来分组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ awk &#x27;BEGIN &#123;T=&quot;&quot;&#125; /worktime/ &#123;print T; T=$0; next&#125; &#123;T=T&quot;&quot;$0&#125; END &#123;print T&#125;&#x27; input_time.txt </span><br><span class="line"></span><br><span class="line">xiaoming worktime is898788908978</span><br><span class="line">xiaoqiang worktime is90989790</span><br><span class="line">xiaohong worktime is909293</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="合并所有的行"><a href="#合并所有的行" class="headerlink" title="合并所有的行"></a>合并所有的行</h3><p>合并一个文件的所有行，经常碰到，linux中实现这类操作的方法很多，可以用sed 直接删除文件中的换行符，当然，也可以用awk来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ cat input.txt </span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br><span class="line">seven</span><br><span class="line">eight</span><br><span class="line">nine</span><br><span class="line">ten</span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;&#123;T=T&quot; &quot;$0&#125; END &#123;print T&#125;&#x27; input.txt </span><br><span class="line"> one two three four five six seven eight nine ten</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多文件操作"><a href="#多文件操作" class="headerlink" title="多文件操作"></a>多文件操作</h2><h3 id="多文件输出"><a href="#多文件输出" class="headerlink" title="多文件输出"></a>多文件输出</h3><p>Q：如何将两个文件一起输出呢？</p><p>A：直接再命令尾部加上文件名即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ awk &#x27;&#123;print $0&#125;&#x27; input.txt input_time.txt </span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br><span class="line">seven</span><br><span class="line">eight</span><br><span class="line">nine</span><br><span class="line">ten</span><br><span class="line">xiaoming worktime is</span><br><span class="line">89</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">90</span><br><span class="line">89</span><br><span class="line">78</span><br><span class="line">xiaoqiang worktime is</span><br><span class="line">90</span><br><span class="line">98</span><br><span class="line">97</span><br><span class="line">90</span><br><span class="line">xiaohong worktime is</span><br><span class="line">90</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="两手抓两个文件"><a href="#两手抓两个文件" class="headerlink" title="两手抓两个文件"></a>两手抓两个文件</h3><p>Q：如果要输出 input.txt 文件中的第一行数据，input_time.txt 的第八行数据以及它们的文件名，应该怎么实现呢？</p><p>A：如下所示</p><ul><li><p>NR 表示已读记录数，无论有几个文件，每读一条记录，值会增加 1；</p></li><li><p>FNR 表示当前文件的已读记录数，操作当前文件时，每读一条记录，值会增加 1。但当更换文件后，该变量会重新从零开始。</p></li><li><p>当 NR==FNR时，表示awk正在处理第一个输入文件。当 NR&gt;FNR时，表示正在处理第二个输入文件。</p></li><li><p>FILENAME表示当前处理文件的文件名。</p></li></ul><blockquote><p>NR          The total number of input records seen so far.</p><p>FNR         The input record number in the current input file.</p><p>FILENAME    The name of the current input file.  If no files  are  specified  on  the  command<br>                       line,  the  value  of  FILENAME is “-”.  However, FILENAME is undefined inside the<br>                        BEGIN block (unless set by getline).</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ awk &#x27;&#123;print $0&#125;&#x27; input.txt input_time.txt </span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br><span class="line">seven</span><br><span class="line">eight</span><br><span class="line">nine</span><br><span class="line">ten</span><br><span class="line">xiaoming worktime is</span><br><span class="line">89</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">90</span><br><span class="line">89</span><br><span class="line">78</span><br><span class="line">xiaoqiang worktime is</span><br><span class="line">90</span><br><span class="line">98</span><br><span class="line">97</span><br><span class="line">90</span><br><span class="line">xiaohong worktime is</span><br><span class="line">90</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;NR==FNR&amp;&amp;FNR==1 &#123;print FILENAME, $0&#125; NR&gt;FNR&amp;&amp;FNR==8 &#123;print FILENAME, $0&#125;&#x27; input.txt input_time.txt </span><br><span class="line">input.txt one</span><br><span class="line">input_time.txt xiaoqiang worktime is</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多只手抓多个文件"><a href="#多只手抓多个文件" class="headerlink" title="多只手抓多个文件"></a>多只手抓多个文件</h3><p>Q：如何区分多个文件呢？</p><p>A：针对多个文件，awk里有个专门的环境变量  ARGIND ，用来指定当前正在处理的文件的编号</p><blockquote><p>ARGIND      The index in ARGV of the current file being processed.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ cat input.txt input_time.txt input_3.txt </span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br><span class="line">seven</span><br><span class="line">eight</span><br><span class="line">nine</span><br><span class="line">ten</span><br><span class="line">xiaoming worktime is</span><br><span class="line">89</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">90</span><br><span class="line">89</span><br><span class="line">78</span><br><span class="line">xiaoqiang worktime is</span><br><span class="line">90</span><br><span class="line">98</span><br><span class="line">97</span><br><span class="line">90</span><br><span class="line">xiaohong worktime is</span><br><span class="line">90</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">file3 line1</span><br><span class="line">file3 line2</span><br><span class="line">file3 line3</span><br><span class="line">file3 line4</span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;ARGIND==1&amp;&amp;FNR==1 &#123;print $0&#125; ARGIND==2&amp;&amp;FNR==2 &#123;print $0&#125; ARGIND==3&amp;&amp;FNR==3 &#123;print $0&#125;&#x27; input.txt input_time.txt input_3.txt </span><br><span class="line">one</span><br><span class="line">89</span><br><span class="line">file3 line3</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上述的方法，还可以在文件名上下手，例如：</p><ul><li>FILENAME</li><li>ARGV：命令行参数的数组，同C语言的main（int argc， char **argv）</li></ul><blockquote><p>ARGV    Array of command line arguments.  The array is indexed from 0 to ARGC - 1.  Dynam‐<br>                 ically changing the contents of ARGV can control the files used for data.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line">[baiyongan@bya awk_test]$ awk &#x27;FILENAME==ARGV[1]&amp;&amp;FNR==1 &#123;print $0&#125; FILENAME==ARGV[2]&amp;&amp;FNR==2 &#123;print $0&#125; FILENAME==ARGV[3]&amp;&amp;FNR==3 &#123;print $0&#125;&#x27; input.txt input_time.txt input_3.txt </span><br><span class="line">one</span><br><span class="line">89</span><br><span class="line">file3 line3</span><br><span class="line">[baiyongan@bya awk_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="合并两个文件"><a href="#合并两个文件" class="headerlink" title="合并两个文件"></a>合并两个文件</h3><p>Q: /etc/passwd 中的第二个域是用 x 来代替的，表示账户对应的密码，/etc/shadow 文件中第二个域，则存储着具体的密码信息，如何用密码来替换掉 x 呢？</p><p>A：</p><p>第一部分：BEGIN {OFS=FS=”:”}</p><p>第二部分：NR==FNR {a[$1]=$2}</p><p>第三部分：NR&gt;FNR {$2=a[$1]; print}</p><ul><li>第一部分，设定OFS（输出字段分隔符） 和 FS（字段分隔符） 都为 “:”。</li><li>第二部分，NR==FNR {a[$1]=$2}。其中NR==FNR 表示awk输入的第一个文件。{a[$1]=$2}执行，则awk会把文件的第二个字段，存放到下标为$1（文件的第一个字段的值）的数组a中。</li><li>第三部分，NR&gt;FNR {$2=a[$1]; print}。其中，NR&gt;FNR表示awk输入的第二个文件。桑awk在处理第二个文件时， {$2=a[$1]; print}，awk会把下标为$1（文件的第一个字段的值）的数组a 中取出内容赋值给 $2 (文件的第一个字段)，最后输出替换后的文件内容。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@bya awk_test]# cat /etc/shadow | head -n 5</span><br><span class="line">root:$6$BzPXls0eBogVmwQz$iCAbjP1CE4ANU35SWcdzo.//3Fm5Bg/MnzKyWEF1rPLTtuMxFwqH2lwbZyCsNAkbAtCQnIUG9MwV98fJ/WOu1.::0:99999:7:::</span><br><span class="line">bin:*:17110:0:99999:7:::</span><br><span class="line">daemon:*:17110:0:99999:7:::</span><br><span class="line">adm:*:17110:0:99999:7:::</span><br><span class="line">lp:*:17110:0:99999:7:::</span><br><span class="line">[root@bya awk_test]# </span><br><span class="line">[root@bya awk_test]# cat /etc/passwd | head -n 5</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">[root@bya awk_test]# </span><br><span class="line">[root@bya awk_test]# awk &#x27;BEGIN &#123;OFS=FS=&quot;:&quot;&#125; NR==FNR &#123;a[$1]=$2&#125; NR&gt;FNR &#123;$2=a[$1]; print&#125;&#x27; /etc/shadow /etc/passwd | head -n 5</span><br><span class="line">root:$6$BzPXls0eBogVmwQz$iCAbjP1CE4ANU35SWcdzo.//3Fm5Bg/MnzKyWEF1rPLTtuMxFwqH2lwbZyCsNAkbAtCQnIUG9MwV98fJ/WOu1.:0:0:root:/root:/bin/bash</span><br><span class="line">bin:*:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:*:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:*:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:*:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">[root@bya awk_test]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="合并两文件并求和"><a href="#合并两文件并求和" class="headerlink" title="合并两文件并求和"></a>合并两文件并求和</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@bya awk_test]# cat 1.txt </span><br><span class="line">92 33 44</span><br><span class="line">20 30 45</span><br><span class="line">[root@bya awk_test]# cat 2.txt </span><br><span class="line">23 45 56</span><br><span class="line">35 56 89</span><br><span class="line">[root@bya awk_test]# awk &#x27;&#123;for(i=1;i&lt;=NF;i++) a[i]=$i; getline &lt;&quot;1.txt&quot;; for(i=1;i&lt;=NF;i++) printf a[i]+$i&quot; &quot;; printf &quot;\n&quot;&#125;&#x27; 2.txt </span><br><span class="line">115 78 100 </span><br><span class="line">55 86 134 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="外部调用"><a href="#外部调用" class="headerlink" title="外部调用"></a>外部调用</h2><p>实现awk 外部调用的两种方式：</p><ul><li>通过getline 引用外部数据；</li><li>通过 system 调用 shell的命令。</li></ul><h3 id="getline操作文件的困惑"><a href="#getline操作文件的困惑" class="headerlink" title="getline操作文件的困惑"></a>getline操作文件的困惑</h3><blockquote><p>   <strong>getline               Set $0 from next input record; set NF, NR, FNR.</strong></p><p>   getline &lt;file         Set $0 from next record of file; set NF.</p><p>   getline var           Set var from next input record; set NR, FNR.</p><p>   getline var &lt;file     Set var from next record of file.</p><p>   command | getline [var]<br>                         Run command piping the output either into $0 or var, as above.</p><p>   command |&amp; getline [var]<br>                         Run command as a co-process piping the output either into $0 or var, as above.  Co-processes are a gawk extension.  (command can also be a socket.  See the  subsection  Special<br>                         File Names, below.)</p></blockquote><p><strong>当只有 getline时，getline是针对当前打开的文件操作，表示读取当前行的下一行数据，并把读取到的数据赋值给$0，同时更新 NF，NR，FNR。</strong></p><p>因此，</p><p><strong>‘{print; getline}’</strong> 输出奇数行</p><p><strong>‘{getline; print}’</strong> 输出偶数行</p><p><strong>‘{print; getline; print}’</strong>  输出全部行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@bya awk_test]# cat -n test | awk &#x27;&#123;print&#125;&#x27;</span><br><span class="line">     1a</span><br><span class="line">     2b</span><br><span class="line">     3c</span><br><span class="line">     4d</span><br><span class="line">[root@bya awk_test]# cat -n test | awk &#x27;&#123;getline; print&#125;&#x27;</span><br><span class="line">     2b</span><br><span class="line">     4d</span><br><span class="line">[root@bya awk_test]# cat -n test | awk &#x27;&#123;print; getline&#125;&#x27;</span><br><span class="line">     1a</span><br><span class="line">     3c</span><br><span class="line">[root@bya awk_test]# cat -n test | awk &#x27;&#123;print; getline; print&#125;&#x27; </span><br><span class="line">     1a</span><br><span class="line">     2b</span><br><span class="line">     3c</span><br><span class="line">     4d</span><br><span class="line">[root@bya awk_test]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在getline之后，添加变量 b，则有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@bya awk_test]# cat -n test </span><br><span class="line">     1a</span><br><span class="line">     2b</span><br><span class="line">     3c</span><br><span class="line">     4d</span><br><span class="line">[root@bya awk_test]# cat -n test | awk &#x27;&#123;print; getline b; print&#125;&#x27;</span><br><span class="line">     1a</span><br><span class="line">     1a</span><br><span class="line">     3c</span><br><span class="line">     3c</span><br><span class="line">[root@bya awk_test]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>getline 后面跟着变量b，表示获取到的数据不会赋值给$0,而会给变量b；</li><li>两个print 用来输出 $0,$0的数据没有改变，则输出了重复的字母。</li></ul><p>如下，已经不需要解释，就可以正确解读了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@bya awk_test]# cat -n test | awk &#x27;&#123;print; getline b; print; print b&#125;&#x27;</span><br><span class="line">     1a</span><br><span class="line">     1a</span><br><span class="line">     2b</span><br><span class="line">     3c</span><br><span class="line">     3c</span><br><span class="line">     4d</span><br><span class="line">[root@bya awk_test]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="getline操作文件的返回值"><a href="#getline操作文件的返回值" class="headerlink" title="getline操作文件的返回值"></a>getline操作文件的返回值</h3><p>先看如下案例，while语句表示，当文件test输出一行，文件 1.txt 的内容就要重新输出一遍，但为什么只有第一行是这样的，而其他行，1.txt的内容完全没有输出呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@bya awk_test]# cat 1.txt </span><br><span class="line">92 33 44</span><br><span class="line">20 30 45</span><br><span class="line">[root@bya awk_test]# cat test </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">[root@bya awk_test]# awk &#x27;&#123;print $0; while((getline &lt; &quot;1.txt&quot;) &gt; 0) print $0&#125;&#x27; test</span><br><span class="line">a</span><br><span class="line">92 33 44</span><br><span class="line">20 30 45</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">[root@bya awk_test]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实，getline的返回值：</p><ul><li>1：表示正常读取一行数据。</li><li>0：表示到了文件末尾。</li><li>-1：表示读取遇到错误。</li></ul><p><strong>p.s.</strong>  getline重定向文件时，后面必须跟字符串类型。因此，文件1.txt一定要加上双引号！</p><h3 id="用system-调用-shell"><a href="#用system-调用-shell" class="headerlink" title="用system 调用 shell"></a>用system 调用 shell</h3><p>awk可以直接通过system()调用shell，但是有两点要注意：</p><ul><li>awk 无法直接将脚本中的数据直接输出给shell命令；</li><li>shell 命令的执行结果也无法直接输入到awk脚本中。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@bya awk_test]# awk &#x27;BEGIN &#123; system(&quot;ls -l&quot;)&#125;&#x27;</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root      root       18 May 30 21:22 1.txt</span><br><span class="line">-rw-r--r-- 1 root      root       18 May 30 21:22 2.txt</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan  48 May 30 20:46 input_3.txt</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 103 May 30 19:17 input_time.txt</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan  49 May 30 16:42 input.txt</span><br><span class="line">-rwxrw-r-- 1 baiyongan baiyongan 145 May 30 15:48 student.awk</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 165 May 30 14:43 student.txt</span><br><span class="line">[root@bya awk_test]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>其实，将awk 与其他命令结合起来，才能体现出awk的强大之处。例如结合下面的网络相关的命令</p><ul><li><strong>ifconfig</strong></li><li><strong>netstat</strong></li><li><strong>tcpdump</strong></li><li><strong>/proc/net/dev</strong></li></ul><h3 id="显示本机的IP"><a href="#显示本机的IP" class="headerlink" title="显示本机的IP"></a>显示本机的IP</h3><h3 id="统计网卡的流量"><a href="#统计网卡的流量" class="headerlink" title="统计网卡的流量"></a>统计网卡的流量</h3><h3 id="查看TCP连接状态"><a href="#查看TCP连接状态" class="headerlink" title="查看TCP连接状态"></a>查看TCP连接状态</h3><h3 id="查找请求数排名前五的IP地址"><a href="#查找请求数排名前五的IP地址" class="headerlink" title="查找请求数排名前五的IP地址"></a>查找请求数排名前五的IP地址</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bya awk_test]# netstat -anlp | grep 80 | grep tcp | awk &#x27;&#123;print $5&#125;&#x27; | awk -F : &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c |sort -nr | head -n 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用tcpdump嗅探80端口的访问"><a href="#用tcpdump嗅探80端口的访问" class="headerlink" title="用tcpdump嗅探80端口的访问"></a>用tcpdump嗅探80端口的访问</h3><p>tcpdump 是 Linux工程师非常常用的流量分析工具。</p><h3 id="锁定-time-wait-连接较多的源IP"><a href="#锁定-time-wait-连接较多的源IP" class="headerlink" title="锁定 time_wait 连接较多的源IP"></a>锁定 time_wait 连接较多的源IP</h3><h3 id="根据端口列进程"><a href="#根据端口列进程" class="headerlink" title="根据端口列进程"></a>根据端口列进程</h3><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>黑体的部分掌握即可应付80%的场景</p><p><strong>awk的功能</strong></p><p><strong>命令格式 + 工作原理 + 执行过程</strong></p><p><strong>常用选项</strong></p><p><strong>内置变量</strong></p><p>运算</p><p><strong>高级输入输出功能</strong></p><p><strong>循环结构</strong></p><p>数组</p><p>内置函数</p><p>字符串函数</p><p>时间函数</p><p>其他一般函数</p><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><p><a href="https://www.cnblogs.com/quincyhu/p/5884390.html"><strong>shell编程之awk命令详解</strong></a></p><p><a href="http://www.zsythink.net/archives/tag/awk/"><strong>awk从放弃到入门</strong></a></p><p><a href="https://www.gnu.org/software/gawk/manual/gawk.html"><strong>The GNU Awk User’s Guide</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列——文本处理三剑客之一 sed</title>
      <link href="/2020/05/27/linux/command-sed/"/>
      <url>/2020/05/27/linux/command-sed/</url>
      
        <content type="html"><![CDATA[<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p>sed 是 stream editor的简写，中文称之为“流编辑器”。</p><p>sed命令是一个面向行处理的工具，以“行”为处理单位，针对每一行进行处理，处理后的结果默认输出道标准输出（STDOUT）。</p><p>基本格式为 <code>sed command file</code></p><p>command部分：指针对每行的内容所要进行的处理，为该命令的精髓所在，共分为两块知识：一块是范围设定，一块是动作处理。</p><p>file部分：指要处理的文件，如果忽略file参数，则sed会把标准输入作为处理对象</p><span id="more"></span><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><h3 id="sed-的工作原理"><a href="#sed-的工作原理" class="headerlink" title="sed 的工作原理"></a>sed 的工作原理</h3><p>sed 命令每次处理时，会把要处理的行存储到缓冲区间，接着用sed命令处理缓冲区中的内容，处理完成之后，把缓冲区的内容送往屏幕。接着处理下一行，不断重复，直至文件末尾。这个缓冲区称为 “模式空间”（pattern space）。</p><p>工作原理详解见 文章： <a href="https://www.linuxidc.com/Linux/2017-09/146906.htm"><strong>《Linux 公社：Linux基础知识：sed命令》</strong></a></p><h3 id="sed实现cut命令的效果"><a href="#sed实现cut命令的效果" class="headerlink" title="sed实现cut命令的效果"></a>sed实现cut命令的效果</h3><p>想实现 cut -d ： -f /etc/passwd 的效果，使用sed 如何操作？主要用到了 sed ‘s/XXX/YYY/‘ 这个用法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ head -n 5 /etc/passwd </span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">[baiyongan@bya sed_test]$ head -n 5 /etc/passwd | cut -d : -f 1 </span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">[baiyongan@bya sed_test]$ head -n 5 /etc/passwd | sed &#x27;s/:.*$//&#x27;</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sed的常用选项"><a href="#sed的常用选项" class="headerlink" title="sed的常用选项"></a>sed的常用选项</h3><h4 id="n-选项，只显示被匹配的行"><a href="#n-选项，只显示被匹配的行" class="headerlink" title="-n 选项，只显示被匹配的行"></a>-n 选项，只显示被匹配的行</h4><blockquote><p> -n, –quiet, –silent</p><p>​          suppress automatic printing of pattern space</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat roc.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">[baiyongan@bya sed_test]$ sed &#x27;/4/p&#x27; roc.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">[baiyongan@bya sed_test]$ sed -n &#x27;/4/p&#x27; roc.txt </span><br><span class="line">4</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br></pre></td></tr></table></figure><h3 id="command部分详解"><a href="#command部分详解" class="headerlink" title="command部分详解"></a>command部分详解</h3><p>command 有两部分知识：一块是范围设定，一块是动作处理。</p><p>范围设定：</p><ul><li>指定行数：比如 ‘3,5’ 表示第3，4，5 行， 而 <code>&#39;5，$&#39;</code> 表示第5至文件最后一行。</li><li>模式匹配：比如<code>/^[^dD]/</code> 表示匹配行首不以d 或者 D 开头的行。 </li></ul><p>动作处理部分：提供丰富的动作以供选择，几种常见的有：</p><ul><li>d：删除行</li></ul><blockquote><p>d      Delete pattern space.  Start next cycle.</p></blockquote><ul><li>p：打印行</li></ul><blockquote><p>​    p      Print the current pattern space.</p></blockquote><ul><li>r：读取指定文件的内容</li></ul><blockquote><p>   r filename<br>              Append text read from filename.</p></blockquote><ul><li>w：写入指定文件</li></ul><blockquote><p>   w filename<br>          Write the current pattern space to filename.</p></blockquote><ul><li>a：在下面插入新行新内容</li></ul><blockquote><p>   a \</p><p>   text   Append text, which has each embedded newline preceded by a backslash.</p></blockquote><h3 id="几个案例"><a href="#几个案例" class="headerlink" title="几个案例"></a>几个案例</h3><h4 id="显示指定行区间的内容"><a href="#显示指定行区间的内容" class="headerlink" title="显示指定行区间的内容"></a>显示指定行区间的内容</h4><p>例如，显示/etc/passwd文件第10 ~20 行的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ sed -n &#x27;10,20p&#x27; /etc/passwd</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin</span><br><span class="line">dbus:x:81:81:System message bus:/:/sbin/nologin</span><br><span class="line">polkitd:x:999:998:User for polkitd:/:/sbin/nologin</span><br><span class="line">abrt:x:173:173::/etc/abrt:/sbin/nologin</span><br><span class="line">libstoragemgmt:x:998:996:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin</span><br><span class="line">rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin</span><br><span class="line">colord:x:997:995:User for colord:/var/lib/colord:/sbin/nologin</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="匹配并替换"><a href="#匹配并替换" class="headerlink" title="匹配并替换"></a>匹配并替换</h4><p>将所有以d或者D开头的行里面的所有小写x 字符，变为 大写 X字符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^[dD]/s/x/X/g&#x27;  test</span><br></pre></td></tr></table></figure><h4 id="删除每行最后的两个字符"><a href="#删除每行最后的两个字符" class="headerlink" title="删除每行最后的两个字符"></a>删除每行最后的两个字符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/..$//&#x27; test</span><br></pre></td></tr></table></figure><h4 id="删除每行的前两个字符"><a href="#删除每行的前两个字符" class="headerlink" title="删除每行的前两个字符"></a>删除每行的前两个字符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/..//&#x27; test</span><br></pre></td></tr></table></figure><h3 id="amp-符号拼接"><a href="#amp-符号拼接" class="headerlink" title="&amp; 符号拼接"></a>&amp; 符号拼接</h3><blockquote><p>   <strong>s/regexp/replacement/</strong>          </p><p>​          Attempt to match regexp against the pattern space.  If successful, replace that portion<br>​          matched with replacement.  The replacement may contain the special character &amp; to refer<br>​          to  that portion of the pattern space which matched, and the special escapes \1 through<br>​          \9 to refer to the corresponding matching sub-expressions in the regexp.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat mysed.txt </span><br><span class="line">Beijing</span><br><span class="line">London</span><br><span class="line">[baiyongan@bya sed_test]$ sed &#x27;s/Bei/&amp;2008/&#x27; mysed.txt </span><br><span class="line">Bei2008jing</span><br><span class="line">London</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="小括号-sed的预存储技术"><a href="#小括号-sed的预存储技术" class="headerlink" title="() 小括号 sed的预存储技术"></a>() 小括号 sed的预存储技术</h3><p>命令中，被“（”，“）” 括起来的内容，会被以此暂存起来，存储到\1, \2, 里面。这样，就可以使用 \N 来调用这些预存储的内容了。</p><p>如下，只在每行的第一个和最后一个Beijing 后面加上 2008 字符串。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat mysed.txt </span><br><span class="line">Beijing Beijing Beijing Beijing</span><br><span class="line">London London London London</span><br><span class="line">[baiyongan@bya sed_test]$ sed &quot;s/\(Beijing\)\(.*\)\(Beijing\)/\12008\2\32008/&quot; mysed.txt </span><br><span class="line">Beijing2008 Beijing Beijing Beijing2008</span><br><span class="line">London London London London</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更聪明的定位行范围"><a href="#更聪明的定位行范围" class="headerlink" title="更聪明的定位行范围"></a>更聪明的定位行范围</h3><p>匹配 2005 ~2007 之间的行内容， 如下，只能匹配第一个2007，并没有匹配到第二个2007。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ sed -n &#x27;/2005/,/2007/p&#x27; mysed.txt </span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br></pre></td></tr></table></figure><h3 id="用-e-选项设置多个-command"><a href="#用-e-选项设置多个-command" class="headerlink" title="用 -e 选项设置多个 command"></a>用 -e 选项设置多个 command</h3><blockquote><p>   -e script, –expression=script</p><p>​      add the script to the commands to be executed</p></blockquote><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ sed -n -e &#x27;1,2p&#x27; -e &#x27;4p&#x27; mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2006</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br></pre></td></tr></table></figure><h4 id="e-选项-的执行顺序是按照从左至右依此进行的"><a href="#e-选项-的执行顺序是按照从左至右依此进行的" class="headerlink" title="-e 选项 的执行顺序是按照从左至右依此进行的"></a>-e 选项 的执行顺序是按照从左至右依此进行的</h4><p>如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ sed -e &#x27;s/Beijing/London/g&#x27; -e &#x27;/Beijing/d&#x27; mysed.txt </span><br><span class="line">London 2003</span><br><span class="line">London 2004</span><br><span class="line">London 2005</span><br><span class="line">London 2006</span><br><span class="line">London 2007</span><br><span class="line">London 2008</span><br><span class="line">London 2007</span><br><span class="line">London 2009</span><br><span class="line">[baiyongan@bya sed_test]$ sed -e &#x27;/Beijing/d&#x27; -e &#x27;s/Beijing/London/g&#x27; mysed.txt </span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用-f-选项-设定-command-文件"><a href="#用-f-选项-设定-command-文件" class="headerlink" title="用 -f 选项 设定 command 文件"></a>用 -f 选项 设定 command 文件</h3><blockquote><p>   -f script-file, –file=script-file</p><p>​      add the contents of script-file to the commands to be executed</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat callsed </span><br><span class="line">/2004/,/2006/p</span><br><span class="line">[baiyongan@bya sed_test]$ sed -n -f callsed mysed.txt </span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入和控制功能"><a href="#插入和控制功能" class="headerlink" title="插入和控制功能"></a>插入和控制功能</h3><h4 id="使用-r动作-，在处理行后面插入内容"><a href="#使用-r动作-，在处理行后面插入内容" class="headerlink" title="使用 r动作 ，在处理行后面插入内容"></a>使用 <code>r</code>动作 ，在处理行后面插入内容</h4><blockquote><p>   r filename<br>          Append text read from filename.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ echo &quot;===China===&quot; &gt; ins.txt</span><br><span class="line">[baiyongan@bya sed_test]$ cat ins.txt </span><br><span class="line">===China===</span><br><span class="line">[baiyongan@bya sed_test]$ sed &#x27;/2005/r ins.txt&#x27; mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">===China===</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用-a-动作，-在匹配行后面加上要插入的内容。"><a href="#使用-a-动作，-在匹配行后面加上要插入的内容。" class="headerlink" title="使用 a \动作， 在匹配行后面加上要插入的内容。"></a>使用 <code>a \</code>动作， 在匹配行后面加上要插入的内容。</h4><blockquote><p>   a \</p><p>   text   Append text, which has each embedded newline preceded by a backslash.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ sed &#x27;/2004/a\China&#x27; mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">China</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="亦可以使用-i-动作，在匹配行的前面加上要插入的内容。"><a href="#亦可以使用-i-动作，在匹配行的前面加上要插入的内容。" class="headerlink" title="亦可以使用 i\ 动作，在匹配行的前面加上要插入的内容。"></a>亦可以使用 <code>i\</code> 动作，在匹配行的前面加上要插入的内容。</h4><blockquote><p>   i \</p><p>   text   Insert text, which has each embedded newline preceded by a backslash.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ sed &#x27;/2004/i\China&#x27; mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">China</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="y动作"><a href="#y动作" class="headerlink" title="y动作"></a><code>y</code>动作</h4><blockquote><p>   y/source/dest/<br>          Transliterate  the characters in the pattern space which appear in source to the corre‐<br>          sponding character in dest.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ sed &#x27;y/ei/ie/&#x27; mysed.txt </span><br><span class="line">Biejeng 2003</span><br><span class="line">Biejeng 2004</span><br><span class="line">Biejeng 2005</span><br><span class="line">Biejeng 2006</span><br><span class="line">Biejeng 2007</span><br><span class="line">Biejeng 2008</span><br><span class="line">Biejeng 2007</span><br><span class="line">Biejeng 2009</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br></pre></td></tr></table></figure><h4 id="y-和-s-的区别？"><a href="#y-和-s-的区别？" class="headerlink" title="y/// 和 s/// 的区别？"></a>y/// 和 s/// 的区别？</h4><p>y的语法格式是 y/source/dest/ ，表示将source 中的字符对位替换为dest中的字符。</p><p>s的语法格式是 s/regexp/replacement/，表示通过正则匹配到的内容替换为 replacement部分。</p><p>y只是简单的逐字替换，s则支持 &amp; 符号和预存处等特性。</p><p>注意，如果 source 部分出现了重复的字符，则只有第一次出现的对位替换，会产生效果，后面的并不会起作用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ sed &#x27;y/iji/iba/&#x27; mysed.txt </span><br><span class="line">Beibing 2003</span><br><span class="line">Beibing 2004</span><br><span class="line">Beibing 2005</span><br><span class="line">Beibing 2006</span><br><span class="line">Beibing 2007</span><br><span class="line">Beibing 2008</span><br><span class="line">Beibing 2007</span><br><span class="line">Beibing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="通过-n动作控制行的下移"><a href="#通过-n动作控制行的下移" class="headerlink" title="通过 n动作控制行的下移"></a>通过 <code>n</code>动作控制行的下移</h4><p>隔行处理 ，比如只需对偶数行进行某个替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ cat mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ sed &#x27;/200/&#123;n;y/eijing/EIJING/;&#125;&#x27; mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">BEIJING 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">BEIJING 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">BEIJING 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">BEIJING 2009</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>n的真实作用，是将下一行内容放在处理缓存中，这样，就让当前这一行躲避开了替换动作。</p><h3 id="将指定行写入到特定文件中"><a href="#将指定行写入到特定文件中" class="headerlink" title="将指定行写入到特定文件中"></a>将指定行写入到特定文件中</h3><p><code>w</code>动作，将匹配到的内容写入到另一个文件中，用来实现内容的筛选与保存</p><blockquote><p>   w filename<br>          Write the current pattern space to filename.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line">[baiyongan@bya sed_test]$ sed &#x27;/200[4-6]/w new.txt&#x27; mysed.txt </span><br><span class="line">Beijing 2003</span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2008</span><br><span class="line">Beijing 2007</span><br><span class="line">Beijing 2009</span><br><span class="line">[baiyongan@bya sed_test]$ cat new.txt </span><br><span class="line">Beijing 2004</span><br><span class="line">Beijing 2005</span><br><span class="line">Beijing 2006</span><br><span class="line">[baiyongan@bya sed_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://blog.csdn.net/bbwangj/article/details/78620859"><strong>CSDN-Linux三剑客之sed命令详解及相关实例</strong></a></p><p><a href="https://www.linuxidc.com/Linux/2017-09/146906.htm"><strong>《Linux 公社：Linux基础知识：sed命令》</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的编程内功与外功(转载自知乎)</title>
      <link href="/2020/05/24/engineering/programmer-roadmap/"/>
      <url>/2020/05/24/engineering/programmer-roadmap/</url>
      
        <content type="html"><![CDATA[<h2 id="编程的内功"><a href="#编程的内功" class="headerlink" title="编程的内功"></a>编程的内功</h2><h3 id="编程通用性的知识"><a href="#编程通用性的知识" class="headerlink" title="编程通用性的知识"></a>编程通用性的知识</h3><ul><li>字符串处理</li><li>正则表达式</li><li>变量与常量</li><li>控制语句if-else</li><li>循环</li><li>函数/方法</li><li>类/对象/接口</li><li>递归</li><li>哈希表</li><li>数组</li></ul><span id="more"></span><h3 id="工具类的内功"><a href="#工具类的内功" class="headerlink" title="工具类的内功"></a>工具类的内功</h3><ul><li>构建工具 （通用知识）</li><li>单元测试 （通用知识）</li><li>依赖包管理 （通用知识）</li><li>MVC 框架 （通用知识）</li><li>代码质量检测 （通用知识）</li><li>JSON 和 XML 设计 （通用知识）</li><li>代码控制 （通用知识）</li></ul><h3 id="IT外的相关知识"><a href="#IT外的相关知识" class="headerlink" title="IT外的相关知识"></a>IT外的相关知识</h3><ul><li>数学（离散数学，几何学）</li><li>物理</li><li>图形处理</li><li>图形/UI设计</li></ul><p>等等，这些都是可以各种语言内都能交叉使用的共同的知识。这些知识学好了，大部分语言都可以用到，也都能或多或少在项目和应用中体现出来。</p><h2 id="编程的外功"><a href="#编程的外功" class="headerlink" title="编程的外功"></a>编程的外功</h2><p>包括有：</p><ul><li>各种编程语言包括C++，javascript，java，php，C#，perl，python等</li><li>各种编程环境，.NET, WAMP/LAMP，node.js 等</li><li>各种 IDE 和编辑器，notepad++，vim，Visual Studio，Sublime等</li><li>各种快捷键</li><li>各种包依赖管理器，npm，composer,Nuget</li><li>各种版本管理器：git，svn，cvs</li><li>各种单元测试工具</li><li>各种构建工具</li><li>各种MVC框架 </li></ul><p>等等。</p><p>外功就是一个个的独立工具的使用知识。其实就是一个和内功的具体实现，具体的外功是抽象内功的具体实现。使用这些工具，你可以实践你的内功。</p><p>由于内功的通用性很高，所以比如说你在 java 中能实现的数据结构，你可以立刻在 C# 中复制出一样的数据结构，如果再学了一个新的语言，比如说 python，ruby，也能很快实现出一样的数据结构来。因为是相通的。 内功就是你在一个工具里面能实现的东西，在另外的那个工具也能同样实现的东西。</p><p>另外，内功学好了，学习新的语言或者工具会很快，这是因为，所有的编程语言和工具都有很多共同点，知识语法改了一改，当然还有一些特有的特性，是要你针对学的。所以假设当你还没有学习java或者C#的时候，你学java需要一年时间，学习C#也同样需要一年时间，但是如果先学习了java后，在学习C#（或先学C#再学java）， 两个先后学习的时间总共只要1年2-3个月的时间，而不是2年。这是因为你用Java去学习语言的共性，修炼了编程的内功。</p><p>内功学好了，内功比外功重要，那要学习外功吗？ 要，当然要，还要好好的学。因为你是通过外功来学习内功的。没有语言本身，那里表现内功的载体呢。当你把一种语言作为载体，把所有语言的共性都学完了，然后就关注特定语言的特性了，有了内功的基础，这些外功很容易就啃完了，然后具体问题具体分析解决。比如要跨平台的桌面程序，用Java；快速网站构建，用PHP；嵌入式编程，用C；网页内编程用javascript;  然后还有不同语言之间的通信，用json或者xml。</p><p>而那些工具，可以辅助你的编程技巧，加速你的编程速度，提高你的编程质量，使你的编程得心应手，享受编程带来的乐趣。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>编程的学习和提高，应该重点在编程内功上</strong>。通过某个编程语言和工具，去学习研究编程的通用功能和共性上。这样就算未来有新的语言和技术出现，也能很快的适应新的语言和技术了。</p><p>而外功的提高，是可以大大提高自己的工作效率，它和内功相辅相成。外功作为辅助和内功的载体，也是很重要的。毕竟它可能是一个程序员吃饭看家领工资最具体的技术表现。</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://www.zhihu.com/question/22471978"><strong>知乎—程序员的编程内功和外功有哪些？如何看待编程内功和外功的关系？</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Resource </category>
          
          <category> Roadmap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列——paste 粘贴</title>
      <link href="/2020/05/24/linux/command-paste/"/>
      <url>/2020/05/24/linux/command-paste/</url>
      
        <content type="html"><![CDATA[<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p>paste单词意思是粘贴。该命令主要用来将多个文件的内容合并，与cut命令完成的功能刚好相反。就是将几个文件的相应行用拼接间隔符(默认是制表符(Tab)) 连接起来，并输出到标准输出。</p><span id="more"></span><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya paste_test]$ cat p1.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[baiyongan@bya paste_test]$ cat p2.txt </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">[baiyongan@bya paste_test]$ paste p1.txt p2.txt </span><br><span class="line">1a</span><br><span class="line">2b</span><br><span class="line">3c</span><br><span class="line">[baiyongan@bya paste_test]$ paste p1.txt p2.txt | sed -n l # 使用制表符进行分隔</span><br><span class="line">1\ta$</span><br><span class="line">2\tb$</span><br><span class="line">3\tc$</span><br><span class="line">[baiyongan@bya paste_test]$ </span><br></pre></td></tr></table></figure><h3 id="行数不同的文件如何拼接"><a href="#行数不同的文件如何拼接" class="headerlink" title="行数不同的文件如何拼接"></a>行数不同的文件如何拼接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya paste_test]$ cat s1.txt </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">[baiyongan@bya paste_test]$ cat s2.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[baiyongan@bya paste_test]$ paste s1.txt s2.txt </span><br><span class="line">a1</span><br><span class="line">b2</span><br><span class="line">c3</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">[baiyongan@bya paste_test]$ paste s2.txt s1.txt </span><br><span class="line">1a</span><br><span class="line">2b</span><br><span class="line">3c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">[baiyongan@bya paste_test]$ </span><br></pre></td></tr></table></figure><p>拼接的顺序对输出有影响；</p><p>也可以拼接多个文件</p><h3 id="拼接符的替换"><a href="#拼接符的替换" class="headerlink" title="拼接符的替换"></a>拼接符的替换</h3><p>-d 选项 可以设定间隔符</p><blockquote><p>   -d, –delimiters=LIST<br>          reuse characters from LIST instead of TABs</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya paste_test]$ paste -d &#x27;*&#x27; p3.txt p1.txt p2.txt </span><br><span class="line">I*1*a</span><br><span class="line">II*2*b</span><br><span class="line">III*3*c</span><br><span class="line">[baiyongan@bya paste_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="paste-的-s-选项"><a href="#paste-的-s-选项" class="headerlink" title="paste 的 -s 选项"></a>paste 的 -s 选项</h3><p> -s 选项，以每个文件自身作为处理单元，将文件中的所有行，以 -d 选项设定的间隔符拼接成一个大行，并输出到标准输出中。 </p><blockquote><p>  -s, –serial<br>          paste one file at a time instead of in parallel</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya paste_test]$ cat p1.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[baiyongan@bya paste_test]$ cat p2.txt </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">[baiyongan@bya paste_test]$ cat p3.txt </span><br><span class="line">I</span><br><span class="line">II</span><br><span class="line">III</span><br><span class="line">[baiyongan@bya paste_test]$ paste -s -d &quot;*&quot; p*</span><br><span class="line">1*2*3</span><br><span class="line">a*b*c</span><br><span class="line">I*II*III</span><br><span class="line">[baiyongan@bya paste_test]$ </span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列—— split 拆分</title>
      <link href="/2020/05/24/linux/command-split/"/>
      <url>/2020/05/24/linux/command-split/</url>
      
        <content type="html"><![CDATA[<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p>Linux中，有时需要将文件分割成更小的片段，比如为提高可读性，生成日志。使用 split命令，则可以将一个大文件分割成指定大小的很多个小文件，如果是文本文件，也可以按照行数进行拆分，默认是1000行作为一个拆分单位。</p><span id="more"></span><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><h3 id="命令格式与常用选项"><a href="#命令格式与常用选项" class="headerlink" title="命令格式与常用选项"></a>命令格式与常用选项</h3><blockquote><h4 id="split-b-C-l-要切割的文件-输出文件名前缀-a"><a href="#split-b-C-l-要切割的文件-输出文件名前缀-a" class="headerlink" title="split [ -b ] [ -C ] [ - ] [ -l ] [ 要切割的文件 ] [ 输出文件名前缀 ] [ -a ]"></a>split [ -b ] [ -C ] [ - ] [ -l ] [ 要切割的文件 ] [ 输出文件名前缀 ] [ -a ]</h4></blockquote><ul><li><p>-b &lt;字节&gt; :指定按照多少字节进行拆分，也可指定 K，M，G，T单位</p><p> -b, –bytes=SIZE</p><pre><code>put SIZE bytes per output file</code></pre></li><li><p>-&lt;行数&gt; 或 -l &lt;行数&gt; ：指定每多少行要拆分成一个文件</p><p> -l, –lines=NUMBER</p><pre><code>put NUMBER lines per output file</code></pre></li><li><p>输出文件名前缀：设置拆分后的文件的名称前缀，split会自动在前缀后加上编号，默认从aa开始</p></li><li><p>-a&lt;后缀长度&gt;：默认的后缀长度是2，也就是按照aa、ab、ac这样的格式依此编号</p><p> -a, –suffix-length=N</p><pre><code>generate suffixes of length N (default 2)</code></pre></li></ul><h3 id="拆分文件与合并"><a href="#拆分文件与合并" class="headerlink" title="拆分文件与合并"></a>拆分文件与合并</h3><p>如下，dd命令生成一个700M的文件，用400M单位拆分成两个文件，然后再合并为新文件，比较。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya split_test]$ dd if=/dev/zero bs=1024 count=700000 of=test_large_file</span><br><span class="line">700000+0 records in</span><br><span class="line">700000+0 records out</span><br><span class="line">716800000 bytes (717 MB) copied, 2.02677 s, 354 MB/s</span><br><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 700000</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:39 test_large_file</span><br><span class="line">[baiyongan@bya split_test]$ split -b 400M test_large_file </span><br><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 1400000</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:39 test_large_file</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 419430400 May 24 11:40 xaa</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 297369600 May 24 11:40 xab</span><br><span class="line">[baiyongan@bya split_test]$ cat xaa xab &gt; test_large_file_merged</span><br><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 2100000</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:39 test_large_file</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:40 test_large_file_merged</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 419430400 May 24 11:40 xaa</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 297369600 May 24 11:40 xab</span><br><span class="line">[baiyongan@bya split_test]$ </span><br></pre></td></tr></table></figure><h3 id="设置拆分文件的名称前、后缀"><a href="#设置拆分文件的名称前、后缀" class="headerlink" title="设置拆分文件的名称前、后缀"></a>设置拆分文件的名称前、后缀</h3><p>如下，以文件名   test_large_file_part_作为前缀， 以及设置数字后缀</p><blockquote><p>   -d, –numeric-suffixes[=FROM]<br>          use numeric suffixes instead of alphabetic; FROM changes the start value (default 0)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya split_test]$ rm -rf xa*</span><br><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 1400000</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:39 test_large_file</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:40 test_large_file_merged</span><br><span class="line">[baiyongan@bya split_test]$ split -b 400M test_large_file test_large_file_part_</span><br><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 2100000</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:39 test_large_file</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:40 test_large_file_merged</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 419430400 May 24 11:42 test_large_file_part_aa</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 297369600 May 24 11:42 test_large_file_part_ab</span><br><span class="line">[baiyongan@bya split_test]$ </span><br><span class="line">[baiyongan@bya split_test]$ rm -rf *part*</span><br><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 1400000</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:39 test_large_file</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:40 test_large_file_merged</span><br><span class="line">[baiyongan@bya split_test]$ split -b 400M -d test_large_file test_large_file_part_</span><br><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 2100000</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:39 test_large_file</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:40 test_large_file_merged</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 419430400 May 24 11:45 test_large_file_part_00</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 297369600 May 24 11:45 test_large_file_part_01</span><br><span class="line">[baiyongan@bya split_test]$ </span><br></pre></td></tr></table></figure><h3 id="按照行数进行拆分"><a href="#按照行数进行拆分" class="headerlink" title="按照行数进行拆分"></a>按照行数进行拆分</h3><p>例如将/etc/passwd 文件每十行进行拆分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya split_test]$ split -d -10 /etc/passwd my_passwd_</span><br><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 2100024</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan       385 May 24 11:47 my_passwd_00</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan       543 May 24 11:47 my_passwd_01</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan       607 May 24 11:47 my_passwd_02</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan       526 May 24 11:47 my_passwd_03</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan       589 May 24 11:47 my_passwd_04</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan        56 May 24 11:47 my_passwd_05</span><br><span class="line">[baiyongan@bya split_test]$ </span><br><span class="line">[baiyongan@bya split_test]$ wc -l my_passwd_*</span><br><span class="line">  10 my_passwd_00</span><br><span class="line">  10 my_passwd_01</span><br><span class="line">  10 my_passwd_02</span><br><span class="line">  10 my_passwd_03</span><br><span class="line">  10 my_passwd_04</span><br><span class="line">   1 my_passwd_05</span><br><span class="line">  51 total</span><br><span class="line">[baiyongan@bya split_test]$ </span><br></pre></td></tr></table></figure><h3 id="合并后的校验"><a href="#合并后的校验" class="headerlink" title="合并后的校验"></a>合并后的校验</h3><p>网络传输大文件，或者再设备之间复制大文件的时候，可能会出现传输前后数据不一致的情况。</p><p>推荐使用md5sum进行计算，比对前后两个大文件的md5 值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya split_test]$ ll</span><br><span class="line">total 2100000</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:49 test_large_file</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 716800000 May 24 11:50 test_large_file_merged</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 419430400 May 24 11:50 test_large_file_part_00</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 297369600 May 24 11:50 test_large_file_part_01</span><br><span class="line">[baiyongan@bya split_test]$ md5sum test_large_file</span><br><span class="line">eacff27bf2db99c7301383b7d8c1c07c  test_large_file</span><br><span class="line">[baiyongan@bya split_test]$ md5sum test_large_file_merged </span><br><span class="line">eacff27bf2db99c7301383b7d8c1c07c  test_large_file_merged</span><br><span class="line">[baiyongan@bya split_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列—— wc 字数统计</title>
      <link href="/2020/05/24/linux/command-wc/"/>
      <url>/2020/05/24/linux/command-wc/</url>
      
        <content type="html"><![CDATA[<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p>wc 命令，全称 word count，功能有限，主要是计算一个文件中的字数，单词数和字节数。</p><p>直接执行 wc 命令 ，输出信息 依此是 <code>行数 词数 字节数 文件名</code></p><span id="more"></span><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><h3 id="实验素材"><a href="#实验素材" class="headerlink" title="实验素材"></a>实验素材</h3><p>准备文件如下，使用 UTF-8 编码</p><p>可见，第一行12个英文半角字符，“hello world”11个字符，加上行尾符$；</p><p>第二行 6个字符，”你好 世界”5个字符，加上行尾符 $。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya wc_test]$ cat wc_test.txt </span><br><span class="line">hello world</span><br><span class="line">你好 世界</span><br><span class="line">[baiyongan@bya wc_test]$ file wc_test.txt </span><br><span class="line">wc_test.txt: UTF-8 Unicode text</span><br><span class="line">[baiyongan@bya wc_test]$ sed -n l wc_test.txt </span><br><span class="line">hello world$</span><br><span class="line">\344\275\240\345\245\275 \344\270\226\347\225\214$</span><br><span class="line">[baiyongan@bya wc_test]$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[baiyongan@bya wc_test]$ wc -c wc_test.txt </span><br><span class="line">26 wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ wc -m wc_test.txt </span><br><span class="line">18 wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ wc -l wc_test.txt </span><br><span class="line">2 wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ wc -w wc_test.txt </span><br><span class="line">4 wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ wc  wc_test.txt </span><br><span class="line"> 2  4 26 wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote><ul><li><p>字节数统计</p><p>-c, –bytes</p><pre><code>print the byte counts</code></pre></li><li><p>字符数统计</p><p> -m, –chars</p><pre><code>print the character counts</code></pre></li><li><p>行数统计</p><p> -l, –lines</p><pre><code>print the newline counts</code></pre></li><li><p>词数统计</p><p> -w, –words</p><pre><code>print the word counts</code></pre></li></ul></blockquote><h3 id="如何找出长度最长的行"><a href="#如何找出长度最长的行" class="headerlink" title="如何找出长度最长的行"></a>如何找出长度最长的行</h3><p>-L 选项，会按照字节数来计算，而非字符数或词数，同时，不会将行尾符$计算在内。</p><blockquote><p>   -L, –max-line-length<br>          print the length of the longest line</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya wc_test]$ cat new_wc_test.txt # 最后 一行有 15 + 2x2 = 19 个字节</span><br><span class="line">hello world</span><br><span class="line">你好 世界</span><br><span class="line">123451234512345你好</span><br><span class="line">[baiyongan@bya wc_test]$ wc -L new_wc_test.txt </span><br><span class="line">19 new_wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="制表符的细节"><a href="#制表符的细节" class="headerlink" title="制表符的细节"></a>制表符的细节</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya wc_test]$ cat new_wc_test.txt </span><br><span class="line">helloworld</span><br><span class="line">[baiyongan@bya wc_test]$ sed -n l new_wc_test.txt </span><br><span class="line">hello\tworld$</span><br><span class="line">[baiyongan@bya wc_test]$ wc -c new_wc_test.txt # 统计字节</span><br><span class="line">12 new_wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ wc -m new_wc_test.txt # 统计字符</span><br><span class="line">12 new_wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ wc -w new_wc_test.txt # 统计词数</span><br><span class="line">2 new_wc_test.txt</span><br><span class="line">[baiyongan@bya wc_test]$ </span><br></pre></td></tr></table></figure><p>使用 -c 时，tab只算一个字符 \t；</p><p>使用 -m 时，视觉上有很多空格，但wc只把它当作一个字符，即制表符；</p><p>使用 -w 时，tab和空格没区别，都被当作间隔对待；</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列——cut 剪切</title>
      <link href="/2020/05/24/linux/command-cut/"/>
      <url>/2020/05/24/linux/command-cut/</url>
      
        <content type="html"><![CDATA[<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p>Linux中，cut命令在文件中负责剪切数据，它以每一行为一个处理对象，这种机制和sed命令一样。</p><span id="more"></span><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><h3 id="cut的定位依据"><a href="#cut的定位依据" class="headerlink" title="cut的定位依据"></a>cut的定位依据</h3><p>所谓的定位依据，就是说，应该如何告诉 cut，想要定位到哪一段内容去进行剪切。</p><p>cut共接受三类定位方法，其定位依据：</p><ul><li><p><strong>按照字节定位，bytes，用-b选项；</strong></p><blockquote><p>   -b, –bytes=LIST</p><pre><code>select only these bytes</code></pre></blockquote></li><li><p><strong>按照字符定位，characters， 用 -c 选项；</strong></p><blockquote><p>   -c, –characters=LIST</p><pre><code>select only these characters</code></pre></blockquote></li><li><p><strong>按照域定位， fileds，用 -f 选项。</strong></p><blockquote><p>   -f, –fields=LIST</p><pre><code>select  only  these  fields;  also print any line that contains no delimiter character,unless the -s option is specified</code></pre></blockquote></li></ul><h3 id="字节定位的技巧"><a href="#字节定位的技巧" class="headerlink" title="字节定位的技巧"></a>字节定位的技巧</h3><p>如下所示，若要提取每一行的第3，4，5，8位的字符，可以如下 “-b 3-5，8” 操作，且cut使用了-b选项之后，cut会先把 -b 后面所有的定位数字按照从小到大的顺序排序，然后再依此提取。所以可以随意颠倒数字顺序，而不改变结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya cut_test]$ who</span><br><span class="line">baiyongan :0           2020-02-11 20:01 (:0)</span><br><span class="line">baiyongan pts/0        2020-05-23 21:07 (:0)</span><br><span class="line">[baiyongan@bya cut_test]$ who | cut -b 3-5,8</span><br><span class="line">iyoa</span><br><span class="line">iyoa</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line">[baiyongan@bya cut_test]$ who | cut -b 8,3-5</span><br><span class="line">iyoa</span><br><span class="line">iyoa</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br></pre></td></tr></table></figure><h3 id="有关定位数字的技巧"><a href="#有关定位数字的技巧" class="headerlink" title="有关定位数字的技巧"></a>有关定位数字的技巧</h3><p>定位数字的设定，非常灵活，比如可以只限定最大定位数或者最小定位数。</p><p>cut 对区间采用的是闭区间，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya cut_test]$ who</span><br><span class="line">baiyongan :0           2020-02-11 20:01 (:0)</span><br><span class="line">baiyongan pts/0        2020-05-23 21:07 (:0)</span><br><span class="line">[baiyongan@bya cut_test]$ who | cut -b -3 # -3 表示 第一字节到第三字节</span><br><span class="line">bai</span><br><span class="line">bai</span><br><span class="line">[baiyongan@bya cut_test]$ who | cut -b 3- # 3- 表示第三字节到结尾</span><br><span class="line">iyongan :0           2020-02-11 20:01 (:0)</span><br><span class="line">iyongan pts/0        2020-05-23 21:07 (:0)</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符定位"><a href="#字符定位" class="headerlink" title="字符定位"></a>字符定位</h3><p>-b 只会以字节（8位二进制）来计算，而 -c 则会以字符为单位来提取内容。</p><p> 当将 -n 与 -b 结合的时候，则不会讲多字节字符拆开</p><ul><li><blockquote><p> -n     with -b: don’t split multibyte characters</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya cut_test]$ cat cut_ch.txt </span><br><span class="line">星期一</span><br><span class="line">星期二</span><br><span class="line">星期三</span><br><span class="line">星期四</span><br><span class="line"></span><br><span class="line">[baiyongan@bya cut_test]$ cut -b 3 cut_ch.txt #用 -b 则会乱码</span><br><span class="line">�</span><br><span class="line">�</span><br><span class="line">�</span><br><span class="line">�</span><br><span class="line"></span><br><span class="line">[baiyongan@bya cut_test]$ cut -c 3 cut_ch.txt # 用 -c 显示正常</span><br><span class="line">一</span><br><span class="line">二</span><br><span class="line">三</span><br><span class="line">四</span><br><span class="line"></span><br><span class="line">[baiyongan@bya cut_test]$ cat cut_ch.txt | cut -nb 1</span><br><span class="line">星</span><br><span class="line">星</span><br><span class="line">星</span><br><span class="line">星</span><br><span class="line"></span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="按域定位"><a href="#按域定位" class="headerlink" title="按域定位"></a>按域定位</h3><p>-b 和 -c 都只能在固定格式的文档中提取信息，而对于非固定格式的文档则束手无策，如 /etc/passwd。</p><p>cut的 -d 、-f 选项，则支持 “设置间隔符”，并指定 “提取第几个域”。</p><blockquote><p>   -d, –delimiter=DELIM<br>          use DELIM instead of TAB for field delimiter</p></blockquote><p>如下，用 -d 设置间隔符，用 -f指定域</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya cut_test]$ cat /etc/passwd | head -n 5</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">[baiyongan@bya cut_test]$ cat /etc/passwd | head -n 5 | cut -d : -f 1 # 提取用户名</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设定 -f选项时，也可以用“3-5”， “-2”等形式</span></span><br><span class="line">[baiyongan@bya cut_test]$ cat /etc/passwd | head -n 5 | cut -d : -f -2</span><br><span class="line">root:x</span><br><span class="line">bin:x</span><br><span class="line">daemon:x</span><br><span class="line">adm:x</span><br><span class="line">lp:x</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何识别空格和制表符"><a href="#如何识别空格和制表符" class="headerlink" title="如何识别空格和制表符"></a>如何识别空格和制表符</h3><p>有时候，文件中出现Tab制表符，是很难察觉的，那么如何区分普通空格和制表符呢？</p><p>可以用 sed -n l 来进行查看， 如果是制表符，则会显示\t, 如果是空格，则原样显示，判断完之后，就可以更准确的去cut了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya cut_test]$ cat tab_space.txt </span><br><span class="line">this is tab finish.</span><br><span class="line">this is serveral space      finish.</span><br><span class="line">[baiyongan@bya cut_test]$ sed -n l tab_space.txt # 其中，l是L的小写，不是数字1</span><br><span class="line">this is tab finish.\t$</span><br><span class="line">this is serveral space \t     finish.$</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="把间隔符设置为空格或制表符"><a href="#把间隔符设置为空格或制表符" class="headerlink" title="把间隔符设置为空格或制表符"></a>把间隔符设置为空格或制表符</h3><p>cut的-d 选项，默认就是以Tab制表符为间隔符，如果想将间隔符设置为空格，则可以用单引号里面有空格来表示：<code>&#39; &#39;</code>， 且 -d 后面只能设置一个空格，不能设置多个空格，因为cu只允许 间隔符是一个字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya cut_test]$ cat tab_space.txt </span><br><span class="line">this is tab finish.</span><br><span class="line">this is serveral space      finish.</span><br><span class="line">[baiyongan@bya cut_test]$ cat tab_space.txt | cut -d &#x27; &#x27; -f 1</span><br><span class="line">this</span><br><span class="line">this</span><br><span class="line">[baiyongan@bya cut_test]$ cat tab_space.txt | cut -d &#x27;  &#x27; -f 1</span><br><span class="line">cut: the delimiter must be a single character</span><br><span class="line">Try &#x27;cut --help&#x27; for more information.</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ps-与-cut-结合时，奇怪的重复现象"><a href="#ps-与-cut-结合时，奇怪的重复现象" class="headerlink" title="ps 与 cut 结合时，奇怪的重复现象"></a>ps 与 cut 结合时，奇怪的重复现象</h3><p>实际运用中，经常会将ps 命令和 cut 结合使用，但是总会出现重复的行，为什么呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya cut_test]$ ps </span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  4052 pts/0    00:00:00 ps</span><br><span class="line">125335 pts/0    00:00:00 bash</span><br><span class="line">[baiyongan@bya cut_test]$ ps | cut -b3  # 为什么不是 0 4 5 呢？</span><br><span class="line"> </span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释：ps | cut 组合命令，其实会产生两个进程，即 ps进程和 cut 进程。当ps进程执行时，也会列出cut命令对应的进程的信息，并且将所有进程的信息都通过管道输出给 cut 进程。所以，cut截取之后，就多了一行，之所以会重复上一行的内容，是恰好截取到相同的字符而已。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya cut_test]$ ps </span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  4176 pts/0    00:00:00 ps</span><br><span class="line">125335 pts/0    00:00:00 bash</span><br><span class="line">[baiyongan@bya cut_test]$ ps | cut -b 1-</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  4194 pts/0    00:00:00 ps</span><br><span class="line">  4195 pts/0    00:00:00 cut</span><br><span class="line">125335 pts/0    00:00:00 bash</span><br><span class="line">[baiyongan@bya cut_test]$ </span><br><span class="line"><span class="meta">#</span><span class="bash"> 用 ps | cat 也可以查看</span></span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列——sort 排序</title>
      <link href="/2020/05/23/linux/command-sort/"/>
      <url>/2020/05/23/linux/command-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p>Linux中，sort 是非常常用的命令之一，它可以帮助我们进行各种文件和内容的排序，又快又准。</p><p>默认情况下，sort是将文件的每一行作为一个单元，进行排序的，其规则是从每行首字符向后，依此按ASCII码值前后顺序进行比较，最后将它们按照升序输出。</p><span id="more"></span><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><h3 id="u-选项消除重复行"><a href="#u-选项消除重复行" class="headerlink" title="-u 选项消除重复行"></a>-u 选项消除重复行</h3><blockquote><p> -u, –unique<br>              with -c, check for strict ordering; without -c, output only  the<br>              first of an equal run</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ cat seq.txt </span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">[baiyongan@bya sort_test]$ sort seq.txt </span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">pear</span><br><span class="line">[baiyongan@bya sort_test]$ sort -u seq.txt  # 重复的pear只显示一次</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br></pre></td></tr></table></figure><h3 id="r-选项降序排列"><a href="#r-选项降序排列" class="headerlink" title="-r 选项降序排列"></a>-r 选项降序排列</h3><p>sort的默认是升序，如果要降序排列，可用 -r</p><blockquote><p>   -r, –reverse<br>          reverse the result of comparisons</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ cat seq.txt </span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">[baiyongan@bya sort_test]$ sort  seq.txt </span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">pear</span><br><span class="line">[baiyongan@bya sort_test]$ sort -r seq.txt </span><br><span class="line">pear</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">[baiyongan@bya sort_test]$</span><br></pre></td></tr></table></figure><h3 id="o-选项保存排序结果"><a href="#o-选项保存排序结果" class="headerlink" title="-o 选项保存排序结果"></a>-o 选项保存排序结果</h3><p>sort默认将结果输出到标准输出 ，如果想存储排序结果，需要借助重定向，将结果写入文件，</p><p>即sort filename &gt; newfile，但是，如果要写回原文件，重定向就不行了。</p><blockquote><p>   -o, –output=FILE<br>          write result to FILE instead of standard output</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ cat number.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">[baiyongan@bya sort_test]$ sort -r number.txt &gt; number.txt </span><br><span class="line">[baiyongan@bya sort_test]$ cat number.txt </span><br><span class="line">[baiyongan@bya sort_test]$ </span><br><span class="line"></span><br><span class="line">[baiyongan@bya sort_test]$ cat number.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">[baiyongan@bya sort_test]$ sort -r number.txt -o number.txt #使用-o选项，可以将结果写回原文件</span><br><span class="line">[baiyongan@bya sort_test]$ cat number.txt </span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="n-进行数字排序"><a href="#n-进行数字排序" class="headerlink" title="-n 进行数字排序"></a>-n 进行数字排序</h3><p>sort默认按照字符来进行排序，它会把诸如 10，2 这些看作普通字符，而非数字，sort会先比较1 和2 两个字符，在ASCII码中，字符1 排在字符2 之前，所以10 被排在2 前面，要想按照数字方式排列，需要 -n 选项</p><blockquote><p>   -n, –numeric-sort<br>          compare according to string numerical val</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ cat number.txt </span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">19</span><br><span class="line">11</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">[baiyongan@bya sort_test]$ sort number.txt </span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">19</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">[baiyongan@bya sort_test]$ sort -n number.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">19</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br></pre></td></tr></table></figure><h3 id="tk-选项组合使用"><a href="#tk-选项组合使用" class="headerlink" title="tk 选项组合使用"></a>tk 选项组合使用</h3><p>-t 选项指定间隔符；-k 选项指定根据第几列进行排序</p><blockquote><p>   -t, –field-separator=SEP<br>          use SEP instead of non-blank to blank transition</p><p>   -k, –key=KEYDEF<br>          sort via a key; KEYDEF gives location and type</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ cat fruits.txt  #以：间隔，每行格式为  水果：数量：价格</span><br><span class="line">banana:30:5.5</span><br><span class="line">apple:10:2.5</span><br><span class="line">pear:90:2.3</span><br><span class="line">orange:20:3.4</span><br><span class="line">[baiyongan@bya sort_test]$ sort -n -k 2 -t : fruits.txt  # 表示按照数量进行排序</span><br><span class="line">apple:10:2.5</span><br><span class="line">orange:20:3.4</span><br><span class="line">banana:30:5.5</span><br><span class="line">pear:90:2.3</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他的好用的sort选项"><a href="#其他的好用的sort选项" class="headerlink" title="其他的好用的sort选项"></a>其他的好用的sort选项</h3><ul><li>-f 选项，将小写字母转化为大写字母来比较，效果相当于排序时忽略大小写</li></ul><blockquote><p>   -f, –ignore-case<br>          fold lower case to upper case characters</p></blockquote><ul><li>-c 选项， 会检查文件是否已经排好序，如果乱序，则输出第一个乱序的行的相关信息</li></ul><blockquote><p>   -c, –check, –check=diagnose-first<br>          check for sorted input; do not sort</p></blockquote><ul><li>-C 选项，会检查文件是否已经排好序，如果乱序，则不输出内容，而命令的返回值为 1 </li></ul><blockquote><p>   -C, –check=quiet, –check=silent<br>          like -c, but do not report first bad line</p></blockquote><ul><li>-M 选项，按照月份（英文名称）进行排序</li></ul><blockquote><p>   -M, –month-sort<br>          compare (unknown) &lt; ‘JAN’ &lt; … &lt; ‘DEC’</p></blockquote><ul><li>-b 选项，忽略每一行前面所有的空白部分，从第一个可见字符开始比较</li></ul><blockquote><p>   -b, –ignore-leading-blanks<br>          ignore leading blanks</p></blockquote><h3 id="k-选项详解"><a href="#k-选项详解" class="headerlink" title="-k 选项详解"></a>-k 选项详解</h3><p>设计一个文件 facebook.txt 每行结构为公司名：公司人数：员工工资，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ cat facebook.txt </span><br><span class="line">google 110 5000</span><br><span class="line">baidu 100 5000</span><br><span class="line">guge 50 300</span><br><span class="line">sohu 100 4500</span><br></pre></td></tr></table></figure><h4 id="复合条件排序"><a href="#复合条件排序" class="headerlink" title="复合条件排序"></a>复合条件排序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按照公司人数排序，人数相同时，默认按照第一个字段升序</span></span><br><span class="line">[baiyongan@bya sort_test]$ sort -n -t &#x27; &#x27; -k 2 facebook.txt </span><br><span class="line">guge 50 300</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照公司人数排序，人数相同时，按照员工平均工资升序排序</span></span><br><span class="line">[baiyongan@bya sort_test]$ sort -n -t &#x27; &#x27; -k 2 -k 3 facebook.txt </span><br><span class="line">guge 50 300</span><br><span class="line">sohu 100 4500</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">按照员工工资降序，工资相同时，按照公司人数升序</span></span><br><span class="line">[baiyongan@bya sort_test]$ sort -n -t &#x27; &#x27; -k 3r -k 2 facebook.txt </span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 300</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">同上需求，前面去掉 -n，后面包含 n</span></span><br><span class="line">[baiyongan@bya sort_test]$ sort -t &#x27; &#x27; -k 3nr -k 2n facebook.txt </span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 300</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br></pre></td></tr></table></figure><h4 id="k-选项的具体语法格式"><a href="#k-选项的具体语法格式" class="headerlink" title="-k 选项的具体语法格式"></a>-k 选项的具体语法格式</h4><blockquote><h4 id="FStart-CStart-Modifier-FEnd-CEnd-Modifier"><a href="#FStart-CStart-Modifier-FEnd-CEnd-Modifier" class="headerlink" title="[ FStart [ .CStart ] ]   [ Modifier ]  [ , [  FEnd [  .CEnd  ]   ]  [  Modifier  ]  ]"></a><strong>[ FStart [ .CStart ] ]   [ Modifier ]  [ , [  FEnd [  .CEnd  ]   ]  [  Modifier  ]  ]</strong></h4></blockquote><p>以其中的 “,” 为分隔，分前后两大部分，Start和End部分。</p><p>Start部分由三个元素组成，即FStart、CStart、Modifier</p><ul><li>FStart 表示我们要排序的列</li><li>CStart 表示在FStart列中，从第几个字符开始算”排序首字符“。CStart可省略，即默认从FStart的开头部分开始。</li><li>Modifier 是之前的类似 n 和 r 的选项部分，可以对排序的需求做补充说明，例如 -k 3nr。</li></ul><p>同理， End部分，也可以设定 FEnd.CEnd。如果省略CEnd，则表示从FEnd列的开头到”列尾“， 即FEnd列的最后一个字符。如果将CEnd设为0，效果和省略CEnd一样。整个的End部分也可被省略，即认为End被设定为行尾了。</p><h4 id="字母级的排序需求"><a href="#字母级的排序需求" class="headerlink" title="字母级的排序需求"></a>字母级的排序需求</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从公司名称的第二个字母开始排序</span></span><br><span class="line">[baiyongan@bya sort_test]$ sort -t &#x27; &#x27; -k 1.2 facebook.txt </span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">guge 50 300</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br><span class="line"><span class="meta">#</span><span class="bash"> 如上，1.2 表示 对第一列的第二个字符开始到本行最后一个字符进行排序。baidu因a排在首位，sohu和google都是</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> o，但sohu后的h，比google后的o靠前，所以sohu在google前</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ”只“ 针对公司名的第二个英文字母进行排序，如果内容相同，则按照员工工资进行降序排列</span></span><br><span class="line">[baiyongan@bya sort_test]$ sort -t &#x27; &#x27; -k 1.2,1.2 -k 3,3nr facebook.txt </span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 300</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中，-k 1.2，1.2 保证 ”只“ 对第二个字母进行排序，-k 3，3nr保证了 ”只“ 对第三列进行排序</span></span><br></pre></td></tr></table></figure><h4 id="k-和-n-参数配合的一些注意点"><a href="#k-和-n-参数配合的一些注意点" class="headerlink" title="-k 和 -n 参数配合的一些注意点"></a>-k 和 -n 参数配合的一些注意点</h4><ul><li>没有使用 -n 选项，同时 -k选项没有指定 End部分时， 则会比较从所指定的列到行尾的所有内容，与此同时，并不支持使用多个 -k 选项。</li><li>当使用 -n 选项， 同时 -k 选项没有指定End部分时，则当比较的列出现内容相同的情况时，则会从第一列开始进行比较。</li></ul><h4 id="modifier-部分"><a href="#modifier-部分" class="headerlink" title="modifier 部分"></a>modifier 部分</h4><p>modifier部分，可用到的修饰词，大体上包括 b、d、f、i、n、r。</p><ul><li>r  逆序</li><li>n  按数字排序</li><li>b  忽略本域前面的空白符号</li><li>d   表示对本域按照字典顺序排序（即 只考虑空白和字母）</li><li>f   表示对本域忽略大小写进行排序</li><li>i   忽略”不可打印字符“，只针对可打印字符进行排序</li></ul><h4 id="k-和-u-选项的联合效果"><a href="#k-和-u-选项的联合效果" class="headerlink" title="-k 和 -u 选项的联合效果"></a>-k 和 -u 选项的联合效果</h4><p>-u 只识别用 -k 设定的域，一旦发现内容相同，就会将后续相同的行都删除掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ cat facebook.txt </span><br><span class="line">google 110 5000</span><br><span class="line">baidu 100 5000</span><br><span class="line">guge 50 300</span><br><span class="line">sohu 100 4500</span><br><span class="line">[baiyongan@bya sort_test]$ sort -n -k 2 facebook.txt  # 按照第二列进行排序</span><br><span class="line">guge 50 300</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">[baiyongan@bya sort_test]$ sort -n -k 2 -u facebook.txt  # 加上 -u 选项</span><br><span class="line">guge 50 300</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时，-u 也会权衡所有的 -k 选项，存在多层排序时，只有都相同时，才会删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ sort -n -k 2 -k 3 -u facebook.txt </span><br><span class="line">guge 50 300</span><br><span class="line">sohu 100 4500</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="诡异的跨列排序"><a href="#诡异的跨列排序" class="headerlink" title="诡异的跨列排序"></a>诡异的跨列排序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ cat facebook.txt </span><br><span class="line">google 110 5000</span><br><span class="line">baidu 100 5000</span><br><span class="line">guge 50 300</span><br><span class="line">sohu 100 4500</span><br><span class="line">[baiyongan@bya sort_test]$ sort -n -k 2.2,3.1 facebook.txt </span><br><span class="line">guge 50 300</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br></pre></td></tr></table></figure><p>如上，对从第二列的第二个字符，到第三列的第一个字符部分，进行排序</p><p>第一行 提取 0 3， 第二行 提取 00 5， 第三行 提取 00 4， 第四行 提取 10  5。为什么 00  5 排在 00 4 前面呢？</p><p>其实”跨列排序只是个骗局“， sort指挥比较第二列的第二个字符到第二列的最后一个字符的部分，而不会把第三列的开头字符纳入比较范围。发现00 和00 相同，就会去自动比较第一列了，结果baidu在sohu前面了。可用案例佐证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya sort_test]$ sort -n -k 2.2,3.1 -k 1,1r facebook.txt </span><br><span class="line">guge 50 300</span><br><span class="line">sohu 100 4500</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">[baiyongan@bya sort_test]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令速查系列——文件的正文处理</title>
      <link href="/2020/05/23/linux/theme-text-processing-of-files/"/>
      <url>/2020/05/23/linux/theme-text-processing-of-files/</url>
      
        <content type="html"><![CDATA[<h2 id="文件的正文处理"><a href="#文件的正文处理" class="headerlink" title="文件的正文处理"></a>文件的正文处理</h2><p>Linux 最大的优点，也许就在于文本操作：通过各种处理（通常是利用管道）将文本文件（或标准输入）转换成所需的格式。所以，可以读取标准输入和写入标准输出的程序都可以用于文本处理。</p><table><thead><tr><th>命令工具</th><th>功能简介</th></tr></thead><tbody><tr><td>grep、egrep、fgrep</td><td>在文件中查找与正则表达式匹配的行</td></tr><tr><td>cut</td><td>从文件中提取列</td></tr><tr><td>paste</td><td>与cut命令相反，将多个文件视为垂直列，并将其合并到标准输出上</td></tr><tr><td>tr</td><td>将字符转为其他字符</td></tr><tr><td>expand，unexpand</td><td>在制表符和空格符之间进行转换</td></tr><tr><td>sort</td><td>按各种标准对文本行进行排序</td></tr><tr><td>uniq</td><td>在文件中查找相同的行</td></tr><tr><td>tee</td><td>复制文件，同时将其输出到标准输出上</td></tr><tr><td>awk</td><td>通过正则匹配数据，并操作</td></tr><tr><td>sed</td><td>一种模式匹配引擎，可针对文本行执行各种操作</td></tr><tr><td>m4</td><td>用来查找文件中的关键字，然后用某些值替代它们</td></tr><tr><td>Perl、PHP、Python、Ruby</td><td>一些成熟的编程语言</td></tr></tbody></table><span id="more"></span><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><blockquote><h3 id="grep-options-pattern-files"><a href="#grep-options-pattern-files" class="headerlink" title="grep [options] pattern [files]"></a>grep [<em>options</em>] pattern [<em>files</em>]</h3></blockquote><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li>-v    只输出与正则表达式不匹配的行    </li><li>-l     仅输出包含匹配行的文件的名称，而不是输出匹配的行</li><li>-L    仅输出不包含匹配行的文件的名称</li><li>-c    仅输出匹配的行数</li><li>-n    在输出结果的时候，每行的前面给出其原始行号</li><li>-b     在输出结果的时候，每行的前面给出其在文件中的偏移字节</li><li>-i     匹配时不区分大小写</li><li>-w    仅匹配完整的单词</li><li>-x     仅匹配完整的行，优先级高于 -w</li><li>-A num  输出匹配行，以及位于匹配行之后的num行</li><li>-B num  输出匹配行，以及位于匹配行之前的num行</li><li>-C num 输出匹配行，以及源文件中位于匹配行的前后num行内容</li><li>--color = always   突出显示匹配文本的颜色</li><li>-r   递归搜索目录及其子目录中的所有文件</li><li>-E   使用扩展的正则表达式 等同于 egrep</li><li>-F  使用固定的字符串列表，等同于 fgrep</li></ul><h2 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h2><blockquote><h3 id="egrep-options-pattern-files"><a href="#egrep-options-pattern-files" class="headerlink" title="egrep [options] pattern [files]"></a>egrep [<em>options</em>] pattern [<em>files</em>]</h3></blockquote><h3 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li>类似grep，需要关注正则表达式相关内容</li></ul><h2 id="fgrep"><a href="#fgrep" class="headerlink" title="fgrep"></a>fgrep</h2><blockquote><h3 id="fgrep-options-fixed-strings-files"><a href="#fgrep-options-fixed-strings-files" class="headerlink" title="fgrep [options] [fixed_strings] [files]"></a>fgrep [<em>options</em>] [<em>fixed_strings</em>] [<em>files</em>]</h3></blockquote><h3 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li>类似grep，但无法接收正则，只能支持用换行符分隔的固定字符串列表。搜索非字母数字字符如* 和 { 时，非常方便。</li></ul><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><blockquote><h3 id="cut-b-c-f-range-options-files"><a href="#cut-b-c-f-range-options-files" class="headerlink" title="cut  -(b|c|f)range  [options]  [files]"></a>cut  -(b|c|f)<em>range</em>  [<em>options</em>]  [<em>files</em>]</h3></blockquote><h3 id="常用选项-3"><a href="#常用选项-3" class="headerlink" title="常用选项"></a>常用选项</h3><blockquote><p><strong>定位依据：</strong></p><p><strong>按照字节定位，bytes，用-b选项；</strong></p><p><strong>按照字符定位，characters， 用 -c 选项；</strong></p><p><strong>按照域定位， fileds，用 -f 选项。</strong></p></blockquote><ul><li>-d C   使用字符 C 作为 -f 选项的字段之间的输入分隔符。默认使用制表符。</li><li>–output-delimiter = C   使用字符C 作为 -f 选项的字段之间的输入分隔符。默认使用制表符。</li><li>-s    排除（不输出）不包含分隔符的行。</li></ul><h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><blockquote><h3 id="paste-options-files"><a href="#paste-options-files" class="headerlink" title="paste [options] [files]"></a>paste [<em>options</em>] [<em>files</em>]</h3></blockquote><h3 id="常用选项-4"><a href="#常用选项-4" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li>-d delimiters   使用给定分隔符来分隔各列，默认使用制表符。可提供一个单个字符如（ -d：），也可以提供一个字符列表（ -dxyz）。</li><li>-s  将输出的行和列进行转置。</li></ul><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><blockquote><h3 id="tr-options-charset1-charset2"><a href="#tr-options-charset1-charset2" class="headerlink" title="tr [options*]  *charset1 [charset2]"></a>tr [<em>options*]  *charset1</em> [<em>charset2</em>]</h3></blockquote><h3 id="常用选项-5"><a href="#常用选项-5" class="headerlink" title="常用选项"></a>常用选项</h3><p>非常适合于快速简单的转换，但是对一些更复杂的转换，则用sed、awk、perl等。</p><ul><li>-d    从输入中删除包含在charset1 中的字符</li><li>-s    从输入中删除（位于charset1中的）那些连续重复字符。如tr -s aeiouAEIOU 命令会将连续重复的元音，变成单个元音（如将reeeeeeeally 变成 really）</li><li>-c     只对 charset1 之外的字符进行操作</li><li>-t      如果charset1 长于  charset2， 通过阶段charset1 使其长度相同。如果没有提供 -t 的话，则不断复制charset2 的最后一个字符，直到charset2 和charset1 的长度相同为止。</li></ul><h2 id="expand、unexpand"><a href="#expand、unexpand" class="headerlink" title="expand、unexpand"></a>expand、unexpand</h2><blockquote><h3 id="expand-options-files"><a href="#expand-options-files" class="headerlink" title="expand [options] [files]"></a>expand [<em>options</em>] [<em>files</em>]</h3><h3 id="unexpand-options-files"><a href="#unexpand-options-files" class="headerlink" title="unexpand [options] [files]"></a>unexpand [<em>options</em>] [<em>files</em>]</h3></blockquote><h3 id="常用选项-6"><a href="#常用选项-6" class="headerlink" title="常用选项"></a>常用选项</h3><p>expand会将制表符转换为特定数量的空白字符，使其看起来长度不变，unexpand与其相反。默认情况下，每8个空格兑换一个制表符。</p><p>检查文件是否包含空格或制表符，可以用 cat -T 命令，它将制表符显示为^I， 此外，也可用 od -c 命令，它将制表符显示为 \t。</p><ul><li>-t N     规定用N个空格替换一个制表符</li></ul><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><blockquote><h3 id="sort-options-files"><a href="#sort-options-files" class="headerlink" title="sort [options]  [files]"></a>sort [<em>options</em>]  [<em>files</em>]</h3></blockquote><h3 id="常用选项-7"><a href="#常用选项-7" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li>-f    排序时区分大小写</li><li>-n    按照数字顺序（如9 在10 之前）进行排序，而不是按照字母顺序（如这时，10会在9 之前，因为10以1开头）</li><li>-g    另一种有不同算法的数字排序方法，详查info sort</li><li>-u    排序时，忽略重复行</li><li>-c     不进行排序，只检查输入是否已经晋国排序处理。是的话，不输出任何内容，否则，输出错误信息</li><li>-b    忽略各行的前导空格</li><li>-r     对输出进行反转：按照从最大到最小的顺序来排序</li><li>-t   X  使用X作为 -k 选项的字段分隔符</li><li>-k  key   选择用于排序的键（结合 -t选项后，可以指定各个键之间的分隔符）</li></ul><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><blockquote><h3 id="uniq-options-files"><a href="#uniq-options-files" class="headerlink" title="uniq [options]  [files]"></a>uniq [<em>options</em>]  [<em>files</em>]</h3></blockquote><h3 id="常用选项-8"><a href="#常用选项-8" class="headerlink" title="常用选项"></a>常用选项</h3><ul><li><p>-c     计算相邻的重复行的数量</p></li><li><p>-i     操作时不区分大小写</p></li><li><p>-u     仅输出唯一的行</p></li><li><p>-d     仅输出重复行</p></li><li><p>-s   N 检测重复行时，忽略每行中的前面N个字符</p></li><li><p>-f    N  当检测重复行时，忽略每行中的前面N个由空白符分隔的第一个字段</p></li><li><p>-w   N   当检测重复行时，仅考察每行的前N个字符。当与  -s  或  -f  选项结合使用时，sort将忽略每行前面制定法数量的字符或字段，然后考察接下来的N个字符。</p></li></ul><h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><blockquote><h3 id="tee-options-files"><a href="#tee-options-files" class="headerlink" title="tee [options*]  *files"></a>tee [<em>options*]  *files</em></h3></blockquote><h3 id="常用选项-9"><a href="#常用选项-9" class="headerlink" title="常用选项"></a>常用选项</h3><p>最常见用于管道命令上</p><ul><li>-a    附加至文件末尾，而非覆盖文件</li><li>-i     忽略中断信号</li></ul><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="m4"><a href="#m4" class="headerlink" title="m4"></a>m4</h2><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> cheatsheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 速查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列——文本处理三剑客之一 grep</title>
      <link href="/2020/05/23/linux/command-grep-egrep-fgrep/"/>
      <url>/2020/05/23/linux/command-grep-egrep-fgrep/</url>
      
        <content type="html"><![CDATA[<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p>Linux系统中grep命令是一个可以利用“正则表达式”进行“全局搜索”，并将搜索出的行打印出来的工具。grep全称是<strong>G</strong>lobal <strong>R</strong>egular <strong>E</strong>xpression <strong>P</strong>rint，它的使用权限是所有用户。</p><p><strong>grep是Linux中最常用的“文本处理工具”之一，grep与sed、awk合称为Linux中的三剑客。</strong>它与egrep和fgrep 实用程序属于同一系列的Unix工具。</p><span id="more"></span><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><h3 id="grep、egrep、fgrep三者关系"><a href="#grep、egrep、fgrep三者关系" class="headerlink" title="grep、egrep、fgrep三者关系"></a>grep、egrep、fgrep三者关系</h3><p>man grep 查询可知：</p><p> <strong>egrep is the same as grep -E.</strong>  </p><p>其中 -E, –extended-regexp<br> Interpret PATTERN as an extended regular expression (ERE, see below).  (-E is specified by POSIX.)</p><p><strong>fgrep is the  same as  grep -F.</strong></p><p>其中 -F, –fixed-strings, –fixed-regexp<br>Interpret PATTERN as a list of fixed strings, separated by newlines, any of which is to be matched.  (-F  is specified by POSIX, –fixed-regexp is an obsoleted alias, please do not use it in new scripts.)</p><blockquote><p><strong>简而言之，grep支持基础正则表达式，egrep支持扩展正则表达式，fgrep不支持正则。</strong></p></blockquote><h3 id="grep-高亮打印"><a href="#grep-高亮打印" class="headerlink" title="grep 高亮打印"></a>grep 高亮打印</h3><p>以下都是围绕/etc/passwd文件来进行说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 # 获取passwd文件最后15行内容</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">netdata:x:990:985:netdata:/opt/netdata:/usr/sbin/nologin</span><br><span class="line">influxdb:x:989:984::/var/lib/influxdb:/bin/false</span><br><span class="line">apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</span><br><span class="line">mosquitto:x:988:983:Mosquitto Broker:/etc/mosquitto:/sbin/nologin</span><br><span class="line">ganglia:x:987:982:Ganglia Monitoring System:/var/lib/ganglia:/sbin/nologin</span><br><span class="line">nut:x:57:57:Network UPS Tools:/var/lib/ups:/bin/false</span><br><span class="line">test_ansible:x:986:980::/home/test_ansible:/sbin/nologin</span><br><span class="line">mysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologin</span><br><span class="line">caddy:x:985:979:Caddy web server:/var/lib/caddy:/sbin/nologin</span><br><span class="line">elasticsearch:x:1001:888::/home/elasticsearch:/bin/bash</span><br><span class="line">[baiyongan@bya linux_practice]$</span><br><span class="line">[baiyongan@bya linux_practice]$ grep --color &quot;baiyongan&quot; /etc/passwd</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">[baiyongan@bya linux_practice]$ grep &quot;baiyongan&quot; /etc/passwd</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">[baiyongan@bya linux_practice]$ alias</span><br><span class="line">alias egrep=&#x27;egrep --color=auto&#x27;</span><br><span class="line">alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br><span class="line">alias grep=&#x27;grep --color=auto&#x27;</span><br><span class="line">alias l.=&#x27;ls -d .* --color=auto&#x27;</span><br><span class="line">alias ll=&#x27;ls -l --color=auto&#x27;</span><br><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br><span class="line">alias which=&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br></pre></td></tr></table></figure><p>其实系统默认grep的别名就是高亮打印了，所以 加不加–color 参数，都会将匹配到的字符串显示成红色。</p><h3 id="grep的反查技能"><a href="#grep的反查技能" class="headerlink" title="grep的反查技能"></a>grep的反查技能</h3><p><strong>使用 -v 参数，可以实现反查效果</strong></p><blockquote><p>-v, –invert-match<br>              Invert the sense of matching, to select non-matching lines.  (-v is specified by POSIX.)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep --color &quot;baiyongan&quot;</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep -v &quot;baiyongan&quot;</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">netdata:x:990:985:netdata:/opt/netdata:/usr/sbin/nologin</span><br><span class="line">influxdb:x:989:984::/var/lib/influxdb:/bin/false</span><br><span class="line">apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin</span><br><span class="line">mosquitto:x:988:983:Mosquitto Broker:/etc/mosquitto:/sbin/nologin</span><br><span class="line">ganglia:x:987:982:Ganglia Monitoring System:/var/lib/ganglia:/sbin/nologin</span><br><span class="line">nut:x:57:57:Network UPS Tools:/var/lib/ups:/bin/false</span><br><span class="line">test_ansible:x:986:980::/home/test_ansible:/sbin/nologin</span><br><span class="line">mysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologin</span><br><span class="line">caddy:x:985:979:Caddy web server:/var/lib/caddy:/sbin/nologin</span><br><span class="line">elasticsearch:x:1001:888::/home/elasticsearch:/bin/bash</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br></pre></td></tr></table></figure><h3 id="grep展示行号和统计行数"><a href="#grep展示行号和统计行数" class="headerlink" title="grep展示行号和统计行数"></a>grep展示行号和统计行数</h3><p><strong>使用 -n 参数，可以输出行号</strong></p><blockquote><p>  -n, –line-number<br>              Prefix each line of output with the 1-based line number within its input file.  (-n is specified by POSIX.)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya linux_practice]$ grep -n &quot;baiyongan&quot; /etc/passwd</span><br><span class="line">41:baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br></pre></td></tr></table></figure><p><strong>使用 -c 参数，仅返回搜索到的匹配行数</strong></p><blockquote><p>-c, –count<br>              Suppress  normal  output;  instead  print  a  count  of  matching  lines  for each input file.  With the -v, –invert-match option (see below), count non-matching lines.  (-c is specified by POSIX.)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep -c &quot;baiyongan&quot;</span><br><span class="line">1</span><br><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep -cv &quot;baiyongan&quot;</span><br><span class="line">14</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br></pre></td></tr></table></figure><h3 id="grep展示检索行的上下临近部分"><a href="#grep展示检索行的上下临近部分" class="headerlink" title="grep展示检索行的上下临近部分"></a>grep展示检索行的上下临近部分</h3><p><strong>A 即After，使用 -A num参数，表示除了打印匹配行之外，还要打印出匹配行下面的num行</strong></p><blockquote><p>-A NUM, –after-context=NUM<br>          Print NUM lines of trailing context after matching lines.   Places  a  line  containing  a  group  separator (described  under  –group-separator)  between contiguous groups of matches.  With the -o or –only-matching option, this has no effect and a warning is given.</p></blockquote><p><strong>B即 Before，使用 -B num参数，表示除了打印匹配行之外，还要打印出匹配行上面的num行</strong></p><blockquote><p>   -B NUM, –before-context=NUM<br>          Print NUM lines of leading context before matching lines.   Places  a  line  containing  a  group  separator<br>          (described  under  –group-separator)  between contiguous groups of matches.  With the -o or –only-matching<br>          option, this has no effect and a warning is given.</p></blockquote><p><strong>C即context，使用 -C num 参数，表示除了打印匹配行之外，还要打印出匹配行的上下num行</strong></p><blockquote><p>   -C NUM, -NUM, –context=NUM<br>          Print NUM  lines  of  output  context.   Places  a  line  containing  a  group  separator  (described  under<br>          –group-separator) between contiguous groups of matches.  With the -o or –only-matching option, this has no<br>          effect and a warning is given.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep -A 1 &quot;baiyongan&quot;</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">netdata:x:990:985:netdata:/opt/netdata:/usr/sbin/nologin</span><br><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep -B 1 &quot;baiyongan&quot;</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep -C 1 &quot;baiyongan&quot;</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash  # 匹配行，前后一行</span><br><span class="line">netdata:x:990:985:netdata:/opt/netdata:/usr/sbin/nologin</span><br><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep -2 &quot;baiyongan&quot;</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash # 匹配行，前后两行</span><br><span class="line">netdata:x:990:985:netdata:/opt/netdata:/usr/sbin/nologin</span><br><span class="line">influxdb:x:989:984::/var/lib/influxdb:/bin/false</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br></pre></td></tr></table></figure><h3 id="grep不区分大小写"><a href="#grep不区分大小写" class="headerlink" title="grep不区分大小写"></a>grep不区分大小写</h3><p><strong>使用 -i 参数，可以忽略大小写，提高搜索命中的概率</strong></p><blockquote><p>   -i, –ignore-case<br>          Ignore case distinctions in both the PATTERN and the input files.  (-i is specified by POSIX.)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya linux_practice]$ cat /etc/passwd | tail -n 15 | grep -i &quot;baiYONGan&quot;</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br><span class="line"><span class="meta">#</span><span class="bash">其中，虽然搜索baiYONGan，而baiyongan、BaiYongan都高亮显示了</span></span><br></pre></td></tr></table></figure><h3 id="grep处理多文件"><a href="#grep处理多文件" class="headerlink" title="grep处理多文件"></a>grep处理多文件</h3><p>grep命令可以一次性搜索多个文件，最常用的场景就是：从大量的文件中查找出含有特定字符的文件。</p><p><strong>使用 -l 参数，可以找到包含匹配字符的文件，并打印文件名</strong></p><p><strong>使用-L 参数，是 -l 参数的反向操作，可以找到不包含匹配字符的文件，并打印文件名</strong></p><blockquote><p>   -l, –files-with-matches<br>          Suppress normal output; instead print the name of each input file from which output would normally have been<br>          printed.  The scanning will stop on the first match.  (-l is specified by POSIX.)</p><p>   -L, –files-without-match<br>          Suppress normal output; instead print the name of each input file from which no output would  normally  have<br>          been printed.  The scanning will stop on the first match.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya grep_test]$ ll</span><br><span class="line">total 12</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 36 May 23 11:26 1.txt</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 37 May 23 11:27 2.txt</span><br><span class="line">-rw-rw-r-- 1 baiyongan baiyongan 36 May 23 11:26 3.txt</span><br><span class="line">[baiyongan@bya grep_test]$ for i in $(ls ./); do echo context of  $i &amp;&amp;  cat $i &amp;&amp; echo; done</span><br><span class="line">context of 1.txt</span><br><span class="line">the first file</span><br><span class="line">this line is useless</span><br><span class="line"></span><br><span class="line">context of 2.txt</span><br><span class="line">the second file</span><br><span class="line">this line is useless</span><br><span class="line"></span><br><span class="line">context of 3.txt</span><br><span class="line">the third file</span><br><span class="line">this line is useless</span><br><span class="line"></span><br><span class="line">[baiyongan@bya grep_test]$ grep -l &quot;first&quot; *.txt</span><br><span class="line">1.txt</span><br><span class="line">[baiyongan@bya grep_test]$ grep -L &quot;first&quot; *.txt</span><br><span class="line">2.txt</span><br><span class="line">3.txt</span><br><span class="line">[baiyongan@bya grep_test]$ </span><br></pre></td></tr></table></figure><h3 id="grep与正则"><a href="#grep与正则" class="headerlink" title="grep与正则"></a>grep与正则</h3><p><strong>检索行首匹配的字符串， 用 ^string</strong></p><p><strong>检索行尾匹配的字符串，用string$</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya grep_test]$ grep &#x27;^baiyongan&#x27; /etc/passwd</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">[baiyongan@bya grep_test]$ grep &#x27;bash$&#x27; /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">elasticsearch:x:1001:888::/home/elasticsearch:/bin/bash</span><br><span class="line">[baiyongan@bya grep_test]$ </span><br></pre></td></tr></table></figure><h3 id="正则中有关-‘词’-的知识"><a href="#正则中有关-‘词’-的知识" class="headerlink" title="正则中有关 ‘词’ 的知识"></a>正则中有关 ‘词’ 的知识</h3><p>正则中的词，一般是由字母、数字和下划线组成的，词与词之间，通常用空格、制表符或换行符分隔。</p><p>如下所示：在正则中，使用 \&lt; 和 \&gt; 来匹配love这个词，gloves则不会被匹配到。</p><p>其实，更简单的方式是 -w参数：</p><p><strong>使用-w 参数，精确匹配要检索的字符串，并打印相关行</strong></p><blockquote><p>-w, –word-regexp<br>          Select only those lines containing matches that form whole words.  The test is that the  matching  substring must either be at the beginning of the line, or preceded by a non-word constituent character.  Similarly, it  must be either at the end of the line or followed by a  non-word  constituent  character.   Word-constituent characters are letters, digits, and the underscore.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya grep_test]$ cat word.txt </span><br><span class="line">I love daisy</span><br><span class="line">My gloves are red.</span><br><span class="line">[baiyongan@bya grep_test]$ grep love word.txt </span><br><span class="line">I love daisy</span><br><span class="line">My gloves are red.</span><br><span class="line">[baiyongan@bya grep_test]$ grep &#x27;\&lt;love\&gt;&#x27; word.txt </span><br><span class="line">I love daisy</span><br><span class="line">[baiyongan@bya grep_test]$# 使用 -w 参数，更加简单</span><br><span class="line">[baiyongan@bya grep_test]$ grep -w love word.txt </span><br><span class="line">I love daisy</span><br><span class="line">[baiyongan@bya grep_test]$ </span><br></pre></td></tr></table></figure><h3 id="egrep-实现多条件查找"><a href="#egrep-实现多条件查找" class="headerlink" title="egrep 实现多条件查找"></a>egrep 实现多条件查找</h3><p>如下所示，使用egrep实现两个条件的查找，其中  ‘|’  符号代表 或 搜索。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya grep_test]$ egrep &#x27;^root|bash$&#x27; /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">elasticsearch:x:1001:888::/home/elasticsearch:/bin/bash</span><br><span class="line">[baiyongan@bya grep_test]$ </span><br><span class="line">[baiyongan@bya grep_test]$ grep -E &#x27;^root|bash$&#x27; /etc/passwd # 与egrep等价</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">baiyongan:x:1000:1000:BaiYongan:/home/baiyongan:/bin/bash</span><br><span class="line">elasticsearch:x:1001:888::/home/elasticsearch:/bin/bash</span><br><span class="line">[baiyongan@bya grep_test]$ grep  &#x27;^root|bash$&#x27; /etc/passwd </span><br><span class="line">[baiyongan@bya grep_test]$ </span><br></pre></td></tr></table></figure><h3 id="基本正则表达式和扩展正则表达式"><a href="#基本正则表达式和扩展正则表达式" class="headerlink" title="基本正则表达式和扩展正则表达式"></a>基本正则表达式和扩展正则表达式</h3><p>正则表达式种类繁多且复杂，POSIX则将正则进行了标准化，并把实现方法分成了两大类。</p><ul><li>基本正则表达式（BRE）</li><li>扩展正则表达式（ERE）</li></ul><p>两者的区别，更多的是元字符的区别。</p><p>基本正则中，只承认 <strong>“^”, “$”, “.”, “[“, “]”, “*”</strong>是元字符，其他都被识别为普通字符；</p><p>扩展正则中，在BRE的基础上，增加了 <strong>“(“, “)”, “{“, “}”, “?”, “+”, “|”</strong> 等元字符。</p><p>特别说明：只有在用反斜杠进行转义的情况下，字符  <strong>“(“, “)”, “{“, “}”</strong>，才会在扩展正则中被当作元字符处理，而在基本正则中，任何元字符前面加上反斜杠，反而会使其被当作普通字符处理。</p><h3 id="不支持正则的fgrep"><a href="#不支持正则的fgrep" class="headerlink" title="不支持正则的fgrep"></a>不支持正则的fgrep</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya grep_test]$ grep -c &#x27;bash$&#x27; /etc/passwd</span><br><span class="line">3</span><br><span class="line">[baiyongan@bya grep_test]$ fgrep -c &#x27;bash$&#x27; /etc/passwd</span><br><span class="line">0</span><br><span class="line">[baiyongan@bya grep_test]$ </span><br></pre></td></tr></table></figure><p>既然fgrep不支持正则，那要它何用？其实，当搜索时，假如搜索字符串中包含了不少的特殊字符，而这些特殊字符，恰好又是正则表达式的预留字符，比如”$”, “^”等，这是，可以用fgrep避免转义。示例如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya grep_test]$ cat roc.txt # roc.txt文件中，有^ ^$等</span><br><span class="line">^this is a useless line</span><br><span class="line">^$this is another useless line</span><br><span class="line">[baiyongan@bya grep_test]$ grep &#x27;^this&#x27; roc.txt  # grep会找开头为this的行，无匹配</span><br><span class="line">[baiyongan@bya grep_test]$ grep &#x27;\^this&#x27; roc.txt </span><br><span class="line">^this is a useless line</span><br><span class="line">[baiyongan@bya grep_test]$ fgrep &#x27;^this&#x27; roc.txt # fgrep会找 ^this这个字符串，有匹配</span><br><span class="line">^this is a useless line</span><br><span class="line">[baiyongan@bya grep_test]$ </span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>无</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>正则上面内容还比较少</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运维实战系列——echo 打印</title>
      <link href="/2020/05/22/linux/command-echo/"/>
      <url>/2020/05/22/linux/command-echo/</url>
      
        <content type="html"><![CDATA[<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p><strong>echo命令是 linux 中最基础的命令，也是最常用的命令之一，常用于在终端处进行输入输出验证，而且在写shell脚本的时候，也会被经常用到</strong>。</p><span id="more"></span><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><h3 id="echo显示字符串与变量"><a href="#echo显示字符串与变量" class="headerlink" title="echo显示字符串与变量"></a>echo显示字符串与变量</h3><p>显示字符串，直接打印即可，显示变量，用 $引用， 示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya ~]$ echo &#x27;hello world&#x27;</span><br><span class="line">hello world</span><br><span class="line">[baiyongan@bya ~]$ echo &quot;hello world&quot;</span><br><span class="line">hello world</span><br><span class="line">[baiyongan@bya ~]$ echo hello world</span><br><span class="line">hello world</span><br><span class="line">[baiyongan@bya ~]$ str=&quot;hello world&quot;</span><br><span class="line">[baiyongan@bya ~]$ echo &quot;$str, good night&quot;</span><br><span class="line">hello world, good night</span><br></pre></td></tr></table></figure><h3 id="用echo-e-显示反斜杠转义"><a href="#用echo-e-显示反斜杠转义" class="headerlink" title="用echo -e 显示反斜杠转义"></a>用echo -e 显示反斜杠转义</h3><p>转义字符，是shell中的一些有特殊功能的字符，比如\n代表换行，\t代表制表符等。它统一由反斜线 “\“ 开头，后面跟上一个或几个字符。  </p><blockquote><p>echo中，要使用转义字符，需要使用 -e 参数，并用双引号将转义字符括起来。</p><p>其中： <strong>-e     enable interpretation of backslash escapes</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya ~]$ echo &quot;hello world&quot;</span><br><span class="line">hello world</span><br><span class="line">[baiyongan@bya ~]$ echo &quot;hello world\n&quot;</span><br><span class="line">hello world\n</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;hello world\n&quot; #-e参数，实现了换行</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">[baiyongan@bya ~]$ </span><br></pre></td></tr></table></figure><h4 id="常用的转义字符列表"><a href="#常用的转义字符列表" class="headerlink" title="常用的转义字符列表"></a>常用的转义字符列表</h4><ul><li><strong>\b转义相当于按退格键（backspace），但前提是“\b”后面存在字符；</strong></li><li><strong>\c不换行输出，在“\c”后面不存在字符的情况下，作用相当于echo -n；</strong></li><li><strong>\n换行；</strong></li><li><strong>\t 表示插入tab，即制表符；</strong></li><li><strong>\f换页，即换行后的新行的开头位置连接着上一行的行尾；</strong></li><li><strong>\v 垂直制表符，与\f相同；</strong></li><li><strong>\r光标移至行首，但不换行，相当于使用“\r”以后的字符覆盖“\r”之前同等长度的字符，只看这段文字描述的话可能不容易理解，具体效果查看示例。</strong></li><li><strong>\表示插入“\”本身；</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> \b 的作用：一个<span class="string">&quot;\b&quot;</span>就相当于按一次backspace键</span></span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;123\b&quot;</span><br><span class="line">123</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;123\b4567&quot;</span><br><span class="line">124567</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;123\b\b4567&quot;</span><br><span class="line">14567</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;123\b\b\b4567&quot;</span><br><span class="line">4567</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \c 的作用： 如果<span class="string">&quot;\c&quot;</span>后面不存在任何字符时，效果与<span class="string">&quot;echo -n&quot;</span>相同，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当<span class="string">&quot;\c&quot;</span>后面仍然存在字符时，<span class="string">&quot;\c&quot;</span>后面的字符将不会被输出。</span></span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;123\c&quot;</span><br><span class="line">123[baiyongan@bya ~]$ echo -n &quot;123&quot;</span><br><span class="line">123[baiyongan@bya ~]$ echo -e &quot;123\c456&quot;</span><br><span class="line">123[baiyongan@bya ~]$ </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> \f的作用：换行后的新行的开头位置连接着上一行的行尾</span></span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;123\f456&quot;</span><br><span class="line">123</span><br><span class="line">   456</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;hello world\f456&quot;</span><br><span class="line">hello world</span><br><span class="line">           456</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;hello world\f456\fgoodbye&quot;</span><br><span class="line">hello world</span><br><span class="line">           456</span><br><span class="line">              goodbye</span><br><span class="line">[baiyongan@bya ~]$ </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">\v的作用：同 \f</span></span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;123\v456&quot;</span><br><span class="line">123</span><br><span class="line">   456</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;hello world\v456&quot;</span><br><span class="line">hello world</span><br><span class="line">           456</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;hello world\v456\vgoodbye&quot;</span><br><span class="line">hello world</span><br><span class="line">           456</span><br><span class="line">              goodbye</span><br><span class="line">[baiyongan@bya ~]$ </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">\r的作用：表示使用“\r”后面的字符覆盖“\r”之前的同等长度的字符</span></span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;abcdefg\r123&quot;</span><br><span class="line">123defg</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;abc\r123&quot;</span><br><span class="line">123</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;a\r123&quot;</span><br><span class="line">123</span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;a\r&quot;</span><br><span class="line">a</span><br><span class="line">[baiyongan@bya ~]$ </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">\\的作用：转义表示\</span></span><br><span class="line"><span class="bash">[baiyongan@bya ~]$ <span class="built_in">echo</span> -e <span class="string">&quot;abc\\def&quot;</span></span></span><br><span class="line">abc\def</span><br><span class="line">[baiyongan@bya ~]$</span><br></pre></td></tr></table></figure><h3 id="关闭echo的自动换行行为"><a href="#关闭echo的自动换行行为" class="headerlink" title="关闭echo的自动换行行为"></a>关闭echo的自动换行行为</h3><p>默认情况下，echo会在内容输出后换行，如果要改变这种默认方式，可有两种方法：</p><p>用 -n 选项去掉echo末尾的换行符；（ -n     do not output the trailing newline）</p><p>用 -e 选项打印出转义字符。</p><blockquote><p>开发shell程序的时候，经常需要用户在一些提示语后的同一行，输入一些内容，这时，就可以用到不换行模式。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya ~]$ echo -n &quot;Enter your username:&quot;</span><br><span class="line">Enter your username:[baiyongan@bya ~]$ </span><br><span class="line">[baiyongan@bya ~]$ echo -e &quot;Enter your username:\c&quot;</span><br><span class="line">Enter your username:[baiyongan@bya ~]$ </span><br><span class="line">[baiyongan@bya ~]$ </span><br></pre></td></tr></table></figure><h3 id="echo后面的引号区别：单引号-vs-双引号-vs-无引号"><a href="#echo后面的引号区别：单引号-vs-双引号-vs-无引号" class="headerlink" title="echo后面的引号区别：单引号 vs 双引号 vs 无引号"></a>echo后面的引号区别：单引号 vs 双引号 vs 无引号</h3><blockquote><p><strong>单引号无视所有的特殊字符，所有字符在它眼里都是普通字符；</strong></p><p><strong>双引号无视文件通配符，但是对 $，\，`起作用；</strong></p><p><strong>不加引号，则会解释所有的特殊字符。</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya linux_practice]$ echo $USER</span><br><span class="line">baiyongan</span><br><span class="line">[baiyongan@bya linux_practice]$ echo $(date)</span><br><span class="line">Fri May 22 23:48:57 CST 2020</span><br><span class="line">[baiyongan@bya linux_practice]$ echo *</span><br><span class="line">demo.sh</span><br><span class="line">[baiyongan@bya linux_practice]$ ls</span><br><span class="line">demo.sh</span><br><span class="line">[baiyongan@bya linux_practice]$ echo &#x27;$USER * $(date)&#x27;</span><br><span class="line"><span class="meta">$</span><span class="bash">USER * $(date)</span></span><br><span class="line">[baiyongan@bya linux_practice]$ echo &quot;$USER * $(date)&quot;</span><br><span class="line">baiyongan * Fri May 22 23:49:12 CST 2020</span><br><span class="line">[baiyongan@bya linux_practice]$ echo $USER * $(date)</span><br><span class="line">baiyongan demo.sh Fri May 22 23:49:16 CST 2020</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br></pre></td></tr></table></figure><h4 id="使用echo打印双引号-or-单引号"><a href="#使用echo打印双引号-or-单引号" class="headerlink" title="使用echo打印双引号 or 单引号"></a>使用echo打印双引号 or 单引号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打印双引号</span></span><br><span class="line">[baiyongan@bya linux_practice]$ echo &quot;\&quot;hello wolrd\&quot;&quot;</span><br><span class="line">&quot;hello wolrd&quot;</span><br><span class="line">[baiyongan@bya linux_practice]$ echo &#x27;&quot;hello world&quot;&#x27;</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">打印单引号</span></span><br><span class="line">[baiyongan@bya linux_practice]$ echo &quot;&#x27;hello again&#x27;&quot;</span><br><span class="line">&#x27;hello again&#x27;</span><br><span class="line">[baiyongan@bya linux_practice]$ </span><br></pre></td></tr></table></figure><h3 id="echo-在shell中显示色彩"><a href="#echo-在shell中显示色彩" class="headerlink" title="echo 在shell中显示色彩"></a>echo 在shell中显示色彩</h3><p>echo通过转义序列，来为输出添加色彩，语法格式如下：</p><blockquote><p><strong>echo  -e “\033[颜色1；颜色2m 要展示的文字  \033[0m”</strong></p></blockquote><p><img src="/images/echo.png" alt="echo"></p><table><thead><tr><th align="center">色彩</th><th align="center">前景色</th><th align="center">背景色</th></tr></thead><tbody><tr><td align="center">黑</td><td align="center">30</td><td align="center">40</td></tr><tr><td align="center">红</td><td align="center">31</td><td align="center">41</td></tr><tr><td align="center">绿</td><td align="center">32</td><td align="center">42</td></tr><tr><td align="center">黄</td><td align="center">33</td><td align="center">43</td></tr><tr><td align="center">蓝</td><td align="center">34</td><td align="center">44</td></tr><tr><td align="center">洋红</td><td align="center">35</td><td align="center">45</td></tr><tr><td align="center">青</td><td align="center">36</td><td align="center">46</td></tr><tr><td align="center">白</td><td align="center">37</td><td align="center">47</td></tr></tbody></table><h3 id="在脚本中显示色彩"><a href="#在脚本中显示色彩" class="headerlink" title="在脚本中显示色彩"></a>在脚本中显示色彩</h3><p>有两种方法：</p><ul><li>在shell脚本中，<strong>事先定义好”颜色变量”</strong>，然后使用echo -e 调用变量显示颜色；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义颜色变量，\033  \e  \E 都是等价的。</span></span><br><span class="line">RED=&#x27;\E[1;31m&#x27;</span><br><span class="line">GREEN=&#x27;\E[1;32m&#x27;</span><br><span class="line">YELLOW=&#x27;\E[1;33m&#x27;</span><br><span class="line">BLUE=&#x27;\E[1;34m&#x27;</span><br><span class="line">PINK=&#x27;\E[1;35m&#x27;</span><br><span class="line">RESET=&#x27;\E[0m&#x27;</span><br><span class="line"></span><br><span class="line">真正使用时，通过echo -e 调用</span><br><span class="line">echo -e &quot;$&#123;RED&#125;Red color$&#123;RESET&#125;&quot;</span><br><span class="line">echo -e &quot;$&#123;GREEN&#125;Red color$&#123;RESET&#125;&quot;</span><br><span class="line">echo -e &quot;$&#123;YELLOW&#125;Red color$&#123;RESET&#125;&quot;</span><br><span class="line">echo -e &quot;$&#123;BLUE&#125;Red color$&#123;RESET&#125;&quot;</span><br><span class="line">echo -e &quot;$&#123;PINK&#125;Red color$&#123;RESET&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在shell中，<strong>事先定义好”颜色动作”</strong>，然后直接调用动作来输出变量。(这样可以不用频繁输入echo了。)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义颜色动作，把<span class="built_in">echo</span> -e 也定义到变量中</span></span><br><span class="line">SETCOLOR_SUCCESS=&quot;echo -en \\E[1;32m&quot;</span><br><span class="line">SETCOLOR_FAILURE=&quot;echo -en \\E[1;31m&quot;</span><br><span class="line">SETCOLOR_WARNING=&quot;echo -en \\E[1;33m&quot;</span><br><span class="line">SETCOLOR_NORMAL=&quot;echo -en \\E[1;39m&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用时，直接调用颜色动作即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash">SETCOLOR_SUCCESS &amp;&amp; <span class="built_in">echo</span> SUCCESS</span></span><br><span class="line"><span class="meta">$</span><span class="bash">SETCOLOR_FAILURE &amp;&amp; <span class="built_in">echo</span> FAILURE</span></span><br><span class="line"><span class="meta">$</span><span class="bash">SETCOLOR_WARNING &amp;&amp; <span class="built_in">echo</span> WARNING</span></span><br><span class="line"><span class="meta">$</span><span class="bash">SETCOLOR_NORMAL &amp;&amp; <span class="built_in">echo</span> NORMAL</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试完之后，可以在终端输入 reset 恢复</span></span><br></pre></td></tr></table></figure><h3 id="使用tput简单的涂色"><a href="#使用tput简单的涂色" class="headerlink" title="使用tput简单的涂色"></a>使用tput简单的涂色</h3><p>UNIX 诞生之初，计算机专家就是用终端来登陆到UNIX主机的，而不同类型的终端，用着不同的命令集，这会导致终端与UNIX之间无法配合。为了解决这个问题，计算机专家将几乎所有类型的终端的命令集，都存储到了一个数据库中，以便实现统一化、标准化的处理和响应。<strong>这个数据库就叫terminfo</strong>。</p><p>而tput命令，会利用terminfo中的信息，控制和更改终端，比如控制光标、更改文本属性、控制屏幕，以及文本涂色等等。</p><blockquote><p><strong>tput setab：用于设置背景色；（background）</strong></p><p><strong>tput setaf：用于设置前景色。（foreground）</strong></p></blockquote><table><thead><tr><th align="center">数  值</th><th align="center">颜  色</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">黑</td></tr><tr><td align="center">1</td><td align="center">红</td></tr><tr><td align="center">2</td><td align="center">绿</td></tr><tr><td align="center">3</td><td align="center">黄</td></tr><tr><td align="center">4</td><td align="center">蓝</td></tr><tr><td align="center">5</td><td align="center">洋红</td></tr><tr><td align="center">6</td><td align="center">青</td></tr><tr><td align="center">7</td><td align="center">白</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RED=$(tput setaf 1)</span><br><span class="line">GREEN=$(tput setaf 2)</span><br><span class="line">YELLOW=$(tput setaf 3)</span><br><span class="line">RESET=$(tput sgr0)</span><br><span class="line"></span><br><span class="line">echo &quot;$&#123;RED&#125;red text $&#123;GREEN&#125;green text $&#123;YELLOW&#125;yellow text$&#123;RESET&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> sgr0 表示颜色重置</span></span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>无</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写出 Pythonic 的代码？</title>
      <link href="/2020/05/11/python/intermediate/pythonic-code-snippets/"/>
      <url>/2020/05/11/python/intermediate/pythonic-code-snippets/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Pythonic？"><a href="#什么是Pythonic？" class="headerlink" title="什么是Pythonic？"></a>什么是Pythonic？</h2><p><strong>Pythonic就是以Python的方式写出简洁、优美的代码。</strong></p><blockquote><p><strong>The Zen of Python</strong>（Python之禅） 执行 <strong>import this</strong> 查看</p></blockquote><h2 id="Pythonic-vs-Non-Pythonic-common-cases"><a href="#Pythonic-vs-Non-Pythonic-common-cases" class="headerlink" title="Pythonic vs Non-Pythonic common cases"></a>Pythonic vs Non-Pythonic common cases</h2><p><strong>P 代表 Pythonic， NP代表 Non-Pythonic。</strong>相比于NP，P的写法简练，明确，优雅，绝大部分时候执行效率高，代码越少也就越不容易出错。好的程序员在写代码时，应该追求代码的正确性，简洁性和可读性，这恰恰就是pythonic的精神所在。</p><span id="more"></span><h3 id="变量交换赋值"><a href="#变量交换赋值" class="headerlink" title="变量交换赋值"></a>变量交换赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">a,b = b,a</span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure><h3 id="Unpacking"><a href="#Unpacking" class="headerlink" title="Unpacking"></a>Unpacking</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">l = [<span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Pythonista&#x27;</span>, <span class="string">&#x27;+1-514-555-1234&#x27;</span>]</span><br><span class="line">first_name, last_name, phone_number = l</span><br><span class="line"><span class="comment"># Python 3 Only</span></span><br><span class="line">first, *middle, last = another_list</span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">l = [<span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Pythonista&#x27;</span>, <span class="string">&#x27;+1-514-555-1234&#x27;</span>]</span><br><span class="line">first_name = l[<span class="number">0</span>]</span><br><span class="line">last_name = l[<span class="number">1</span>]</span><br><span class="line">phone_number = l[<span class="number">2</span>] </span><br></pre></td></tr></table></figure><h3 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a>链式比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P </span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> &lt;= b &lt;= a &lt; <span class="number">10</span> <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">b &gt;= <span class="number">1</span> <span class="keyword">and</span> b &lt;= a <span class="keyword">and</span> a &lt; <span class="number">10</span> <span class="comment">#True</span></span><br></pre></td></tr></table></figure><h3 id="使用操作符in"><a href="#使用操作符in" class="headerlink" title="使用操作符in"></a>使用操作符in</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="keyword">if</span> fruit <span class="keyword">in</span> [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;berry&quot;</span>]:</span><br><span class="line"> <span class="comment"># 使用 in 更加简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">if</span> fruit == <span class="string">&quot;apple&quot;</span> <span class="keyword">or</span> fruit == <span class="string">&quot;orange&quot;</span> <span class="keyword">or</span> fruit == <span class="string">&quot;berry&quot;</span>:</span><br><span class="line"> <span class="comment"># 多次判断 </span></span><br></pre></td></tr></table></figure><h3 id="真值测试"><a href="#真值测试" class="headerlink" title="真值测试"></a>真值测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">name = <span class="string">&#x27;Tim&#x27;</span></span><br><span class="line">langs = [<span class="string">&#x27;AS3&#x27;</span>, <span class="string">&#x27;Lua&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tim&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">23</span> &#125;    </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">and</span> langs <span class="keyword">and</span> info:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All True!&#x27;</span>)  <span class="comment">#All True!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(langs) &gt; <span class="number">0</span> <span class="keyword">and</span> info != &#123;&#125;:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All True!&#x27;</span>) <span class="comment">#All True!</span></span><br></pre></td></tr></table></figure><p>P的写法就是对于<strong>任意对象</strong>，直接判断其真假，无需写判断条件，这样既能保证正确性，又能减少代码量。</p><table><thead><tr><th align="center">真</th><th align="center">假</th></tr></thead><tbody><tr><td align="center">True</td><td align="center">False</td></tr><tr><td align="center">任意非空字符串</td><td align="center">空字符串 <code>&#39;&#39;</code></td></tr><tr><td align="center">任意非0数字</td><td align="center">数字 <code>0</code></td></tr><tr><td align="center">任意非空容器</td><td align="center">空的容器 <code>[]``()``&#123;&#125;``set()</code></td></tr><tr><td align="center">其他任意非False</td><td align="center">None</td></tr></tbody></table><h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_str</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_str</span>(<span class="params">s</span>):</span></span><br><span class="line">    t = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        t += s[x]</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果用于检测回文，就是一句话input == input[::-1]</span></span><br></pre></td></tr></table></figure><h3 id="字符串列表的连接"><a href="#字符串列表的连接" class="headerlink" title="字符串列表的连接"></a>字符串列表的连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">strList = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;good&quot;</span>]  </span><br><span class="line">res =  <span class="string">&#x27; &#x27;</span>.join(strList) <span class="comment">#Python is good # 没有额外的内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">res = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strList:</span><br><span class="line">    res += s + <span class="string">&#x27; &#x27;</span> <span class="comment">#每次赋值都丢弃以前的字符串对象, 生成一个新对象</span></span><br><span class="line"><span class="comment">#Python is good </span></span><br><span class="line"><span class="comment">#最后还有个多余空格</span></span><br></pre></td></tr></table></figure><p><code>string.join()</code>常用于连接列表里的字符串，相对于NP，P的方式十分高效，且不会犯错。</p><h3 id="列表求和，最大值，最小值，乘积"><a href="#列表求和，最大值，最小值，乘积" class="headerlink" title="列表求和，最大值，最小值，乘积"></a>列表求和，最大值，最小值，乘积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">numList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]   </span><br><span class="line"> </span><br><span class="line"><span class="built_in">sum</span> = <span class="built_in">sum</span>(numList)  <span class="comment">#sum = 15</span></span><br><span class="line">maxNum = <span class="built_in">max</span>(numList) <span class="comment">#maxNum = 5</span></span><br><span class="line">minNum = <span class="built_in">min</span>(numList) <span class="comment">#minNum = 1</span></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce <span class="comment">#Python3 中 reduce被取消了，要从functools中导入</span></span><br><span class="line">prod = reduce(mul, numList, <span class="number">1</span>) <span class="comment">#prod = 120 默认值传1以防空列表报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">maxNum = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">minNum = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">prod = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numList:</span><br><span class="line">    <span class="keyword">if</span> num &gt; maxNum:</span><br><span class="line">        maxNum = num</span><br><span class="line">    <span class="keyword">if</span> num &lt; minNum:</span><br><span class="line">        minNum = num</span><br><span class="line">    <span class="built_in">sum</span> += num</span><br><span class="line">    prod *= num</span><br><span class="line"><span class="comment"># sum = 15 maxNum = 5 minNum = 1 prod = 120</span></span><br></pre></td></tr></table></figure><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">l = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment">#l = [0, 9, 36, 81]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        l.append(x*x)</span><br><span class="line"><span class="comment">#l = [0, 9, 36, 81]</span></span><br></pre></td></tr></table></figure><h3 id="列表推导嵌套"><a href="#列表推导嵌套" class="headerlink" title="列表推导嵌套"></a>列表推导嵌套</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">gen = (item <span class="keyword">for</span> sl <span class="keyword">in</span> nested_list <span class="keyword">if</span> list_condition(sl) </span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> sl <span class="keyword">if</span> item_condition(item))</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> gen:</span><br><span class="line"> <span class="comment"># do something...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">for</span> sub_list <span class="keyword">in</span> nested_list:</span><br><span class="line"><span class="keyword">if</span> list_condition(sub_list):</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> sub_list:</span><br><span class="line"><span class="keyword">if</span> item_condition(item):</span><br><span class="line"><span class="comment"># do something... </span></span><br></pre></td></tr></table></figure><h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">for</span> x, y, z <span class="keyword">in</span> product(x_list, y_list, z_list):</span><br><span class="line"><span class="comment"># do something for x, y, z</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> x_list:</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> y_list:</span><br><span class="line"><span class="keyword">for</span> z <span class="keyword">in</span> z_list:</span><br><span class="line"><span class="comment"># do something for x &amp; y </span></span><br></pre></td></tr></table></figure><h3 id="字典键值列表"><a href="#字典键值列表" class="headerlink" title="字典键值列表"></a>字典键值列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict:</span><br><span class="line"> <span class="comment"># my_dict[key] ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict.keys():</span><br><span class="line"> <span class="comment"># my_dict[key] ... </span></span><br></pre></td></tr></table></figure><p>只有当循环中需要更改key值的情况下，我们需要使用 my_dict.keys()</p><h3 id="字典键值判断"><a href="#字典键值判断" class="headerlink" title="字典键值判断"></a>字典键值判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> my_dict:</span><br><span class="line"> <span class="comment"># ...do something with d[key]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">if</span> my_dict.has_key(key):</span><br><span class="line"> <span class="comment"># ...do something with d[key] </span></span><br></pre></td></tr></table></figure><h3 id="字典-get-和-setdefault-方法"><a href="#字典-get-和-setdefault-方法" class="headerlink" title="字典 get 和 setdefault 方法"></a>字典 get 和 setdefault 方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">navs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (portfolio, equity, position) <span class="keyword">in</span> data:</span><br><span class="line"><span class="comment"># 使用 get 方法</span></span><br><span class="line">navs[portfolio] = navs.get(portfolio, <span class="number">0</span>) + position * prices[equity]</span><br><span class="line"><span class="comment"># 或者使用 setdefault 方法</span></span><br><span class="line">navs.setdefault(portfolio, <span class="number">0</span>)</span><br><span class="line">navs[portfolio] += position * prices[equity]</span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">navs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (portfolio, equity, position) <span class="keyword">in</span> data:</span><br><span class="line"><span class="keyword">if</span> portfolio <span class="keyword">not</span> <span class="keyword">in</span> navs:</span><br><span class="line">navs[portfolio] = <span class="number">0</span></span><br><span class="line">navs[portfolio] += position * prices[equity]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字典的默认值"><a href="#字典的默认值" class="headerlink" title="字典的默认值"></a>字典的默认值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">dic = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Tim&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">23</span>&#125;  </span><br><span class="line"> </span><br><span class="line">dic[<span class="string">&#x27;workage&#x27;</span>] = dic.get(<span class="string">&#x27;workage&#x27;</span>,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">#dic = &#123;&#x27;age&#x27;: 23, &#x27;workage&#x27;: 1, &#x27;name&#x27;: &#x27;Tim&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;workage&#x27;</span> <span class="keyword">in</span> dic:</span><br><span class="line">    dic[<span class="string">&#x27;workage&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dic[<span class="string">&#x27;workage&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">#dic = &#123;&#x27;age&#x27;: 23, &#x27;workage&#x27;: 1, &#x27;name&#x27;: &#x27;Tim&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>dict的<code>get(key,default)</code>方法用于获取字典中key的值，若不存在该key，则将key赋默认值default。<br>P相比NP的写法少了<code>if...else...</code></p><h3 id="for-else-语句"><a href="#for-else-语句" class="headerlink" title="for...else...语句"></a><code>for...else...</code>语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;find 5&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;can not find 5!&#x27;</span>)</span><br><span class="line"><span class="comment">#can not find 5!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">find = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">5</span>:</span><br><span class="line">        find = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;find 5&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> find:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;can not find 5!&#x27;</span>)</span><br><span class="line"><span class="comment">#can not find 5!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>for...else...</code>的else部分用来处理没有从for循环中断的情况。有了它，我们不用设置状态变量来检查是否for循环有break出来，简单方便。</p><h3 id="三元符的替代"><a href="#三元符的替代" class="headerlink" title="三元符的替代"></a>三元符的替代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">a = <span class="number">3</span>   </span><br><span class="line"> </span><br><span class="line">b = <span class="number">2</span> <span class="keyword">if</span> a &gt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#b = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">2</span>:</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line"><span class="comment">#b = 2</span></span><br></pre></td></tr></table></figure><h3 id="enumerate，带有索引位置的集合遍历"><a href="#enumerate，带有索引位置的集合遍历" class="headerlink" title="enumerate，带有索引位置的集合遍历"></a><code>enumerate</code>，带有索引位置的集合遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(array, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, e)</span><br><span class="line"><span class="comment"># 0 1</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br><span class="line"><span class="comment"># 2 3</span></span><br><span class="line"><span class="comment"># 3 4</span></span><br><span class="line"><span class="comment"># 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">    <span class="built_in">print</span>(i, array[i])</span><br><span class="line"><span class="comment">#0 1</span></span><br><span class="line"><span class="comment">#1 2</span></span><br><span class="line"><span class="comment">#2 3</span></span><br><span class="line"><span class="comment">#3 4</span></span><br><span class="line"><span class="comment">#4 5</span></span><br></pre></td></tr></table></figure><p>使用enumerate可以一次性将索引和值取出，避免使用索引来取值，而且enumerate的第二个参数可以调整索引下标的起始位置，默认为0。</p><h3 id="使用zip创建键值对"><a href="#使用zip创建键值对" class="headerlink" title="使用zip创建键值对"></a>使用<code>zip</code>创建键值对</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line">keys = [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line">values = [<span class="string">&#x27;Tim&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>, <span class="number">23</span>]</span><br><span class="line"> </span><br><span class="line">dic = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values))</span><br><span class="line"><span class="comment">#&#123;&#x27;Age&#x27;: 23, &#x27;Name&#x27;: &#x27;Tim&#x27;, &#x27;Sex&#x27;: &#x27;Male&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i,e <span class="keyword">in</span> <span class="built_in">enumerate</span>(keys):</span><br><span class="line">    dic[e] = values[i]</span><br><span class="line"><span class="comment">#&#123;&#x27;Age&#x27;: 23, &#x27;Name&#x27;: &#x27;Tim&#x27;, &#x27;Sex&#x27;: &#x27;Male&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>zip方法返回的是一个元组，用它来创建键值对，简单明了。</p><h3 id="表达式单行显示"><a href="#表达式单行显示" class="headerlink" title="表达式单行显示"></a>表达式单行显示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cond1 = &lt;<span class="built_in">complex</span> comparison&gt;</span><br><span class="line">cond2 = &lt;other <span class="built_in">complex</span> comparison&gt;</span><br><span class="line"><span class="keyword">if</span> cond1 <span class="keyword">and</span> cond2:</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;one&#x27;</span>); <span class="built_in">print</span>(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">1</span>: <span class="built_in">print</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &lt;<span class="built_in">complex</span> comparison&gt; <span class="keyword">and</span> &lt;other <span class="built_in">complex</span> comparison&gt;:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><h3 id="使用-with-处理文件"><a href="#使用-with-处理文件" class="headerlink" title="使用 with 处理文件"></a>使用 with 处理文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;some_file.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read()</span><br><span class="line"><span class="comment"># 其他文件操作...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;some_file.txt&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">data = f.read()</span><br><span class="line"><span class="comment"># 其他文件操作..</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h3 id="使用-with-忽视异常-仅限Python-3"><a href="#使用-with-忽视异常-仅限Python-3" class="headerlink" title="使用 with 忽视异常(仅限Python 3)"></a>使用 with 忽视异常(仅限Python 3)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ignored <span class="comment"># Python 3 only</span></span><br><span class="line"><span class="keyword">with</span> ignored(OSError):</span><br><span class="line">os.remove(<span class="string">&quot;somefile.txt&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">os.remove(<span class="string">&quot;somefile.txt&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="使用-with-处理加锁"><a href="#使用-with-处理加锁" class="headerlink" title="使用 with 处理加锁"></a>使用 with 处理加锁</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#P</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">     <span class="comment"># 互斥操作...</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#NP</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()</span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 互斥操作...</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><h3 id="尽量使用生成器替代列表"><a href="#尽量使用生成器替代列表" class="headerlink" title="尽量使用生成器替代列表"></a>尽量使用生成器替代列表</h3><h3 id="中间结果尽量使用imap-ifilter代替map-filter"><a href="#中间结果尽量使用imap-ifilter代替map-filter" class="headerlink" title="中间结果尽量使用imap/ifilter代替map/filter"></a>中间结果尽量使用imap/ifilter代替map/filter</h3><h3 id="善用装饰器"><a href="#善用装饰器" class="headerlink" title="善用装饰器"></a>善用装饰器</h3><p>······</p><h2 id="Pythonic-编程惯用法"><a href="#Pythonic-编程惯用法" class="headerlink" title="Pythonic 编程惯用法"></a>Pythonic 编程惯用法</h2><h3 id="利用assert-语句发现问题"><a href="#利用assert-语句发现问题" class="headerlink" title="利用assert 语句发现问题"></a>利用assert 语句发现问题</h3><h3 id="数据交换时不推荐使用中间变量"><a href="#数据交换时不推荐使用中间变量" class="headerlink" title="数据交换时不推荐使用中间变量"></a>数据交换时不推荐使用中间变量</h3><h3 id="充分利用lazy-evaluation-的特性"><a href="#充分利用lazy-evaluation-的特性" class="headerlink" title="充分利用lazy evaluation 的特性"></a>充分利用lazy evaluation 的特性</h3><h3 id="不推荐使用type进行类型检查"><a href="#不推荐使用type进行类型检查" class="headerlink" title="不推荐使用type进行类型检查"></a>不推荐使用type进行类型检查</h3><p>因为有些时候type的结果并不一定可靠。如果有需求，建议使用isinstance函数来代替。</p><h3 id="浮点数可能是不准确的"><a href="#浮点数可能是不准确的" class="headerlink" title="浮点数可能是不准确的"></a>浮点数可能是不准确的</h3><p>——<strong>未完待续</strong>，<strong>先消化完拓展阅读的东西再总结</strong>  2020/5/11</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://www.cnblogs.com/Simon-xm/p/4058932.html"><strong>Code Like a Pythonista: Idiomatic Python–译</strong></a></p><p><a href="https://www.iteye.com/blog/2057-1807516"><strong>Code Like a Pythonista: Idiomatic Python(原文)</strong></a></p><p><a href="https://wuzhiwei.net/be_pythonic/"><strong>让你的Python代码更加 pythonic</strong></a></p><p><a href="https://python-web-guide.readthedocs.io/zh/latest/codingstyle/codingstyle.html"><strong>《编码之前碎碎念(工程实践) - python-web-guide 0.1 文档》</strong></a></p><p><a href="https://www.cnblogs.com/jcli/p/3624904.html">分享书籍writing idiomatic python ebook</a></p><p><a href="https://buildmedia.readthedocs.org/media/pdf/python-3-patterns-idioms-test/latest/python-3-patterns-idioms-test.pdf">《Python 3 Patterns, Recipes and Idioms》</a></p><p><a href="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/26312313/">《Effective Python》</a></p><p><a href="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/25910544/">《编写高质量代码：改善Python程序的91个建议》</a></p><p><a href="https://www.zhihu.com/question/37751951/answer/73425339"><strong>知乎—Python 有哪些优雅的代码实现让自己的代码更pythonic</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Intermediate </category>
          
          <category> Experience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code snippets </tag>
            
            <tag> pythonic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中的可变参数 *args 和 **kwargs</title>
      <link href="/2020/05/10/python/intermediate/args-and-kwargs/"/>
      <url>/2020/05/10/python/intermediate/args-and-kwargs/</url>
      
        <content type="html"><![CDATA[<p>在Python中的代码中经常会见到这两个词 *args 和 **kwargs，这两个词主要用于函数定义，表示将不定数量的参数 (Variable Argument) 传递给一个函数。而其实前面的星号才是必须的，args 和 kwargs 只是编程人员约定的变量名字。</p><p>args 是 arguments 的缩写，表示位置参数，<strong>它的数据类型是一个tuple</strong>。</p><p>kwargs 是 keyword arguments 的缩写，表示关键字参数。<strong>它的数据类型是一个dict。</strong></p><span id="more"></span><h2 id="Ordering-Arguments"><a href="#Ordering-Arguments" class="headerlink" title="Ordering Arguments"></a>Ordering Arguments</h2><p>Python中的参数有位置参数 (positional arguments) 和关键字参数 (keyword arguments) 之分。在函数定义或者函数调用时，各种参数之间的顺序是有要求的，顺序如下: </p><blockquote><ol><li><p><strong>Formal positional arguments</strong></p></li><li><p><strong>*args</strong></p></li><li><p><strong>Keyword arguments</strong></p></li><li><p><strong>**kwargs</strong></p></li></ol></blockquote><h2 id="args的用法"><a href="#args的用法" class="headerlink" title="*args的用法"></a>*args的用法</h2><p>*args就是就是传递一个可变参数列表给函数实参，这个参数列表的数目未知，甚至长度可以为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args</span>(<span class="params">first, *args</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Required argument: &#x27;</span>, first)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(args))</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Optional argument: &#x27;</span>, v)</span><br><span class="line"></span><br><span class="line">test_args(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>第一个参数是必须要传入的参数，所以使用了第一个形参，而后面三个参数则作为可变参数列表传入了实参，并且是作为元组tuple来使用的。代码的运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Required argument:  <span class="number">1</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Optional</span> <span class="title">argument</span>:</span>  <span class="number">2</span></span><br><span class="line"><span class="type">Optional</span> argument:  <span class="number">3</span></span><br><span class="line"><span class="type">Optional</span> argument:  <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="kwargs-的用法"><a href="#kwargs-的用法" class="headerlink" title="**kwargs 的用法"></a>**kwargs 的用法</h2><p>而**kwargs则是将一个可变的关键字参数的字典传给函数实参，同样参数列表长度可以为0或为其他值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_kwargs</span>(<span class="params">first, *args, **kwargs</span>):</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;Required argument: &#x27;</span>, first)</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">type</span>(kwargs))</span><br><span class="line">   <span class="keyword">for</span> v <span class="keyword">in</span> args:</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;Optional argument (args): &#x27;</span>, v)</span><br><span class="line">   <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;Optional argument %s (kwargs): %s&#x27;</span> % (k, v))</span><br><span class="line"></span><br><span class="line">test_kwargs(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, k1=<span class="number">5</span>, k2=<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>正如前面所说的，args类型是一个tuple，而kwargs则是一个字典dict，并且args只能位于kwargs的前面。代码的运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Required argument:  <span class="number">1</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">dict</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">Optional</span> <span class="title">argument</span> (<span class="params">args</span>):</span>  <span class="number">2</span></span><br><span class="line"><span class="type">Optional</span> argument (args):  <span class="number">3</span></span><br><span class="line"><span class="type">Optional</span> argument (args):  <span class="number">4</span></span><br><span class="line"><span class="type">Optional</span> argument k1 (kwargs): <span class="number">5</span></span><br><span class="line"><span class="type">Optional</span> argument k2 (kwargs): <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>args和kwargs不仅可以在函数定义中使用，还可以在函数调用中使用。在调用时使用就相当于pack（打包）和unpack（解包），类似于元组的打包和解包。</p><p>如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args_kwargs</span>(<span class="params">arg1, arg2, arg3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;arg1:&quot;</span>, arg1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;arg2:&quot;</span>, arg2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;arg3:&quot;</span>, arg3)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用args来解包调用函数</span></span><br><span class="line">args = (<span class="string">&quot;two&quot;</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">test_args_kwargs(*args)</span><br><span class="line"></span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">arg1: two</span><br><span class="line">arg2: <span class="number">3</span></span><br><span class="line">arg3: <span class="number">5</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#使用kwargs解包调用函数</span></span><br><span class="line">kwargs = &#123;<span class="string">&quot;arg3&quot;</span>: <span class="number">3</span>, <span class="string">&quot;arg2&quot;</span>: <span class="string">&quot;two&quot;</span>, <span class="string">&quot;arg1&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">test_args_kwargs(**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">arg1: <span class="number">5</span></span><br><span class="line">arg2: two</span><br><span class="line">arg3: <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="常见的使用场景"><a href="#常见的使用场景" class="headerlink" title="常见的使用场景"></a>常见的使用场景</h2><p>最常见的用例是在<strong>写函数装饰器</strong>的时候。</p><p>此外也可以<strong>用来做猴子补丁(monkey patching)</strong>。</p><p>猴子补丁的意思是指Python中类和模块可以在外部被动态修改这种特性。通常是添加功能或修正缺陷。猴子补丁在代码运行时内存中发挥作用，不会修改源码，因此只对当前运行的程序实例有效。</p><p>为什么叫做猴子补丁呢？在模块和类的外部对模块和类进行修改是一种非常耍赖的做法，会破坏代码的封装结构，这种事情大概只有淘气的猴子喜欢去做，因此形象地称之为猴子补丁。</p><p>——待完善</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://www.agiliq.com/blog/2012/06/understanding-args-and-kwargs/"><strong>Understanding ‘*‘, ‘*args’, ‘**‘ and ‘**kwargs’</strong></a></p><p><a href="https://blog.csdn.net/callinglove/article/details/45483097"><strong>理解’*‘,’*args’,’**‘,’**kwargs’(译)</strong></a></p><p><a href="https://www.cnblogs.com/abclife/p/11483372.html"><strong>Python中的args和kwargs</strong></a></p><p><a href="https://www.digitalocean.com/community/tutorials/how-to-use-args-and-kwargs-in-python-3"><strong>How To Use *args and **kwargs in Python 3</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Intermediate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> args </tag>
            
            <tag> kwargs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写出更好的 Python 函数 （翻译-转载）</title>
      <link href="/2020/05/07/python/intermediate/how-to-write-better-python-functions/"/>
      <url>/2020/05/07/python/intermediate/how-to-write-better-python-functions/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 简洁灵活，但是要想用好，并不简单，那么如何写出一个好的Python函数呢？《Writing Idiomatic Python》一书的作者在 Medium 上发表了一篇文章，给出了 6 个建议。</p><h3 id="0-怎样算是一个好的函数？"><a href="#0-怎样算是一个好的函数？" class="headerlink" title="0. 怎样算是一个好的函数？"></a>0. 怎样算是一个好的函数？</h3><p>“<strong>好</strong>”的 Python 函数和“<strong>差</strong>”的 Python 函数之间<strong>有什么差别</strong>呢？每个人都有自己的理解。基于我的理解，如果一个 Python 函数能够符合下面的大部分条件，我会认为它是一个“好”函数：</p><blockquote><ul><li><strong>命名合理</strong></li><li><strong>单一功能</strong></li><li><strong>包括文档字符串</strong></li><li><strong>返回一个值</strong></li><li><strong>不超过 50 行</strong></li><li><strong>是幂等函数或纯函数</strong></li></ul></blockquote><p>对许多人来说，这些要求可能显得过于苛刻了。</p><p>不过，<strong>如果你的函数遵循这些规则，你的代码会非常漂亮</strong>。</p><p>下面，我将一一讨论这些规则，然后总结它们是如何创造“好”函数的。</p><span id="more"></span><h2 id="1-命名（Naming）"><a href="#1-命名（Naming）" class="headerlink" title="1. 命名（Naming）"></a>1. 命名（Naming）</h2><p>在这个问题上，我最喜欢的一句话是：</p><blockquote><p><strong>计算机科学中只有两件事很让人头疼：缓存失效和命名。</strong></p></blockquote><p>尽管这听起来很莫名其妙，但给一个事情命名太难了。下面是一个反面案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_knn_from_df</span>(<span class="params">df</span>):</span></span><br></pre></td></tr></table></figure><p>上面这个例子来源于数据分析领域 (准确的讲是机器学习相关的，k-近邻模型)。</p><p>这个函数命名的第一个问题是它使用了缩写。</p><p><strong>对于那些并不出名的缩略词来说，使用完整的英语单词会更好。</strong>缩写单词的唯一原因是为了节省打字时间，但是每个现代编辑器都有自动填充功能，所以你只需要键入一次全名就可以了。</p><p>缩写通常是特定领域的。在上面的代码中，KNN 指的是“K-Nearest Neighbors”，df 指的是“DataFrame”，这是一个数据结构。如果另一个不熟悉这些首字母缩写的程序员正在阅读代码，几乎很难看懂。</p><p>关于这个函数的名字还有另外两个小瑕疵：</p><ul><li>“get”这个词是无关紧要的。对于大多数命名比较好的函数来说，很明显有一些东西会从函数中返回，它的名字将反映这一点。</li><li>from_df 也不是必要的。如果没有明确的参数名称，函数的文档字符串或类型注释会描述参数的类型。</li></ul><p>那么我们如何重命名这个函数呢？很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_nearest_neighbors</span>(<span class="params">dataframe</span>):</span></span><br></pre></td></tr></table></figure><p>即使是外行，这个函数要计算的内容也很清楚，参数的名称(dataframe) 也清楚地表明了参数类型。</p><h2 id="2-单一功能（Single-Responsibility）"><a href="#2-单一功能（Single-Responsibility）" class="headerlink" title="2. 单一功能（Single Responsibility）"></a>2. 单一功能（Single Responsibility）</h2><p><strong>单一功能原则不仅适用于类和模块，也同样适用于函数。</strong></p><p>一个函数应该只有一个功能。也就是说，它应该做且只做一件事。</p><p>一个重要的原因是，如果每个函数只做一件事，只有这件事发生了变化，才需要改变这个函数。</p><p>此外，如果这个函数的单个功能不再需要了，直接把它删了就行了。</p><p>还是用例子来说明吧。下面这个函数，可以做不止一件“事情”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_and</span> <span class="title">print_stats</span>(<span class="params">list_of_numbers</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>(list_of_numbers)</span><br><span class="line">    mean = statistics.mean(list_of_numbers)</span><br><span class="line">    median = statistics.median(list_of_numbers)</span><br><span class="line">    mode = statistics.mode(list_of_numbers)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-----------------Stats-----------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;SUM: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">sum</span>) <span class="built_in">print</span>(<span class="string">&#x27;MEAN: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(mean)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;MEDIAN: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(median)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;MODE: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(mode)</span><br></pre></td></tr></table></figure><p>这个函数做了两件事：一是计算一组关于数字列表的统计数据，二是将它们打印到 STDOUT。</p><p>如果需要计算新的或不同的统计数据，或者需要改变输出的格式，就需要对这个函数进行调整。</p><p>所以，这个函数最好写成两个独立的函数：一个用来执行并返回计算结果，另一个用来获取这些结果并打印出来。</p><p>这种处理方式，不仅能让测试函数更容易，并且还允许这两个部分有了迁移性，如果合适的话，还可能一起应用到不同的模块中。</p><p><strong>在编程中，你会发现好多函数都可以做很多很多事情。同样，为了可读性和可测试性，这些多功能函数应该被分解成更小的函数，每个函数只有一个功能。</strong></p><h2 id="3-文档字符串（Docstrings）"><a href="#3-文档字符串（Docstrings）" class="headerlink" title="3. 文档字符串（Docstrings）"></a>3. 文档字符串（Docstrings）</h2><p>虽然每个人似乎都知道 <strong>PEP - 8</strong>，它<strong>定义了 Python 的样式指南</strong>，但是很少有人知道 <strong>PEP - 257</strong>，它<strong>是关于文档字符串的</strong>。我再这里不简单地重复 PEP - 257 的内容了，你可以在闲暇时读一下。其中的关键内容是：</p><blockquote><ul><li>每个函数都需要有一个文档字符串</li><li>使用适当的语法和标点符号；用完整的句子写</li><li>首先对函数的作用进行一句话的总结</li><li>使用说明性语言而不是描述性语言</li></ul></blockquote><p>在编写函数时，<strong>要养成写文档字符串的习惯，并在编写函数代码  之前   尝试写一下</strong>。</p><p><strong>如果你不能写一个清晰的文档字符串来描述函数做什么，就说明你需要再考虑考虑为什么要写这个函数了。</strong></p><h2 id="4-返回值-（Return-Values）"><a href="#4-返回值-（Return-Values）" class="headerlink" title="4. 返回值 （Return Values）"></a>4. 返回值 （Return Values）</h2><p>函数可以被认为是一些独立的程序。它们以参数的形式接受一些输入，并返回一些结果。</p><p>参数有没有都可以，但从 Python 内部的角度来看，返回值是必须要有的。你不可能创建一个没有返回值的函数。如果函数没有返回值，Python 会“强制”返回 None。你可以测试一下这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">❯ python3</span><br><span class="line">Python <span class="number">3.7</span><span class="number">.0</span> (default, Jul <span class="number">232018</span>, <span class="number">20</span>:<span class="number">22</span>:<span class="number">55</span>)</span><br><span class="line">[Clang <span class="number">9.1</span><span class="number">.0</span> (clang-<span class="number">902.0</span><span class="number">.39</span><span class="number">.2</span>)] on darwin</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span>o<span class="string">r&quot;license&quot;</span><span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(a + b)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>你会发现 b 的返回值实际上是 None。即使你写的函数没有返回语句，它仍然会返回一些东西。而且，每个函数都应该返回一个有用的值，测试起来也会更方便。毕竟，你写的代码应该能够被测试。</p><p>试想一下，测试上面的 add 函会有多艰难。遵循这个概念，我们应该这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> input_file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> input_file:</span><br><span class="line">        <span class="keyword">if</span> line.strip().lower().endswith(<span class="string">&#x27;cat&#x27;</span>):</span><br><span class="line">        <span class="comment"># ... do something useful with these lines</span></span><br></pre></td></tr></table></figure><p><code>if line.strip().lower().endswith(‘cat’):</code> 这一行能够工作，是因为每个字符串方法( strip ( )、lower ( )、endswith ( ) ) 都返回一个字符串作为调用函数的结果。</p><p>当给定函数没有返回值时，有一些常见的原因：</p><ul><li><strong>“它所做的只是[一些与 I/O 相关的事情，比如将一个值保存到数据库中]。我不能返回任何有用的东西。”</strong></li></ul><p>我不同意。如果操作顺利完成，函数可以返回 True。</p><ul><li><strong>“我们修改了其中一个参数，将其用作参考参数。”</strong></li></ul><p>这里有两点需要注意。首先，尽最大努力避免这种做法。用好了令人惊讶，用不好非常危险。</p><p>其次，即使这样做不可行，复制某个参数的成本太高，你也可以回到上一条建议。</p><ul><li><strong>“我需要返回多个值。单独返回一个值是没有意义的。”</strong></li></ul><p>其实，可以使用元组返回多个值。</p><p>总是返回一个有用的值，调用者也总能自由地去忽略掉它们。</p><h2 id="5-函数长度-（Function-Length）"><a href="#5-函数长度-（Function-Length）" class="headerlink" title="5. 函数长度 （Function Length）"></a>5. 函数长度 （Function Length）</h2><p>让你读一个 200 行的函数，并说出它是做什么的，你是什么感受？</p><p><strong>函数的长度直接影响可读性，从而影响可维护性。</strong>所以要保持你的函数简短。50 行是一个随意的数字，在我看来是合理的。你编写的大多数函数应该要短一些。</p><p>如果一个函数遵循单一功能原则，它很可能是相当短的。如果它是纯函数或是幂等的 (下面讨论) ，它也可能是短的。</p><p>那么，<strong>如果函数太长，应该怎么做？重构（Refactor）。</strong>这只会改变程序的结构而不改变其行为。</p><p>从一个长函数中提取几行代码，并把它们变成其自己的函数就是一种重构。这是缩短长函数的最快、也是最常见的方式。</p><p>加上你给所有这些新函数取了合适的名称，因此生成的代码读起来也会更容易。</p><h2 id="6-幂等和函数纯度-（Idempotency-and-Functional-Purity）"><a href="#6-幂等和函数纯度-（Idempotency-and-Functional-Purity）" class="headerlink" title="6. 幂等和函数纯度 （Idempotency and Functional Purity）"></a>6. 幂等和函数纯度 （Idempotency and Functional Purity）</h2><p><strong>不管被调用了多少次，幂等函数总是在给定相同参数集的情况下返回相同的值。结果不依赖于非局部变量、参数的可变性或来自任何 I / O 流的数据。</strong></p><p>下面的这个 add_three(number) 函数是幂等函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_three</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return *number* + 3.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>不管一个人调用 add_three(7)多少次，答案总是 10。</p><p>以下是一个非幂等函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_three</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return 3 + the number entered by the user.&quot;&quot;&quot;</span></span><br><span class="line">    number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter a number: &#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这个函数的返回值取决于 I / O，即用户输入的数字。对 add_three() 的每次调用都会返回不同的值。</p><p>如果它被调用两次，用户可以第一次输入 3，第二次输入 7，分别调用 add_three()返回 6 和 10。</p><p><strong>幂等性的一个现实中例子是在电梯前点击“向上”按钮。</strong>第一次按时，电梯会被“通知”你要上去。因为按按钮是幂等的，所以反复按它都没有什么影响。结果是一样的。</p><h3 id="6-1-为什么幂等很重要？"><a href="#6-1-为什么幂等很重要？" class="headerlink" title="6.1 为什么幂等很重要？"></a>6.1 为什么幂等很重要？</h3><p><strong>可测试性和可维护性</strong>。</p><p>幂等函数很容易测试，因为在使用相同的参数时，它们总是返回相同的结果。</p><p>测试仅仅是检查通过不同调用返回值的预期值。更重要的是，这些测试很快，这是单元测试中一个重要且经常被忽视的问题。</p><p>而在处理幂等函数时，重构是轻而易举的事情。无论如何在函数之外更改代码，使用相同的参数调用它的结果总是一样的。</p><h3 id="6-2-什么是纯函数？"><a href="#6-2-什么是纯函数？" class="headerlink" title="6.2 什么是纯函数？"></a>6.2 什么是纯函数？</h3><p><strong>在函数编程中，如果一个函数既幂等又没有可观察到的副作用，它就被认为是纯函数。</strong>因为有幂等性，所以函数外部的任何东西都不会影响这个值。然而，这并不意味着函数不能影响非局部变量或 I / O 流之类的事情。例如，如果上面 add_three(number)的幂等版本在返回结果之前打印了结果，那么它仍然被认为是幂等的，因为当它访问 I / O 流时，这个访问与从函数返回的值无关。</p><p>调用 print()只是一个副作用：除了返回值之外，还与程序的其他部分或系统本身进行了一些交互。</p><p>让我们把我们的 add_three(number)示例再向前推进一步。我们可以编写下面的代码片段来确定调用 add_three(number)的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add_three_calls = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_three</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return *number* + 3.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> add_three_calls</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Returning <span class="subst">&#123;number + <span class="number">3</span>&#125;</span>&#x27;</span>)</span><br><span class="line">    add_three_calls += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_calls</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the number of times *add_three* was called.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> add_three_calls</span><br></pre></td></tr></table></figure><p>我们现在正在打印到控制台(一个副作用)并修改一个非局部变量(另一个副作用)，但是由于这两者都不影响函数返回的值，它仍然是幂等的。</p><p>纯函数没有副作用。它不仅不使用任何“外部数据”来计算值，除了计算和返回所述值之外，它与系统/程序的其余部分都没有交互。因此，虽然我们新的 add_three(number) 定义仍然是幂等的，但它不再是纯的。</p><p><strong>纯函数没有日志语句或 print()调用。</strong></p><p><strong>它们不使用数据库或互联网连接。</strong></p><p><strong>它们不访问或修改非局部变量。</strong></p><p><strong>它们不调用任何其他非纯函数。</strong></p><p>简而言之，它们无法做到爱因斯坦所说的“远距离幽灵般的行动”(在计算机科学环境中)。它们不会以任何方式修改程序或系统的其余部分。</p><p>在交互式编程(编写 Python 代码时所做的那种)中，它们是所有函数中最安全的函数。</p><p>它们也很容易被测试和维护，甚至比只是幂等函数更重要的是，测试它们基本上可以和执行它们一样快。</p><p>它的测试本身很简单：没有数据库连接或其他外部资源进行模拟，也不需要安装代码，之后也没有什么需要清理的。</p><p><strong>准确地来说，幂等性和纯函数只是一种期望，不是必需的。</strong>也就是说，由于好处很多，我们可能会希望只编写纯函数或幂等函数，但这并不现实。</p><p><strong>重要的是，我们要有意识开始写代码来隔离副作用和外部依赖性。这会使得我们编写的每一行代码都更容易被测试。</strong></p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://hackernoon.com/write-better-python-functions-c3a9a36382a6"><strong>Write Better Python Functions</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Intermediate </category>
          
          <category> Experience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中的魔术方法(magic methods)</title>
      <link href="/2020/05/02/python/intermediate/magic-methods/"/>
      <url>/2020/05/02/python/intermediate/magic-methods/</url>
      
        <content type="html"><![CDATA[<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://my.oschina.net/jhao104/blog/779743"><strong>Python魔术方法-Magic Method</strong></a></p><p><a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id28"><strong>(译)Python魔法方法指南</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Intermediate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> magic methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 内置函数</title>
      <link href="/2020/05/02/python/fundation/69-builtins/"/>
      <url>/2020/05/02/python/fundation/69-builtins/</url>
      
        <content type="html"><![CDATA[<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>内置函数，一般都是因为使用频率比较频繁或是元操作，所以通过内置函数的形式提供出来。</p><p>python 版本不同，其内容也有变化，例如之前Py2 vs. Py3 还存在 xrange() vs. range()， raw_input() vs. input()，现在只保留range()、input()。依据目前的python 3.8 版本，共计69个（实际上，<a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#The_distinction_between_functions_and_classes_often_doesn't_matter">only 42 of them are actually functions</a>）。</p><span id="more"></span><h2 id="按功能类型分类"><a href="#按功能类型分类" class="headerlink" title="按功能类型分类"></a>按功能类型分类</h2><table><thead><tr><th align="center">类型</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">数学运算</td><td align="center">7</td></tr><tr><td align="center">类型转换</td><td align="center">24</td></tr><tr><td align="center">序列操作</td><td align="center">8</td></tr><tr><td align="center">对象操作</td><td align="center">9</td></tr><tr><td align="center">反射操作</td><td align="center">8</td></tr><tr><td align="center">变量操作</td><td align="center">2</td></tr><tr><td align="center">交互操作</td><td align="center">2</td></tr><tr><td align="center">文件操作</td><td align="center">1</td></tr><tr><td align="center">编译执行</td><td align="center">5</td></tr><tr><td align="center">装饰器相关</td><td align="center">3</td></tr></tbody></table><p>注：其分类的对象操作和反射操作中，有自省的东西，见之前的博客——《Python  自省与反射》，文件操作和交互操作也可以合并，因为参照的别的博客文章，所以，还是宏观掌握，实际应用为主，也懒得自己重新分类了。</p><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">abs()</td><td align="center">返回一个数的绝对值</td></tr><tr><td align="center">divmod()</td><td align="center">返回两个数值的商和余数</td></tr><tr><td align="center">max()</td><td align="center">返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的</td></tr><tr><td align="center">min()</td><td align="center">返回可迭代对象中的元素中的最小值或者所有参数的最小值</td></tr><tr><td align="center">pow()</td><td align="center">返回两个数值的幂运算值或其与指定整数的模值</td></tr><tr><td align="center">round()</td><td align="center">对浮点数进行四舍五入求值</td></tr><tr><td align="center">sum()</td><td align="center">对元素类型是数值的可迭代对象中的每个元素求和</td></tr></tbody></table><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">bool()</td><td align="center">根据传入的参数的逻辑值创建一个新的布尔值</td></tr><tr><td align="center">int()</td><td align="center">根据传入的参数创建一个新的整数</td></tr><tr><td align="center">float()</td><td align="center">根据传入的参数创建一个新的浮点数</td></tr><tr><td align="center">complex()</td><td align="center">根据传入参数创建一个新的复数</td></tr><tr><td align="center">str()</td><td align="center">返回一个对象的字符串表现形式(给用户)</td></tr><tr><td align="center">bytearray()</td><td align="center">根据传入的参数创建一个新的字节数组</td></tr><tr><td align="center">bytes()</td><td align="center">根据传入的参数创建一个新的不可变字节数组</td></tr><tr><td align="center">memoryview()</td><td align="center">根据传入的参数创建一个新的内存查看对象</td></tr><tr><td align="center">ord()</td><td align="center">返回Unicode字符对应的整数</td></tr><tr><td align="center">chr()</td><td align="center">返回整数所对应的Unicode字符</td></tr><tr><td align="center">bin()</td><td align="center">将整数转换成2进制字符串</td></tr><tr><td align="center">oct()</td><td align="center">将整数转化成8进制数字符串</td></tr><tr><td align="center">hex()</td><td align="center">将整数转换成16进制字符串</td></tr><tr><td align="center">tuple()</td><td align="center">根据传入的参数创建一个新的元组</td></tr><tr><td align="center">list()</td><td align="center">根据传入的参数创建一个新的列表</td></tr><tr><td align="center">dict()</td><td align="center">根据传入的参数创建一个新的字典</td></tr><tr><td align="center">set()</td><td align="center">根据传入的参数创建一个新的集合</td></tr><tr><td align="center">frozenset()</td><td align="center">根据传入的参数创建一个新的不可变集合</td></tr><tr><td align="center">enumerate()</td><td align="center">根据可迭代对象创建枚举对象</td></tr><tr><td align="center">range()</td><td align="center">根据传入的参数创建一个新的range对象</td></tr><tr><td align="center">iter()</td><td align="center">根据传入的参数创建一个新的可迭代对象</td></tr><tr><td align="center">slice()</td><td align="center">根据传入的参数创建一个新的切片对象</td></tr><tr><td align="center">super()</td><td align="center">根据传入的参数创建一个新的子类和父类关系的代理对象</td></tr><tr><td align="center">object()</td><td align="center">创建一个新的object对象</td></tr></tbody></table><h3 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">all()</td><td align="center">判断可迭代对象的每个元素是否都为True值</td></tr><tr><td align="center">any()</td><td align="center">判断可迭代对象的元素是否有为True值的元素</td></tr><tr><td align="center">filter()</td><td align="center">使用指定方法过滤可迭代对象的元素</td></tr><tr><td align="center">map()</td><td align="center">使用指定方法去作用传入的每个可迭代对象的元素，生成新的可迭代对象</td></tr><tr><td align="center">next()</td><td align="center">返回可迭代对象中的下一个元素值</td></tr><tr><td align="center">reversed()</td><td align="center">反转序列生成新的可迭代对象</td></tr><tr><td align="center">sorted()</td><td align="center">对可迭代对象进行排序，返回一个新的列表</td></tr><tr><td align="center">zip()</td><td align="center">聚合传入的每个迭代器中相同位置的元素，返回一个新的元组类型迭代器</td></tr></tbody></table><h3 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">help()</td><td align="center">返回对象的帮助信息</td></tr><tr><td align="center">dir()</td><td align="center">返回对象或者当前作用域内的属性列表</td></tr><tr><td align="center">id()</td><td align="center">返回对象的唯一标识符</td></tr><tr><td align="center">hash()</td><td align="center">获取对象的哈希值</td></tr><tr><td align="center">type()</td><td align="center">返回对象的类型，或者根据传入的参数创建一个新的类型</td></tr><tr><td align="center">len()</td><td align="center">返回对象的长度</td></tr><tr><td align="center">ascii()</td><td align="center">返回对象的可打印表字符串表现方式</td></tr><tr><td align="center">format()</td><td align="center">格式化显示值</td></tr><tr><td align="center">vars()</td><td align="center">返回当前作用域内的局部变量和其值组成的字典，或者返回对象的属性列表</td></tr></tbody></table><h3 id="反射操作"><a href="#反射操作" class="headerlink" title="反射操作"></a>反射操作</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">__import__()</td><td align="center">动态导入模块</td></tr><tr><td align="center">isinstance()</td><td align="center">判断对象是否是类或者类型元组中任意类元素的实例</td></tr><tr><td align="center">issubclass()</td><td align="center">判断类是否是另外一个类或者类型元组中任意类元素的子类</td></tr><tr><td align="center">hasattr()</td><td align="center">检查对象是否含有属性</td></tr><tr><td align="center">getattr()</td><td align="center">获取对象的属性值</td></tr><tr><td align="center">setattr()</td><td align="center">设置对象的属性值</td></tr><tr><td align="center">delattr()</td><td align="center">删除对象的属性</td></tr><tr><td align="center">callable()</td><td align="center">检测对象是否可被调用</td></tr></tbody></table><h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">globals()</td><td align="center">返回当前作用域内的全局变量和其值组成的字典</td></tr><tr><td align="center">locals()</td><td align="center">返回当前作用域内的局部变量和其值组成的字典</td></tr></tbody></table><h3 id="交互操作"><a href="#交互操作" class="headerlink" title="交互操作"></a>交互操作</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">print()</td><td align="center">向标准输出对象打印输出</td></tr><tr><td align="center">input()</td><td align="center">读取用户输入值</td></tr></tbody></table><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">open()</td><td align="center">使用指定的模式和编码打开文件，返回文件读写对象</td></tr></tbody></table><h3 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">compile()</td><td align="center">将字符串编译为代码或者AST对象，使之能够通过exec语句来执行或者eval进行求值</td></tr><tr><td align="center">eval()</td><td align="center">执行动态表达式求值</td></tr><tr><td align="center">exec()</td><td align="center">执行动态语句块</td></tr><tr><td align="center">repr()</td><td align="center">返回一个对象的字符串表现形式(给解释器)</td></tr><tr><td align="center">breakpoint()</td><td align="center">调用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.breakpointhook"><code>sys.breakpointhook()</code></a> ，直接传递 <code>args</code> 和 <code>kws</code>，在调用时直接进入调试器中</td></tr></tbody></table><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能简介</th></tr></thead><tbody><tr><td align="center">property()</td><td align="center">标示属性的装饰器</td></tr><tr><td align="center">classmethod()</td><td align="center">标示方法为类方法的装饰器</td></tr><tr><td align="center">staticmethod()</td><td align="center">标示方法为静态方法的装饰器</td></tr></tbody></table><h2 id="按使用频度分类"><a href="#按使用频度分类" class="headerlink" title="按使用频度分类"></a>按使用频度分类</h2><blockquote><p>Python 有几十个内置函数和类，数百个工具捆绑在Python的标准库中，以及PyPI上的数千个第三方库。任何人都不可能记住所有这些东西。</p></blockquote><p>但其实不止是对Python的学习，对所有要掌握的技能而言， 建议对你的知识进行分类：</p><p>1.我应该记住的东西，这样我就能很好地理解它们；<br>2.我应该知道的东西，这样我以后才能更有效地查找它们；<br>3.我根本不应该为之烦恼的东西，除非有一天我需要它们 。 </p><p>（道理都懂，但知易行难，新手小白，如果没高手带着飞，哪里会提前知道呢，该踩的坑，一个也不能少，修行在个人，多学习，多总结就好，总会慢慢变强的。）</p><blockquote><p><strong>估计大多数Python开发人员只需要大约30个内置函数，但是哪30个取决于你实际使用Python做什么。</strong></p></blockquote><p>依据上述方法论，以鸟瞰的方式来看看Python中的所有的69个内置函数。</p><p>可以把这些内置组件分成五类:</p><ol><li>众所周知: 大多数python初学者会因为需要而很快地接触到这些内置组件</li><li>初学者所忽略的: 了解这些函数很有用，但是当你是Python新手时，就会很容易忽略它们</li><li>稍后再学习的: 了解这些内置组件通常很有用，但是当/如果你需要它们时，你就会找到它们</li><li>也许最终会学的: 这些东西迟早会派上用场，但只是在特定的情况下</li><li>你可能不需要这些: 除非你在做一些相当专业的事情，否则你不太可能会需要这些</li></ol><p>类别1和类别2中的内置函数几乎是所有Python程序员最终都应该学习的基本内置函数。</p><p>类别3和类别4中的内置函数是专门的内置函数，它们通常非常有用，但是你对它们的需求会根据你对Python的使用情况而有所不同。</p><p>类别5是神秘的内置函数，当你需要它们时，这可能非常方便，但是许多Python程序员可能永远都不需要它们。</p><p>如此分类下来，则可以看到</p><h3 id="10-Commonly-known-built-in-functions"><a href="#10-Commonly-known-built-in-functions" class="headerlink" title="10 Commonly known built-in functions"></a>10 Commonly known built-in functions</h3><ul><li><p>print</p></li><li><p>len</p></li><li><p>str</p></li><li><p>int</p></li><li><p>float</p></li><li><p>list</p></li><li><p>tuple</p></li><li><p>dict</p></li><li><p>set</p></li><li><p>range</p></li></ul><h3 id="Built-ins-overlooked-by-new-Pythonistas"><a href="#Built-ins-overlooked-by-new-Pythonistas" class="headerlink" title="Built-ins overlooked by new Pythonistas"></a>Built-ins overlooked by new Pythonistas</h3><ul><li>bool</li><li>enumerate</li><li>zip</li><li>reversed</li><li>sum</li><li>min and max</li><li>sorted</li><li>any and all</li></ul><h4 id="The-5-debugging-functions"><a href="#The-5-debugging-functions" class="headerlink" title="The 5 debugging functions"></a>The 5 debugging functions</h4><ul><li>breakpoint</li><li>dir</li><li>vars</li><li>type</li><li>help</li></ul><h3 id="Learn-it-later"><a href="#Learn-it-later" class="headerlink" title="Learn it later"></a>Learn it later</h3><ul><li><strong>open</strong></li><li><strong>input</strong></li><li>repr</li><li>super</li><li>property</li><li>issubclass  and  isinstance</li><li>hasattr, getattr, setattr, delattr </li><li>classmethod, staticmethod</li><li>next</li></ul><h3 id="Maybe-learn-it-eventually"><a href="#Maybe-learn-it-eventually" class="headerlink" title="Maybe learn it eventually"></a>Maybe learn it eventually</h3><ul><li>iter</li><li>callable</li><li><strong>filter</strong> and <strong>map</strong></li><li><strong>id</strong>, locals, globals</li><li>round</li><li>divmod</li><li>bin, oct, hex</li><li>abs</li><li>hash</li><li>object</li></ul><h3 id="You-likely-don’t-need-these"><a href="#You-likely-don’t-need-these" class="headerlink" title="You likely don’t need these"></a>You likely don’t need these</h3><ul><li>ord  and chr</li><li>exec  and eval</li><li>compile</li><li>bytes  and  bytearray  and memoryview</li><li>ascii</li><li>frozenset</li><li>__import __</li><li><strong>format</strong></li><li>pow</li><li>complex</li></ul><p>注：巧了，上述前两类10+10+5 = 25个，再加我根据经验，在后面几类加粗的6个函数，共31个，大佬就是大佬，毕竟过来人，果然应付一般的Python开发，30个左右即可。</p><h2 id="源码阅读的问题"><a href="#源码阅读的问题" class="headerlink" title="源码阅读的问题"></a>源码阅读的问题</h2><blockquote><p>Q:  有的python内置函数，在PyCharm 这个IDE中，用ctrl+b 查看源码时，为什么函数内容就是一个pass？</p></blockquote><blockquote><p>A：你<strong>看到的只是</strong>用来生成文档和给静态分析工具看的<strong>假代码</strong>，这些函数的<strong>真正实现在解释器里</strong>，一般看不到源代码。</p></blockquote><p>Python的解释器有c、 java、 python等多种实现，官方提供的默认实现是CPython，因此，作为解释器标准实现的一部分，那些内置函数也是用c语言实现的，也就是说，正常情况下你是连pass也看不到的。PyCharm这个IDE，维护着一个对当前解释器中所有函数，类型等东西的索引，这样就可以进行定义跳转一类的操作。但是对内置函数来说，找不到对应的实现，只有文档 pydoc 可用。PyCharm就根据文档自动地生成这些函数的签名，也就是内容为pass 占位符的函数。而这些函数的具体实现需要到<a href="https://github.com/python/cpython"><strong>python的源代码(官方的github仓库)</strong></a>中去找，也可以参考官方文档 <a href="https://docs.python.org/3.8/extending/index.html"><strong>Extending and Embedding the Python Interpreter</strong></a>，看看 c 写的东西是怎么被python使用的。</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/functions.html"><strong>Python 标准库-69个内置函数</strong></a></p><p><a href="https://treyhunner.com/2019/05/python-builtins-worth-learning/"><strong>Python built-ins worth learning</strong></a></p><p><a href="https://www.cnblogs.com/sesshoumaru/p/6140987.html"><strong>Python内置函数详解——总结篇</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内置函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 自省与反射</title>
      <link href="/2020/04/29/python/fundation/introspection-reflection/"/>
      <url>/2020/04/29/python/fundation/introspection-reflection/</url>
      
        <content type="html"><![CDATA[<h2 id="自省"><a href="#自省" class="headerlink" title="自省"></a><strong>自省</strong></h2><p>In computing, <strong>type introspection</strong> is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.<br>在计算机科学中，内省是指计算机程序在运行时（Run time）检查对象（Object）类型（以及属性等）的一种能力，通常也可以称作运行时类型检查。</p><table><thead><tr><th align="center">方法</th><th align="center">作用</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">help()</td><td align="center">查看函数或者模块用途的详细说明</td><td align="center">自省</td></tr><tr><td align="center"><strong>dir()</strong></td><td align="center"><strong>返回对象所有属性</strong></td><td align="center">自省</td></tr><tr><td align="center"><strong>type()</strong></td><td align="center"><strong>查看对象类型</strong></td><td align="center">自省</td></tr><tr><td align="center"><strong>isinstance()</strong></td><td align="center"><strong>判断一个对象是否是一个已知的类型</strong></td><td align="center">自省</td></tr><tr><td align="center">issubclass()</td><td align="center">判断一个类是不是另一个类的子类</td><td align="center">自省</td></tr><tr><td align="center">id()</td><td align="center">返回地址值</td><td align="center">自省</td></tr><tr><td align="center">callable()</td><td align="center">判断对象是否可调用</td><td align="center">自省</td></tr></tbody></table><span id="more"></span><h2 id="自省的常见使用方式"><a href="#自省的常见使用方式" class="headerlink" title="自省的常见使用方式"></a>自省的常见使用方式</h2><h3 id="help"><a href="#help" class="headerlink" title="help()"></a>help()</h3><p>help() 函数用于查看函数或模块用途的<strong>详细说明</strong>。<strong>主要在IDE环境下使用</strong>，接受任何拥有函数或者方法的对象，打印出对象所有的函数和文档字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Python <span class="number">3.6</span><span class="string">&#x27;s help utility!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If this is your first time using Python, you should definitely check out</span></span><br><span class="line"><span class="string">the tutorial on the Internet at https://docs.python.org/3.6/tutorial/.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter the name of any module, keyword, or topic to get help on writing</span></span><br><span class="line"><span class="string">Python programs and using Python modules.  To quit this help utility and</span></span><br><span class="line"><span class="string">return to the interpreter, just type &quot;quit&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To get a list of available modules, keywords, symbols, or topics, type</span></span><br><span class="line"><span class="string">&quot;modules&quot;, &quot;keywords&quot;, &quot;symbols&quot;, or &quot;topics&quot;.  Each module also comes</span></span><br><span class="line"><span class="string">with a one-line summary of what it does; to list the modules whose name</span></span><br><span class="line"><span class="string">or summary contain a given string such as &quot;spam&quot;, type &quot;modules spam&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">help&gt; </span></span><br><span class="line"><span class="string"># 可以继续输入 keywords、modules 等了解</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>对于自定义的类、函数、或者模块等，也可以打印帮助信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    this is a Demo</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    classVar = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.var1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.var1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">help</span>(Demo)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p><strong>dir()</strong> 函数可能是 Python 自省机制中最著名的部分了。它返回传递给它的任何对象的属性名称经过排序的列表。如果不指定对象，则<strong>dir()</strong> 返回当前作用域中的名称。</p><blockquote><p><strong>dir() 函数适用于所有对象类型，包括字符串、整数、列表、元组、字典、函数、定制类、类实例和类方法。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前作用域中的属性名称</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())</span><br><span class="line">-------------------</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 __builtins__ 模块的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(__builtins__))</span><br><span class="line">——————————————————————</span><br><span class="line">[<span class="string">&#x27;ArithmeticError&#x27;</span>, <span class="string">&#x27;AssertionError&#x27;</span>, <span class="string">&#x27;AttributeError&#x27;</span>, <span class="string">&#x27;BaseException&#x27;</span>, <span class="string">&#x27;BlockingIOError&#x27;</span>, <span class="string">&#x27;BrokenPipeError&#x27;</span>, <span class="string">&#x27;BufferError&#x27;</span>, <span class="string">&#x27;BytesWarning&#x27;</span>, <span class="string">&#x27;ChildProcessError&#x27;</span>, <span class="string">&#x27;ConnectionAbortedError&#x27;</span>, <span class="string">&#x27;ConnectionError&#x27;</span>, <span class="string">&#x27;ConnectionRefusedError&#x27;</span>, <span class="string">&#x27;ConnectionResetError&#x27;</span>, <span class="string">&#x27;DeprecationWarning&#x27;</span>, <span class="string">&#x27;EOFError&#x27;</span>, <span class="string">&#x27;Ellipsis&#x27;</span>, <span class="string">&#x27;EnvironmentError&#x27;</span>, <span class="string">&#x27;Exception&#x27;</span>, <span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;FileExistsError&#x27;</span>, <span class="string">&#x27;FileNotFoundError&#x27;</span>, <span class="string">&#x27;FloatingPointError&#x27;</span>, <span class="string">&#x27;FutureWarning&#x27;</span>, <span class="string">&#x27;GeneratorExit&#x27;</span>, <span class="string">&#x27;IOError&#x27;</span>, <span class="string">&#x27;ImportError&#x27;</span>, <span class="string">&#x27;ImportWarning&#x27;</span>, <span class="string">&#x27;IndentationError&#x27;</span>, <span class="string">&#x27;IndexError&#x27;</span>, <span class="string">&#x27;InterruptedError&#x27;</span>, <span class="string">&#x27;IsADirectoryError&#x27;</span>, <span class="string">&#x27;KeyError&#x27;</span>, <span class="string">&#x27;KeyboardInterrupt&#x27;</span>, <span class="string">&#x27;LookupError&#x27;</span>, <span class="string">&#x27;MemoryError&#x27;</span>, <span class="string">&#x27;ModuleNotFoundError&#x27;</span>, <span class="string">&#x27;NameError&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;NotADirectoryError&#x27;</span>, <span class="string">&#x27;NotImplemented&#x27;</span>, <span class="string">&#x27;NotImplementedError&#x27;</span>, <span class="string">&#x27;OSError&#x27;</span>, <span class="string">&#x27;OverflowError&#x27;</span>, <span class="string">&#x27;PendingDeprecationWarning&#x27;</span>, <span class="string">&#x27;PermissionError&#x27;</span>, <span class="string">&#x27;ProcessLookupError&#x27;</span>, <span class="string">&#x27;RecursionError&#x27;</span>, <span class="string">&#x27;ReferenceError&#x27;</span>, <span class="string">&#x27;ResourceWarning&#x27;</span>, <span class="string">&#x27;RuntimeError&#x27;</span>, <span class="string">&#x27;RuntimeWarning&#x27;</span>, <span class="string">&#x27;StopAsyncIteration&#x27;</span>, <span class="string">&#x27;StopIteration&#x27;</span>, <span class="string">&#x27;SyntaxError&#x27;</span>, <span class="string">&#x27;SyntaxWarning&#x27;</span>, <span class="string">&#x27;SystemError&#x27;</span>, <span class="string">&#x27;SystemExit&#x27;</span>, <span class="string">&#x27;TabError&#x27;</span>, <span class="string">&#x27;TimeoutError&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;TypeError&#x27;</span>, <span class="string">&#x27;UnboundLocalError&#x27;</span>, <span class="string">&#x27;UnicodeDecodeError&#x27;</span>, <span class="string">&#x27;UnicodeEncodeError&#x27;</span>, <span class="string">&#x27;UnicodeError&#x27;</span>, <span class="string">&#x27;UnicodeTranslateError&#x27;</span>, <span class="string">&#x27;UnicodeWarning&#x27;</span>, <span class="string">&#x27;UserWarning&#x27;</span>, <span class="string">&#x27;ValueError&#x27;</span>, <span class="string">&#x27;Warning&#x27;</span>, <span class="string">&#x27;WindowsError&#x27;</span>, <span class="string">&#x27;ZeroDivisionError&#x27;</span>, <span class="string">&#x27;__build_class__&#x27;</span>, <span class="string">&#x27;__debug__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;any&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;bin&#x27;</span>, <span class="string">&#x27;bool&#x27;</span>, <span class="string">&#x27;bytearray&#x27;</span>, <span class="string">&#x27;bytes&#x27;</span>, <span class="string">&#x27;callable&#x27;</span>, <span class="string">&#x27;chr&#x27;</span>, <span class="string">&#x27;classmethod&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;complex&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span>, <span class="string">&#x27;delattr&#x27;</span>, <span class="string">&#x27;dict&#x27;</span>, <span class="string">&#x27;dir&#x27;</span>, <span class="string">&#x27;divmod&#x27;</span>, <span class="string">&#x27;enumerate&#x27;</span>, <span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;filter&#x27;</span>, <span class="string">&#x27;float&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;frozenset&#x27;</span>, <span class="string">&#x27;getattr&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>, <span class="string">&#x27;hasattr&#x27;</span>, <span class="string">&#x27;hash&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;isinstance&#x27;</span>, <span class="string">&#x27;issubclass&#x27;</span>, <span class="string">&#x27;iter&#x27;</span>, <span class="string">&#x27;len&#x27;</span>, <span class="string">&#x27;license&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;locals&#x27;</span>, <span class="string">&#x27;map&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;memoryview&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;oct&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;ord&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;print&#x27;</span>, <span class="string">&#x27;property&#x27;</span>, <span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;range&#x27;</span>, <span class="string">&#x27;repr&#x27;</span>, <span class="string">&#x27;reversed&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;setattr&#x27;</span>, <span class="string">&#x27;slice&#x27;</span>, <span class="string">&#x27;sorted&#x27;</span>, <span class="string">&#x27;staticmethod&#x27;</span>, <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;super&#x27;</span>, <span class="string">&#x27;tuple&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;vars&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看其他类型的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="string">&#x27;just a string&#x27;</span>)) <span class="comment"># string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="number">42</span>))   <span class="comment"># Integer </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>([]))   <span class="comment"># List </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(()))   <span class="comment"># Tuple </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(&#123;&#125;))   <span class="comment"># Dictionary </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">dir</span>))  <span class="comment"># Function (functions are also objects)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="将-dir-运用于定制类、类实例和属性，下例可以说明-Python-自省能力的动态本质"><a href="#将-dir-运用于定制类、类实例和属性，下例可以说明-Python-自省能力的动态本质" class="headerlink" title="将 dir() 运用于定制类、类实例和属性，下例可以说明 Python 自省能力的动态本质"></a>将 dir() 运用于定制类、类实例和属性，下例可以说明 Python 自省能力的动态本质</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Person class.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intro</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return an introduction.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, my name is %s and I&#x27;m %s.&quot;</span> % (self.name, self.age)</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&quot;Robert&quot;</span>, <span class="number">35</span>)  <span class="comment"># Create a Person instance</span></span><br><span class="line">joe = Person(<span class="string">&quot;Joseph&quot;</span>, <span class="number">17</span>)  <span class="comment"># Create another Person instance</span></span><br><span class="line"></span><br><span class="line">joe.sport = <span class="string">&quot;football&quot;</span>   <span class="comment"># Assign a new attribute to one instance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(Person))  <span class="comment"># Attributes of the Person class</span></span><br><span class="line">----------</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;intro&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(bob))</span><br><span class="line">----------</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;intro&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(joe))  <span class="comment"># Note that joe has an additional attribute 注意 joe 多了一个&#x27;sport&#x27; 属性</span></span><br><span class="line">----------</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;intro&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sport&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bob.intro())</span><br><span class="line">----------</span><br><span class="line">Hello, my name <span class="keyword">is</span> Robert <span class="keyword">and</span> I<span class="string">&#x27;m 35.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(dir(bob.intro))</span></span><br><span class="line"><span class="string">----------</span></span><br><span class="line"><span class="string">[&#x27;</span>__call__<span class="string">&#x27;, &#x27;</span>__class__<span class="string">&#x27;, &#x27;</span>__delattr__<span class="string">&#x27;, &#x27;</span>__dir__<span class="string">&#x27;, &#x27;</span>__doc__<span class="string">&#x27;, &#x27;</span>__eq__<span class="string">&#x27;, &#x27;</span>__format__<span class="string">&#x27;, &#x27;</span>__func__<span class="string">&#x27;, &#x27;</span>__ge__<span class="string">&#x27;, &#x27;</span>__get__<span class="string">&#x27;, &#x27;</span>__getattribute__<span class="string">&#x27;, &#x27;</span>__gt__<span class="string">&#x27;, &#x27;</span>__hash__<span class="string">&#x27;, &#x27;</span>__init__<span class="string">&#x27;, &#x27;</span>__init_subclass__<span class="string">&#x27;, &#x27;</span>__le__<span class="string">&#x27;, &#x27;</span>__lt__<span class="string">&#x27;, &#x27;</span>__ne__<span class="string">&#x27;, &#x27;</span>__new__<span class="string">&#x27;, &#x27;</span>__reduce__<span class="string">&#x27;, &#x27;</span>__reduce_ex__<span class="string">&#x27;, &#x27;</span>__repr__<span class="string">&#x27;, &#x27;</span>__self__<span class="string">&#x27;, &#x27;</span>__setattr__<span class="string">&#x27;, &#x27;</span>__sizeof__<span class="string">&#x27;, &#x27;</span>__str__<span class="string">&#x27;, &#x27;</span>__subclasshook__<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="注意-dir-vs-help"><a href="#注意-dir-vs-help" class="headerlink" title="注意 dir() vs help()"></a>注意 dir() vs help()</h4><ul><li>dir() : 只是得到方法或者属性的名称</li><li>help() : 不但可以得到对象的方法和属性名称, 同时也可以得到这些方法或者属性的使用方式的描述</li></ul><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>type() 函数属于 Python 内置函数，<strong>通常用来查看某个变量的具体类型</strong>。其实，type() 函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。</p><p>type() 函数的语法格式有 2 种，分别如下：</p><ul><li>*<em>type(obj) *</em></li></ul><p>用来查看某个变量（类对象）的具体类型，obj 表示某个变量或者类对象。</p><ul><li><strong>type(name, bases, dict)</strong></li></ul><p>用来创建类，其中 name 表示类的名称；bases 表示一个父类的元组；dict 表示一个字典，即类内定义的属性方法和值组成的键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instancetest</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is a instance method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classtest</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is a class method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statictest</span>():</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is a static method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类</span></span><br><span class="line">test_property = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;instancetest&quot;</span>: instancetest, <span class="string">&quot;classtest&quot;</span>: classtest, <span class="string">&quot;statictest&quot;</span>: statictest&#125;</span><br><span class="line">Test = <span class="built_in">type</span>(<span class="string">&quot;Test&quot;</span>, (), test_property)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">test = Test()</span><br><span class="line"><span class="comment"># 调用方法</span></span><br><span class="line"><span class="built_in">print</span>(test.name)</span><br><span class="line">test.instancetest()</span><br><span class="line">test.classtest()</span><br><span class="line">test.statictest()</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">tom</span><br><span class="line">this <span class="keyword">is</span> a instance method</span><br><span class="line">this <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"><span class="title">this</span> <span class="title">is</span> <span class="title">a</span> <span class="title">static</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure><h4 id="注意：type-vs-object"><a href="#注意：type-vs-object" class="headerlink" title="注意：type vs object"></a>注意：type vs object</h4><p>type为对象的顶点，所有对象都创建自type。</p><p>object为类继承的顶点，所有类都继承自object。</p><p>python中万物皆对象，一个python对象可能拥有两个属性，<code>__class__</code> 和 <code>__base__</code>，<code>__class__</code> 表示这个对象是谁创建的，<code>__base__</code> 表示一个类的父类是谁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span>.__class__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>.__base__)</span><br><span class="line">---------------</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">type</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><ul><li>type类继承自object</li><li>object的对象创建自type</li></ul><h3 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isinstance</span>(<span class="params">x, A_tuple</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return whether an object is an instance of a class or of a subclass thereof.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    A tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to</span></span><br><span class="line"><span class="string">    check against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)</span></span><br><span class="line"><span class="string">    or ...`` etc.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass()"></a>issubclass()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issubclass</span>(<span class="params">x, A_tuple</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return whether &#x27;cls&#x27; is a derived from another class or is the same class.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    A tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to</span></span><br><span class="line"><span class="string">    check against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)</span></span><br><span class="line"><span class="string">    or ...`` etc.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span>  <span class="comment"># B类 继承 A类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">b = B() <span class="comment"># b 是 B类的一个实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># is是去判断这两个是不是一个对象, 即id是否相同</span></span><br><span class="line"><span class="comment"># ==是判断值是否相等  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># 求一个未知数据类型的对象</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(<span class="built_in">type</span>(b)))</span><br><span class="line"><span class="comment"># 2290407692200</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(B))</span><br><span class="line"><span class="comment"># 2290407692200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, B)) </span><br><span class="line"><span class="comment">#True </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, A)) <span class="comment"># isinstance会根据继承链去判断</span></span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b) <span class="keyword">is</span> B)  <span class="comment"># 得到的是B的地址</span></span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b) <span class="keyword">is</span> A)</span><br><span class="line"><span class="comment">#False </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">int</span>, <span class="built_in">type</span>))  <span class="comment"># int 是type的子类</span></span><br><span class="line"><span class="comment">#True </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(A, <span class="built_in">type</span>))  <span class="comment"># 类A是type的子类</span></span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="literal">True</span>, <span class="built_in">int</span>))  <span class="comment"># 布尔是int的子类</span></span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, <span class="built_in">type</span>))</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(B, A)) <span class="comment"># 类B 是 类A的子类 ，注意必须都传入类名</span></span><br><span class="line"><span class="comment">#True</span></span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><h4 id="is-vs"><a href="#is-vs" class="headerlink" title="is vs =="></a>is vs ==</h4><ul><li><p>is 是去判断这两个是不是一个对象, 即 id 是否相同</p></li><li><p>== 是判断值是否相等</p></li><li><p><strong>(ob1 is ob2) 等价于 (id(ob1) == id(ob2))</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">c=a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)) <span class="comment"># 2866545727304</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b)) <span class="comment"># 2866545726984</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c)) <span class="comment"># 2866545727304</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(c <span class="keyword">is</span> a) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>((a==b)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h4 id="type-vs-isinstance"><a href="#type-vs-isinstance" class="headerlink" title="type() vs isinstance()"></a>type() vs isinstance()</h4><ul><li><p><strong>type() 用于求一个未知数据类型的对象</strong>，<strong>isinstance() 用于判断一个对象是否是已知类型</strong>；</p></li><li><p>type() 不认为子类是父类的一种类型，isinstance() 认为子类是父类的一种类型，即子类对象也属于父类类型</p></li></ul><h3 id="id"><a href="#id" class="headerlink" title="id()"></a>id()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id</span>(<span class="params">*args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return the identity of an object.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    This is guaranteed to be unique among simultaneously existing objects.</span></span><br><span class="line"><span class="string">    (CPython uses the object&#x27;s memory address.)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>id()</strong> 函数返回对象的唯一标识符，标识符是一个整数。</p></li><li><p>CPython 中 <strong>id()</strong> 函数用于获取对象的内存地址。</p></li></ul><h3 id="callable"><a href="#callable" class="headerlink" title="callable()"></a>callable()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callable</span>(<span class="params">i_e_, some_kind_of_function</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return whether the object is callable (i.e., some kind of function).</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Note that classes are callable, as are instances of classes with a</span></span><br><span class="line"><span class="string">    __call__() method.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>该方法用来检测对象是否可被调用，可被调用——指的是对象能否使用()括号的方法调用。</li><li>可调用对象，在实际调用也可能调用失败；但是不可调用对象，调用肯定不成功。</li><li>类对象都是可被调用对象，类的实例对象是否可调用对象，取决于类是否定义了<code>__call__</code>方法。</li><li>也就是说，对于函数、方法、lambda 函式、 类以及实现了 <code>__call__</code>方法的类实例, 它都返回 True。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">callable</span>(A))  <span class="comment">#类A是可调用对象</span></span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">callable</span>(a))  <span class="comment">#实例a不可调用</span></span><br><span class="line"><span class="comment">#False</span></span><br><span class="line">a()  <span class="comment">#调用实例a 会失败</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;D:/BYA_Project/XTC_Develops/Python_json.py&quot;, line 97, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     a()</span></span><br><span class="line"><span class="comment"># TypeError: &#x27;A&#x27; object is not callable</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;instance are callable now.&quot;</span>)</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">callable</span>(B))  <span class="comment">#类B是可调用对象</span></span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">callable</span>(b))   <span class="comment">#实例b是可调用对象</span></span><br><span class="line"><span class="comment">#True</span></span><br><span class="line">b()   <span class="comment">#调用实例b成功</span></span><br><span class="line"><span class="comment">#instance are callable now.</span></span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Introspection should not be confused with <strong>reflection</strong>, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.<br>也就是说自省和反射不是同一回事，自省是获取对象类型的能力，而反射是操纵对象的值，元数据，属性和/或函数的能力。</p><p>在计算机学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，<strong>反射就是程序在运行的时候能够“观察”并且修改自己的行为</strong>。</p><p>在Python中反射非常简单，用起来几乎感觉不到与其他的代码有区别，使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例；不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已。</p><table><thead><tr><th align="center">方法</th><th align="center">作用</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">hasattr()</td><td align="center">判断类方法或者类属性是否存在，返回一个布尔值，存在返回True，反之返回Flase</td><td align="center">反射</td></tr><tr><td align="center">getattr()</td><td align="center">获取属性值或实例方法，如果其不存在，会抛出一个<code>AttributeError</code>异常</td><td align="center">反射</td></tr><tr><td align="center">setattr()</td><td align="center">设置实例属性的值，如果实例属性不存在时，会自动给当前实例添加该属性</td><td align="center">反射</td></tr><tr><td align="center">delattr()</td><td align="center">删除实例的属性或者实例的方法，当其不存在时同样会抛出一个<code>AttributeError</code>异常</td><td align="center">反射</td></tr></tbody></table><h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">object</span></span>):</span>  <span class="comment"># 类Cat 指向类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="string">&quot;kitty&quot;</span></span>):</span></span><br><span class="line">        self.name = name  <span class="comment"># 类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span>(<span class="params">self</span>):</span>  <span class="comment"># 类方法</span></span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;say Hi~~&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cat = Cat(<span class="string">&#x27;KITTY&#x27;</span>)  <span class="comment"># 类的实例对象</span></span><br><span class="line">    <span class="built_in">print</span>(cat.name)  <span class="comment"># 访问对象属性</span></span><br><span class="line">    cat.sayHi() <span class="comment"># 访问对象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(cat, <span class="string">&quot;name&quot;</span>):  <span class="comment"># 判断</span></span><br><span class="line">        <span class="built_in">setattr</span>(cat, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;tiger&quot;</span>)  <span class="comment"># 设置</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">getattr</span>(cat, <span class="string">&quot;name&quot;</span>))  <span class="comment"># 获取</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">delattr</span>(cat, <span class="string">&quot;name&quot;</span>)  <span class="comment"># 删除</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hasattr</span>(cat, <span class="string">&quot;name&quot;</span>))  <span class="comment"># 判断</span></span><br><span class="line">    </span><br><span class="line">-------------------</span><br><span class="line">KITTY</span><br><span class="line">KITTY say Hi~~</span><br><span class="line">tiger</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>反射主要根据字符串去寻找类的属性值，主要用于用户交互，触发类内函数运行，根据字符串动态的判断,调用,添加/修改,删除类或类的实例化对象中的方法或属性。</p><p>反射在 web 框架中用的很多，通过解析url，执行对应不同的功能。</p><p>反射还可以用于<strong>动态导入模块</strong> ，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">model = <span class="string">&quot;requests&quot;</span></span><br><span class="line">function = <span class="string">&quot;get&quot;</span></span><br><span class="line"></span><br><span class="line">obj = <span class="built_in">__import__</span>(model)</span><br><span class="line">request_get = <span class="built_in">getattr</span>(obj, function)</span><br><span class="line"></span><br><span class="line">response = request_get(<span class="string">&quot;http://example.com&quot;</span>).text</span><br><span class="line"><span class="built_in">print</span>(response)</span><br><span class="line"></span><br><span class="line">----------------------</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: <span class="comment">#f0f0f2;</span></span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        padding: <span class="number">0</span>;</span><br><span class="line">        font-family: -apple-system, system-ui, BlinkMacSystemFont, <span class="string">&quot;Segoe UI&quot;</span>, <span class="string">&quot;Open Sans&quot;</span>, <span class="string">&quot;Helvetica Neue&quot;</span>, Helvetica, Arial, sans-serif;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 600px;</span><br><span class="line">        margin: 5em auto;</span><br><span class="line">        padding: 2em;</span><br><span class="line">        background-color: <span class="comment">#fdfdff;</span></span><br><span class="line">        border-radius: <span class="number">0.5</span>em;</span><br><span class="line">        box-shadow: 2px 3px 7px 2px rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.02</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a:link, a:visited &#123;</span><br><span class="line">        color: <span class="comment">#38488f;</span></span><br><span class="line">        text-decoration: none;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">    @media (<span class="params"><span class="built_in">max</span>-width: 700px</span>) &#123;</span></span><br><span class="line">        div &#123;</span><br><span class="line">            margin: <span class="number">0</span> auto;</span><br><span class="line">            width: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;    </span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Example Domain&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;This domain <span class="keyword">is</span> <span class="keyword">for</span> use <span class="keyword">in</span> illustrative examples <span class="keyword">in</span> documents. You may use this</span><br><span class="line">    domain <span class="keyword">in</span> literature without prior coordination <span class="keyword">or</span> asking <span class="keyword">for</span> permission.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;a href=<span class="string">&quot;https://www.iana.org/domains/example&quot;</span>&gt;More information...&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-pyint/index.html"><strong>IBM Developer Python 自省指南</strong></a></p><p><a href="https://www.cnblogs.com/huxi/archive/2011/01/02/1924317.html"><strong>CSDN Python自省（反射）指南</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自省 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 命名空间、作用域及LEGB规则</title>
      <link href="/2020/04/28/python/intermediate/scope-namespace-LEGB/"/>
      <url>/2020/04/28/python/intermediate/scope-namespace-LEGB/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>Python使用叫做命名空间的东西来记录变量的轨迹。</p><p>命名空间是一个字典（dictionary），它的键就是变量名，它的值就是那些变量的值，即 {name:object}映射。</p><p>A <em>namespace</em> is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries。</p><span id="more"></span><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Python 中 name-object 的映射存储在不同的作用域中，各个不同的作用域是相互独立的。而我们就在不同的作用域中搜索 name-object。</p><p>Python是静态作用域，也就是说，<strong>在Python中，变量的作用域源于它在代码中的位置；在不同的位置，可能有不同的命名空间。命名空间是变量作用域的体现形式。</strong>如：函数定义了本地作用域，而模块定义的是全局作用域。如果想要在函数内定义全局作用域，需要加上global修饰符。</p><h3 id="命名空间的访问：globals-和-locals"><a href="#命名空间的访问：globals-和-locals" class="headerlink" title="命名空间的访问：globals() 和 locals()"></a>命名空间的访问：globals() 和 locals()</h3><p>Python的命名空间是一个字典，字典内保存了变量名称与对象之间的映射关系。因此，查找变量名就是在命名空间字典中<strong>查找键-值对</strong>，想要<strong>打印出全局变量与局部变量的字典映射</strong>，我们可以使<strong>用函数globals()和locals()</strong>。</p><h3 id="命名空间的查找顺序：LEGB-规则"><a href="#命名空间的查找顺序：LEGB-规则" class="headerlink" title="命名空间的查找顺序：LEGB 规则"></a>命名空间的查找顺序：LEGB 规则</h3><p>Python有多个命名空间，因此需要有规则来规定，LEGB就是用来规定命名空间查找顺序的规则<strong>，</strong>顺序为：<strong>local–&gt;enclosing function locals–&gt;global–&gt;builtin。</strong></p><p>补：<strong>上面的变量规则只适用于简单对象</strong>，当出现引用对象的属性时，则有另一套搜索规则:属性引用搜索一个或多个对象，而不是作用域，并且有可能涉及到所谓的”继承”。</p><h2 id="LEGB-规则解释"><a href="#LEGB-规则解释" class="headerlink" title="LEGB 规则解释"></a>LEGB 规则解释</h2><p><img src="/images/LEGB.png" alt="LEGB"></p><h3 id="L：Local-函数内的命名空间"><a href="#L：Local-函数内的命名空间" class="headerlink" title="L：Local    函数内的命名空间"></a>L：Local    函数内的命名空间</h3><p>作用范围：当前整个函数体范围。</p><p>生命周期：当函数被调用时创建一个局部命名空间，当函数返回结果 或 抛出异常时，被删除。每一个递归调用的函数都拥有自己的命名空间。</p><h3 id="E-Enclosing-function-locals-外部嵌套函数的命名空间"><a href="#E-Enclosing-function-locals-外部嵌套函数的命名空间" class="headerlink" title="E-Enclosing function locals    外部嵌套函数的命名空间"></a><strong>E-Enclosing function locals</strong>    外部嵌套函数的命名空间</h3><p>作用范围：闭包函数。</p><p>生命周期：</p><h3 id="G-Global-全局命名空间"><a href="#G-Global-全局命名空间" class="headerlink" title="G-Global   全局命名空间"></a><strong>G-Global</strong>   全局命名空间</h3><p>作用范围：当前模块(文件)。</p><p>生命周期：在模块定义被读入时创建，通常模块命名空间也会一直保存到解释器退出。</p><h3 id="B-Builtin-内建模块命名空间"><a href="#B-Builtin-内建模块命名空间" class="headerlink" title="B-_Builtin_    内建模块命名空间"></a><strong>B-_<em>Builtin_</em></strong>    内建模块命名空间</h3><p>作用范围：所有模块(文件)。</p><p>生命周期：Python 解释器启动时创建，会一直保留，不被删除。</p><p>Python 在启动的时候会自动为我们载入很多内建的函数、类，比如 dict，list，type，print，这些都位于 __<em>builtin_</em> 模块中，可以使用 dir(__<em>builtin_</em>) 来查看。这也是为什么我们在没有 import任何模块的情况下，就能使用这么多丰富的函数和功能了。</p><p>在Python中，有一个内建模块，该模块中有一些常用函数;在Python启动后，且没有执行程序员所写的任何代码前，Python会首先加载该内建函数到内存。另外，该内建模块中的功能可以直接使用，不用在其前添加内建模块前缀，其原因是对函数、变量、类等标识符的查找是按LEGB法则，其中B即代表内建模块。比如：内建模块中有一个abs()函数，其功能求绝对值，如abs(-20)将返回20。</p><h3 id="例题练习"><a href="#例题练习" class="headerlink" title="例题练习"></a>例题练习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span>():</span></span><br><span class="line">    j,k = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;j == %d and k == %d&quot;</span> % (j,k))</span><br><span class="line">    k = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span>():</span></span><br><span class="line">    j = <span class="number">6</span></span><br><span class="line">    proc1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;j == %d and k == %d&quot;</span> % (j,k))</span><br><span class="line"></span><br><span class="line">k = <span class="number">7</span></span><br><span class="line">proc1()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j == %d and k == %d&quot;</span> % (j, k))</span><br><span class="line"></span><br><span class="line">j = <span class="number">8</span></span><br><span class="line">proc2()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j == %d and k == %d&quot;</span> % (j, k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># j == 3 and k == 4</span></span><br><span class="line"><span class="comment"># name &#x27;j&#x27; is not defined #注释对应代码后出现以下三列结果</span></span><br><span class="line"><span class="comment"># j == 3 and k == 4</span></span><br><span class="line"><span class="comment"># j == 6 and k == 7</span></span><br><span class="line"><span class="comment"># j == 8 and k == 7</span></span><br></pre></td></tr></table></figure><h3 id="答案解释"><a href="#答案解释" class="headerlink" title="答案解释"></a>答案解释</h3><ul><li><p>proc1() 函数内部就有j,k，停止向上查找，故 j == 3 and k == 4</p></li><li><p>print(“j == %d and k == %d” % (j,k)) 程序从上往下执行，当前只定义 k=7,j 还未定义，因为已经是全局变量了，Builtin中未定义 j, 因此返回未定义的错误。</p></li><li><p>proc2()中会调用proc1()依旧先打印 j == 3 and k == 4<br>proc2()内部需要打印，j, k值，j本地已经定义为6，k未定义，则向上查找，查找到全局变另种定义了k=7,因此输出：j == 6 and k == 7</p></li><li><p>print (“j == %d and k == %d” % (j,k))  前面的程序已经给j,k进行了赋值，直接输出即可，j == 8 and k == 7</p></li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://www.cnblogs.com/GuoYaxiang/p/6405814.html"><strong>Python中的LEGB规则</strong></a></p><p><strong><a href="https://segmentfault.com/a/1190000000640834">理解 Python 的 LEGB</a></strong></p><p><a href="http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html"><strong>A Beginner’s Guide to Python’s Namespaces, Scope Resolution, and the LEGB Rule</strong></a></p><p><a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#python-scopes-and-namespaces"><strong>Python-tutorial-classes-python-scopes-and-namespaces</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Intermediate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LEGB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中的 global、nonlocal 辨析</title>
      <link href="/2020/04/28/python/fundation/global-nonlocal/"/>
      <url>/2020/04/28/python/fundation/global-nonlocal/</url>
      
        <content type="html"><![CDATA[<h2 id="global-语句"><a href="#global-语句" class="headerlink" title="global 语句"></a>global 语句</h2><ul><li><p>语法：声明此变量为全局变量</p></li><li><p>用法： global [变量名]</p></li><li><p>注意：引用全局变量时，不需要global 声明，但是后面使用或者修改这个全局变量的时候，需要global声明。</p></li><li><p><strong>应用场景</strong>：变量定义在函数<strong>外部</strong>的时候，如果函数里面想改变这个<strong>全局变量</strong>的值，需要在当前的引用函数里面<strong>重新定义</strong>一个<strong>变量</strong>， 并<strong>用关键字global修饰</strong>。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>  <span class="comment"># 外部全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>():</span></span><br><span class="line">        <span class="keyword">global</span> a <span class="comment"># 与外部全局变量同名</span></span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;函数内部的a的值：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(a))   <span class="comment"># 2</span></span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">change()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用change函数后， 函数外部的a的值：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(a))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="nonlocal-语句"><a href="#nonlocal-语句" class="headerlink" title="nonlocal 语句"></a>nonlocal 语句</h2><ul><li><p>语法：允许内嵌函数修改定义在语法上位于外层的函数的作用域中的一个或者多个名称</p></li><li><p>用法： nonlocal [变量名]</p></li><li><p>注意：<strong>此语句仅适用于python3</strong>，在python2中内嵌函数可以使用外层作用域中通过赋值的所有名称，但不能进行修改；python3则可以使用并且可以进行修改。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_fun</span>():</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo_fun_1</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"><span class="comment"># 在这段demo里面，变量num既不是全局变量，也不是局部变量，而是外部内嵌函数的变量。</span></span><br></pre></td></tr></table></figure><ul><li><p>应用场景：nolocal 的使用场景比较单一，它是<strong>使用在闭包中</strong>的，使变量使用<strong>外层</strong>（非全局）的同名变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">func</span>):</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;外层函数a的值&quot;</span>, a)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">                func()</span><br><span class="line">                <span class="keyword">nonlocal</span> a</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;经过改变后，外层函数a的值：&quot;</span>, a)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>():</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;nolocal的使用&quot;</span>)</span><br><span class="line"></span><br><span class="line">change()</span><br><span class="line">------------------------------------------------</span><br><span class="line">外层函数a的值 <span class="number">1</span></span><br><span class="line">nolocal的使用</span><br><span class="line">经过改变后，里外层函数a的值： <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="global-vs-nonlocal"><a href="#global-vs-nonlocal" class="headerlink" title="global vs nonlocal"></a>global vs nonlocal</h2><p>在Python中，global 和 nonlocal 的<strong>作用</strong>都是可以<strong>实现代码块内变量使用外部的同名变量</strong>，但其中是有很明显的区别的。</p><p>而在谈到nonlocal与global的区别之前，我们应该了解python中引用变量的顺序是什么样的。</p><p><strong>python变量引用顺序</strong>：从当前作用域开始寻找变量，如果没找到就往上一层作用域寻找，依此上推一层。</p><p>具体步骤：当前作用域局部变量-&gt;外层作用域变量-&gt;再外层作用域变量-&gt;…-&gt;当前模块全局变量-&gt;pyhton内置变量</p><h3 id="区别点"><a href="#区别点" class="headerlink" title="区别点"></a>区别点</h3><ul><li><strong>作用对象，作用域不同</strong></li></ul><p>global的作用对象是全局变量， 作用域是全局的，就是会修改这个变量对应地址的值；</p><p>nonlocal的作用对象是外部内嵌函数的变量（也就是闭包这种情况）。即是说，只在闭包里面生效，作用域就是闭包里面的，外函数和内函数都影响，但是闭包外面不影响。</p><ul><li><strong>操作权限不同</strong></li></ul><p>global可以改变全局变量，同时可以定义新的全局变量，</p><p>nonlocal只能改变外层函数变量，不能定义新的外层函数变量，并且nonlocal也不能改变全局变量。</p><ul><li><strong>声明不同</strong></li></ul><p>global声名变量后，标志此变量为全局变量；</p><p>nonlocal声名变量后，标志此变量为外层函数的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误。</p><ul><li><strong>使用范围不同</strong></li></ul><p>global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用；</p><p>nonlocal关键字只能用于嵌套函数中，并且外层函数中必须定义了相应的局部变量，否则会发生错误。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><p>本地的变量声明为global，就不能再声明为nonlocal</p></li><li><p>使用nonlocal之前，需要初始化变量</p></li><li><p>不能在函数的外部函数里声明nonlocal</p></li><li><p><strong>在 实际的编程中，应该尽量避开使用 global关键字，因为它引入了多余的变量到全局作用域了。</strong></p></li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://punchagan.muse-amuse.in/blog/python-globals/"><strong>Python’s globals</strong></a></p><p><a href="https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement"><strong>Python manual —— Simple statements</strong></a></p><p><a href="https://blog.csdn.net/weixin_42514606/article/details/104004237"><strong>Python Global和Nonlocal的用法</strong></a></p><p><a href="https://blog.csdn.net/JackLang/article/details/81294208?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2"><strong>全局变量: 浅析 python 中 global 作用和全局变量实现方式</strong></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> global </tag>
            
            <tag> nonlocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《强势》书摘</title>
      <link href="/2020/04/27/booknote/when-I-say-no-I-feel-guilty/"/>
      <url>/2020/04/27/booknote/when-I-say-no-I-feel-guilty/</url>
      
        <content type="html"><![CDATA[<div class="douban-card-block"><a class="douban-card" href="https://book.douban.com/subject/25925226"><div class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/subject/s/public/s27321995.jpg');"></div><div class="douban-card-left"><div class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/subject/s/public/s27321995.jpg');"></div></div><div class="douban-card-right" style="line-height: 1.7;"><div class="douban-card-item"><span>书名: </span><strong>强势</strong></div><div class="douban-card-item"><span>作者: </span><span>（美）曼纽尔•J•史密斯</span></div><div class="douban-card-item"><span>出版年份: </span><span>2014-8</span></div><div class="douban-card-item"><span>评分: </span><span>8.0</span></div></div></a></div><style>.douban-card-block {display: flex;justify-content: center;align-items: center;width: 100%;max-height: 400px;}.douban-card {display: flex;margin: 30px 10px;padding: 15px;border-radius: 10px;position: relative;justify-content: center;align-items: center;overflow: hidden;color: antiquewhite;text-decoration: none;}.douban-card:hover {text-decoration: none;}.douban-card-bgimg {position: absolute;width: 115%;height: 115%;filter: blur(15px) brightness(0.6);background-size: 100%;background-position: center;background-repeat: no-repeat;}.douban-card-img {position: relative;height: 130px;width: 80px;background-size: 100%;background-position: center;background-repeat: no-repeat;}.douban-card-img {position: relative;height: 130px;width: 80px;}.douban-card-left {position: relative;display: flex;flex-direction: column;align-items: center;}.douban-card-right {position: relative;display: flex;flex-direction: column;margin-left: 12px;font-size: 16px;font-family: 'Courier New', Courier, monospace;line-height: 1.3;color: antiquewhite;}.douban-card-item {margin-top: 4px;}</style><h2 id="《强势》摘录"><a href="#《强势》摘录" class="headerlink" title="《强势》摘录"></a>《强势》摘录</h2><h3 id="Part-1-：你为什么要强势？"><a href="#Part-1-：你为什么要强势？" class="headerlink" title="Part 1 ：你为什么要强势？"></a>Part 1 ：你为什么要强势？</h3><ul><li><h4 id="chapter-1：强势：面对矛盾与困扰时，最好的应对之道"><a href="#chapter-1：强势：面对矛盾与困扰时，最好的应对之道" class="headerlink" title="chapter 1：强势：面对矛盾与困扰时，最好的应对之道"></a>chapter 1：强势：面对矛盾与困扰时，最好的应对之道</h4></li></ul><p>无论你我做什么，别人都会给我们带来一个又一个的问题。我们中的许多人，都存在那种不切实际的观念，认为日复一日地与问题共存，是一种既不健康又不自然的生活方式。可事实并非如此。生活会给每个人都带来问题，这才是完全符合自然规律的。</p><blockquote><p><strong>我们在生活中都会碰到问题，这是正常的，我们都拥有充分应对这些问题的能力，这也是正常的。</strong></p></blockquote><p>祖先留下三种解决矛盾的能力：争斗、逃避、用语言解决问题，现代社会，比争斗与逃避更好的，是语言上的强势。</p><span id="more"></span><p>愤怒、恐惧和沮丧这三种情感，是人类最根本的、遗传得来的生存性情绪组合，也是导致病人寻求专业心理治疗的常见情绪指征。</p><p>消极情绪对于生存的意义，正如肌体的疼痛对于生存的意义一样重要。</p><p>沮丧时，你所感受到的，是大脑中的原始区域所发出的信息而产生的反应，这种反应的目的，是让维持日常活动所需的大部分生理机能缓慢下来。</p><p>我们大多数人，都只有在受到挫折、变得恼怒的时候，才会对他人用言语坚持自己的权利或意见。可怒气只会让你处理问题不那么有效。</p><p>一旦学会说话，能够理解他人所说的话语，你我和绝大多数人就会受到训练，来对他人带有操控性的情感控制做出回应。父母给我们拴上了心理上的木偶提线，从而掌控着我们幼稚的强势之心。这些木偶体现效果显著，让小时候的我们远离了种种现实或想象的危险，也使大人的生活变得轻松。</p><p>——2020/4/28 下午</p><ul><li><h4 id="chapter-2：他人对你的隐形操控无处不在，你必须强势"><a href="#chapter-2：他人对你的隐形操控无处不在，你必须强势" class="headerlink" title="chapter 2：他人对你的隐形操控无处不在，你必须强势"></a>chapter 2：他人对你的隐形操控无处不在，你必须强势</h4></li></ul><p><strong>只要你不允许，就没人能够操控你。</strong></p><blockquote><p>强势法则一：你有权坚持自己的行为、想法和情感，并对产生的一切后果负责。</p></blockquote><p>人与人的三种关系：</p><ol><li>商务式或正式关系</li><li>权威式关系</li><li>平等关系</li></ol><p>婚姻关系中，任何一方的个人不安全感越强，这一方试图强加于配偶或自身的结构就越武断，操控感就越强。</p><p>在与人交往的三种方式中，出现问题的共同原因时：你与同一个人之间，存在着一种以上的相互关系。在混合关系中，只有强势地我行我素，自主决断你想要什么，认真研究每一阶段你愿意接受地折中办法，以此应对别人地操控，你才能与一个朋友又做生意，又做朋友。</p><blockquote><p><strong>许多人往往会害怕成为自己的评判者。做自己的最终评判者，没有准则约束，就像是独自在陌生的异国旅游，没有导游来介绍应该看哪些景点一样。更令人担心的是，我们手头还没有指点迷津的地图。在人生路上为自己制定准则并不容易，但要是允许他人操控我们的情感，而让我们面临沮丧、敌意和逃避，肯定更糟。我们要依赖于自己的判断，因为事实——无论我们是否愿意面对这一事实——就是：只有我们，才对自己负有责任。</strong></p></blockquote><p>——2020/4/28 夜</p><ul><li><h4 id="chapter-3：我们在哪些方面必须强势？"><a href="#chapter-3：我们在哪些方面必须强势？" class="headerlink" title="chapter 3：我们在哪些方面必须强势？"></a>chapter 3：我们在哪些方面必须强势？</h4></li></ul><blockquote><p>强势法则二：坚持你要做的，不必解释</p></blockquote><p>只有你，才有权最终评判自己的为人和行为。假如你是自己的最终评判者，那么，你就无需向别人解释，无需让他们来评判你的行为是否恰当，是对是错，也无需他们进行其他什么评价。</p><p>只需指出事实就行：“没有原因，我就是不喜欢。”</p><p>选择朋友和选择其他东西一样，完全取决于你自己。</p><blockquote><p>强势法则三：帮不到别人，不用内疚。</p></blockquote><p>你可以按照别人的要求去做，暂时性地取悦他/她，但那个人自己必须经历所有地辛劳、汗水、苦痛，以及失败带来的恐惧，才能让自己地生活过得健康、幸福。</p><blockquote><p>强势法则四：你有权改变想法</p></blockquote><p>每个人都必须认识到，我们的选择，在某种情况下可能有利，而在另一情形下却有可能对我们不利。要想不与现实脱节，想使自己更健康、幸福，我们就得接受这种可能性：一个人改变想法，既是合理的，也是正常的。</p><blockquote><p>强势法则五：犯错不可怕，但要承担后果。</p></blockquote><p>没有人使完美无缺的。犯错时人类特征的一部分。</p><blockquote><p>强势法则六：你有权说“我不知道”。</p></blockquote><p>如果事情还没做，就考虑每一种可能的结果，那么，你很可能什么夜干不成，而这正式哪些操控你的人乐意看到的。</p><p>在许多婚姻咨询案例中，配偶中的一方拽着另一方来治疗，往往是为了让医生告诉那名“病人”：“你是病人，你犯错了。”</p><blockquote><p>强势法则七：要与人交往，但不要刻意讨好。</p></blockquote><p>你的行为，并不是非得让他人喜欢或赞赏不可，你也无需因为自己“不被喜欢”而焦虑。对你来说最重要的是，达到自己的最终目的。</p><p>一个人，不可能永远生活在惧怕伤害他人感情的心态之中。有时候，任何人都免不了会给他人带来不快。这才是大都市的生活。</p><blockquote><p>强势法则八：你有权做出“不合逻辑”的决定</p></blockquote><p>许多人都会利用逻辑来操控我们，这种操控伎俩，是以下述观念作为基础的：你必须遵循逻辑，因为逻辑判断要胜过我们任何人所作的判断。</p><p>合乎逻辑，并不一定会解决你的全部问题。但它却意味着，你会把解决问题的方法局限在那些完全理解的事物上——实际上，问题的解决之道往往存在于局限之外。</p><blockquote><p>强势法则九：你有权说“我不明白”</p></blockquote><p>当我们认识到，对人生、对自己、对周围事物了解的少之又少的时候，我们就有了真正的智慧。</p><blockquote><p>强势法则十：你有权说“我不在乎”</p></blockquote><p>前面所述的各项强势法则，存在着许多重叠的地方。这是因为，它们都只由你的首要权利——做自己的最终评判者——衍生出来的具体权利罢了。</p><p><strong>他人操控你的手段当中，贯穿着一根共同的主线：他们想当然地认为，作为人类，纵然不完美，你也“应当”努力做到十全十美。如果因为条件限制，你无法完善自我，那你至少也“应当”去完善那种有人情味的、通情达理的做事方式。假如你对自己也这么想，就很容易被他人用形形色色的方式操控，这些方式只有想不到，没有做不到的。</strong></p><p>一个简易法则，将内心的矛盾表达出来，归入“我想做的”， “我必须做的”， 或 “我应当做的”这三类当中去。</p><p>“我想做的”——简单明了，有了这些意愿之后，你可能就得去做某些“我必须做的”事情。</p><p>“我必须做的”——是你心中权衡之后，所作的妥协，或是你与他人达成的折中办法。</p><p>“我应当做的”——可以归入操控性的结构当中，这种结构会让你按照他人的意愿行事，或者归入武断性的结构当中，这种结构是你强加给自己的，目的是为了应对自己在“能或者不能做什么”这一点上的不安全感。</p><p>无论什么时候，一旦听到自己或者他人说起“应当”这个词，就赶紧 支起那根反操控的天线，凝神细听吧。十有八九，他接下来的意思就是说，“你并不是自己的最终评判者”。</p><p>——2020/4/30 夜</p><h3 id="Part-2：训练强势力"><a href="#Part-2：训练强势力" class="headerlink" title="Part 2：训练强势力"></a>Part 2：训练强势力</h3><ul><li><h4 id="chapter-4：始终如一地坚持你的意愿"><a href="#chapter-4：始终如一地坚持你的意愿" class="headerlink" title="chapter 4：始终如一地坚持你的意愿"></a>chapter 4：始终如一地坚持你的意愿</h4></li></ul><p>要想变得强势，你不但需要了解有哪些强势法则，还得明白怎样去行使这些权利。前者是理念，后者是一系列强势行为。</p><blockquote><p>表现强势的技巧一：“我是一张坏唱片”法  “Broken Record”——反复纠缠</p></blockquote><p>你们之所以失败，原因就在于太容易放弃。</p><p>言语上的强势最重要的一方面，就是坚持，就是一而再再而三地说出你的意愿，而不生气、不动怒、也不大喊大叫。</p><p>通过练习，让自己像一张坏唱片那样说话，这样我们就可以学会坚定不移，学会不偏离主题，执着不懈地说出自己想说地话，学会毫不理睬对方提出的所有细枝末节。</p><p>在强势状态下坚持的权利，应当一而再、再而三地表达出来，知道实现你所想要地结果为止——</p><ol><li>使某人不再操控我们</li><li>实现我们地某种物质目的</li><li>找到某种可行的折中办法</li><li>达到自己的治疗性结果</li><li>让我们重拾自尊</li></ol><p>要学会不再下意识回答他人提出的任何问题，或者下意识地回应别人的话。原有的错误习惯源于我们的一种观念，那就是：假如有人跟我们说话，我们就“应当”回答，并且“应当”针对这个人所说的话，做出明确而具体的回应。</p><p>要学会不理会别人的催促和提问，强势、自如地说出心中所想，不按别人的意愿说话。</p><blockquote><p>你可以“哄骗”某人去做某些事情，可以操控某人，也可以强势地明说你想让某人做什么，但你无法永远控制另一个成年人。其中，强势的明说最有效，因为它能迅速终止相互操控，使产生了矛盾的双方能够坦率地沟通，从而找出问题的解决办法。</p></blockquote><p>这些自主性的语言技能，跟你们所学到的其他技能没什么两样，它们都与道德上的是非对错无关。比如说，学会开车后，你既可以利用这一技能送孩子们去参加周日野餐，也可以驾车帮助黑手党逃跑。</p><blockquote><p>表现强势的技巧二：可行折中法</p></blockquote><p>我们的自尊感，要优于其他一切事物。</p><p>在某些情况下，采取强势的态度并不现实。假如你根本无法掌控事态的发展，用本书所述的系统性方法来坚持自身的权利，就很不明智，甚至还可能带来危险。必须限制你自己的行为、不能过分强势。</p><p>这些特殊情况，主要指设计到法律和体格因素的情况。</p><p>在涉及法律的情况下，我们应当用克制的态度来平衡强势的行为，因为哪些掌权的人只要乐意，就能用我们的前途来开玩笑。另一种不适宜表现得过分强势的清醒，就是当你的身体完全任由他人摆布的时候。在那种打了就跑、暴动骚乱、抢劫钱财或者背后劫袭的情形下，强势对你并没有什么用处。</p><blockquote><p>不明智地逞一时之勇，并不是强势。有时候，无论你表现得如何强势和坚持，你都注定赢不了，也注定实现不了你的物质目标。</p></blockquote><p>——2020/5/1</p><ul><li><h4 id="chapter-5：掌握沟通上的强势，消除交际挫折感"><a href="#chapter-5：掌握沟通上的强势，消除交际挫折感" class="headerlink" title="chapter 5：掌握沟通上的强势，消除交际挫折感"></a>chapter 5：掌握沟通上的强势，消除交际挫折感</h4></li></ul><p>当人们真正变得强势后，他们开始擅长社交。</p><p>不自信的人，在社交场合下通常难以与他人交流。这种人往往很腼腆。</p><p>沟通是”黏合剂”，它将人们凝聚起来，使人际关系发展并巩固，成为相互支持、共同协商、具备激励性和满足感的渠道。要想让一种社会关系得以发展，双方在彼此交往的时候，都必须保持最低水平的强势的态度。</p><p>自己的意愿、喜好、厌憎、兴趣，自己正在做什么，想做什么，自己的做事方式······ 谈论自己是什么样的人、谈论我怎样生活，我有什么能力，以及让他人用同样的方式舒适愉快地谈论自身，都属于强势地社交技能。</p><blockquote><p>表现强势的技巧三：自由信息法</p></blockquote><p>首先，你得练习聆听他人说出的，关于他们自身情况的一些提示。跟进他人自身情况的自由信息（并没有询问这些，也没有进行评论），在社交环境下会有一箭双雕的效果。</p><blockquote><p>表现强势的技巧四：自我表露法</p></blockquote><p>强势地披露自己的情况——你的想法、感受，以及对他人自由信息的回应——能够使社交谈话变成一种双向交流。</p><blockquote><p>防止受到操控的方法：向他人表露自己的担忧</p></blockquote><p>你的情感可能并不合理，可它们仍是你的真实情感，我们必须尊重这些感受。</p><p>遗憾的是，我们一般并不尊重自己的情感。</p><p>当然，我们一直强调的这种主动自我表露，是指披露哪些我们想当然认为应当隐藏起来的东西：反感、忧虑、无知、惧怕等。主动地自我表露，不应当与那种毫无尊严可言、和盘托出式地忏悔混淆，后者具有不自觉、无意识和已成习惯地特征。</p><p>主动表露自己的缺点，表明自己愿意接纳这些缺点，很可能是防止他人操控、确保内心平和的一种最为有效的自主技能。</p><blockquote><p>表现你的强势，要注重眼神交流。</p></blockquote><p>系统性强势训练的目的，是为了呈现出一个沉着强势、善于应对与他人的矛盾、相当冷静的人。如果你在表现强势的同时，流露出别人可以察觉的焦虑，那么你的强势可能对他人产生不了影响。</p><p>“缺乏目光交流” 这种最常见的焦虑暗示，属于一种习得性的逃避反应。</p><p>建议：在回答问题或者进行语言陈述时，可以将目光聚焦于对方鼻子周围半径约9英寸的范围内，不盯着对方的眼睛。看着对方的耳朵，内心不会那么紧张焦虑，也不会打断思路。</p><p>——2020/5/5 午</p><ul><li><h4 id="chapter-6：强势应对他人的“批评”式操控"><a href="#chapter-6：强势应对他人的“批评”式操控" class="headerlink" title="chapter 6：强势应对他人的“批评”式操控"></a>chapter 6：强势应对他人的“批评”式操控</h4></li></ul><h3 id="Part-3：在日常生活中运用强势"><a href="#Part-3：在日常生活中运用强势" class="headerlink" title="Part 3：在日常生活中运用强势"></a>Part 3：在日常生活中运用强势</h3><ul><li><h4 id="chapter-7：鼓励你最亲密的人，别被”是非对错“操控"><a href="#chapter-7：鼓励你最亲密的人，别被”是非对错“操控" class="headerlink" title="chapter 7：鼓励你最亲密的人，别被”是非对错“操控"></a>chapter 7：鼓励你最亲密的人，别被”是非对错“操控</h4></li><li><h4 id="chapter-8：日常人际关系——强势地”谈钱不伤感情“"><a href="#chapter-8：日常人际关系——强势地”谈钱不伤感情“" class="headerlink" title="chapter 8：日常人际关系——强势地”谈钱不伤感情“"></a>chapter 8：日常人际关系——强势地”谈钱不伤感情“</h4></li><li><h4 id="chapter-9：职场人际关系——应对上级或专业人士"><a href="#chapter-9：职场人际关系——应对上级或专业人士" class="headerlink" title="chapter 9：职场人际关系——应对上级或专业人士"></a>chapter 9：职场人际关系——应对上级或专业人士</h4></li><li><h4 id="chapter-10：朋友与亲戚关系——想出折中方案或直接说”不“"><a href="#chapter-10：朋友与亲戚关系——想出折中方案或直接说”不“" class="headerlink" title="chapter 10：朋友与亲戚关系——想出折中方案或直接说”不“"></a>chapter 10：朋友与亲戚关系——想出折中方案或直接说”不“</h4></li><li><h4 id="chapter-11：夫妻、情侣关系——巧妙运用强势，促进性爱和谐"><a href="#chapter-11：夫妻、情侣关系——巧妙运用强势，促进性爱和谐" class="headerlink" title="chapter  11：夫妻、情侣关系——巧妙运用强势，促进性爱和谐"></a>chapter  11：夫妻、情侣关系——巧妙运用强势，促进性爱和谐</h4></li></ul><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Booknote </category>
          
          <category> 人际交往 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人际交往 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 2 Python生态工具 《Python Linux系统管理与自动化运维》</title>
      <link href="/2020/04/26/python/administration/chapter02/"/>
      <url>/2020/04/26/python/administration/chapter02/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-生态工具"><a href="#Python-生态工具" class="headerlink" title="Python 生态工具"></a>Python 生态工具</h2><p>工欲善其事，必先利其器，掌握主流实用工具，优点很多，可以显著提升编程效率，形成统一代码风格，通过工具自学Python，任意切换 / 管理不同工作环境等。</p><span id="more"></span><h3 id="2-1-Python-内置小工具"><a href="#2-1-Python-内置小工具" class="headerlink" title="2.1 Python 内置小工具"></a>2.1 Python 内置小工具</h3><h4 id="内置下载服务器"><a href="#内置下载服务器" class="headerlink" title="内置下载服务器"></a>内置下载服务器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer</span><br><span class="line">python -m http.server # python3 </span><br></pre></td></tr></table></figure><p>执行上述命令，会在当前目录下启动一个文件下载服务器，默认打开8000端口。</p><h4 id="字符串转换为-json"><a href="#字符串转换为-json" class="headerlink" title="字符串转换为 json"></a>字符串转换为 json</h4><p>工作中，系统会调用底层服务的 API。底层服务的 API 一般都是以 JSON 格式返回，为了便于问题追踪，会将 API 返回的 JSON 转换为字符串记录到日志文件中。当需要分析问题时，需要将日志文件中的 JSON 字符串拿出来进行解析。即需要将一个 JSON 字符串转换为 JSON 对象，以提高日志的可读性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya ~]$ echo &#x27;&#123;&quot;address&quot;: &#123;&quot;province&quot;: &quot;jiangsu&quot;, &quot;city&quot;: &quot;nanjing&quot;&#125;, &quot;name&quot;: &quot;baiyongan&quot;, &quot;role&quot;: &quot;superman&quot;&#125;&#x27; | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    &quot;address&quot;: &#123;</span><br><span class="line">        &quot;city&quot;: &quot;nanjing&quot;,</span><br><span class="line">        &quot;province&quot;: &quot;jiangsu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;role&quot;: &quot;superman&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;baiyongan&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  前面是json 字符串，后面接管道与python -m json.tool</span></span><br></pre></td></tr></table></figure><h4 id="检查第三方库是否正确安装"><a href="#检查第三方库是否正确安装" class="headerlink" title="检查第三方库是否正确安装"></a>检查第三方库是否正确安装</h4><p>如果使用脚本对大批量的服务器进行自动部署，可以使用python解释器的 -c 参数快速地执行import 语句。</p><p>最关键——可以在脚本中实现对远程服务器地验证操作。</p><h3 id="2-2-pip-高级用法"><a href="#2-2-pip-高级用法" class="headerlink" title="2.2 pip 高级用法"></a>2.2 pip 高级用法</h3><h4 id="pip常用命令"><a href="#pip常用命令" class="headerlink" title="pip常用命令"></a>pip常用命令</h4><table><thead><tr><th>子命令</th><th>功能</th></tr></thead><tbody><tr><td>install</td><td>安装 如：pip install flask==0.8 安装特定版本</td></tr><tr><td>download</td><td>下载</td></tr><tr><td>uninstall</td><td>卸载</td></tr><tr><td>freeze</td><td>按照requirements 格式输出安装包，<strong>pip freeze &gt; requirements.txt</strong>                                          可以到其他服务器上执行 <strong>pip install -r requirements.txt</strong>  直接安装软件</td></tr><tr><td>list</td><td>列出当前系统中的安装包</td></tr><tr><td>show</td><td>查看安装包的信息：版本、依赖、许可证、作者、主页等</td></tr><tr><td>check</td><td>检查安装包的依赖是否完整</td></tr><tr><td>search</td><td>查找</td></tr><tr><td>wheel</td><td>打包软件到wheel格式</td></tr><tr><td>hash</td><td>计算安装包的hash值</td></tr><tr><td>completion</td><td><strong>pip completion –bash &gt;&gt; ~/.profile</strong>    $ source ~/.profile 通过键入’pip i<tab>‘，将会自动输入 ‘pip install’</td></tr><tr><td>help</td><td>获取pip 和子命令的帮助信息</td></tr></tbody></table><h4 id="如何加速pip的安装"><a href="#如何加速pip的安装" class="headerlink" title="如何加速pip的安装"></a>如何加速pip的安装</h4><h5 id="方法一：更改镜像源"><a href="#方法一：更改镜像源" class="headerlink" title="方法一：更改镜像源"></a>方法一：更改镜像源</h5><p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p><p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p><p><strong>临时使用</strong>，如下：只有安装pillow时使用指定源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pillow</span><br></pre></td></tr></table></figure><p><strong>永久修改</strong>，修改配置文件</p><ul><li><p>Linux下，修改 ~/.pip/<strong>pip.conf</strong> (没有就创建一个)， 修改 index-url至tuna，内容如下：<br> [global]<br> index-url = <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p></li><li><p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件<strong>pip.ini</strong>，内容如下:<br> [global]<br> index-url = <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p></li><li><p>PyCharm 中更改镜像源</p><p>File &gt;&gt; Settings &gt;&gt; Project &gt;&gt; Project Interpreter &gt;&gt; (右侧边缘 + 号) Available Packages &gt;&gt; Manage Repositories &gt;&gt; 右侧边缘加号 &gt;&gt; input a repository URL &gt;&gt; 清华、豆瓣等</p></li></ul><h5 id="方法二：将软件下载到本地部署"><a href="#方法二：将软件下载到本地部署" class="headerlink" title="方法二：将软件下载到本地部署"></a>方法二：将软件下载到本地部署</h5><p>如果服务器无法连接外网，且安装包较多较大，可以先将包下载到本地，然后从本地安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载到本地</span></span><br><span class="line">pip install --download=&#x27;pwd&#x27; -r requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地安装</span></span><br><span class="line">pip install --no-index -f file://&#x27;pwd&#x27; -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="2-3-Python编辑器"><a href="#2-3-Python编辑器" class="headerlink" title="2.3 Python编辑器"></a>2.3 Python编辑器</h3><p>Linux 用 vim：代码补全插件 snipmate、语法检查插件 Syntastic、编程提示插件 jedi-vim</p><p>windows 用Pycharm</p><h3 id="2-4-Python-编程辅助工具"><a href="#2-4-Python-编程辅助工具" class="headerlink" title="2.4 Python 编程辅助工具"></a>2.4 Python 编程辅助工具</h3><p>Python 交互式编程：IPython Shell 和 jupyter (IPython Notebook)<br>IPython： 略</p><p>jupyter：略</p><h3 id="2-5-Python-调试器"><a href="#2-5-Python-调试器" class="headerlink" title="2.5 Python 调试器"></a>2.5 Python 调试器</h3><p>单步调试  标准库 的pdb 以及第三方库ipdb</p><p>ipdb 之于pdb，就相当于 IPython 之于Python</p><p><a href="https://docs.python.org/3.7/library/pdb.html">标准库的pdb</a>：部分调试命令</p><p>一种是直接在命令行参数指定使用pdb模块启动python 文件，适用于文件较短的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pdb test_pdb.py</span><br></pre></td></tr></table></figure><p>另一种，直接在代码中，调用set_trace方法设置断点，适用于程序文件较大的场景</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"><span class="keyword">import</span> ipdb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_nums</span>(<span class="params">n</span>):</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    pdb.set_trace()</span><br><span class="line">    <span class="comment"># ipdb.set_trace()</span></span><br><span class="line">    s += i</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sum_nums(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="2-6-Python-代码规范检查"><a href="#2-6-Python-代码规范检查" class="headerlink" title="2.6 Python 代码规范检查"></a>2.6 Python 代码规范检查</h3><blockquote><p><a href="https://www.python.org/dev/peps/pep-0008/">PEP8 编码规范</a> : 对齐规则、包导入顺序、空格与注释、命名习惯、异常处理等</p><p>google Python 编码风格</p></blockquote><ul><li>pycodestyle 检查代码规范</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@bya Test_Project]# cat test.py </span><br><span class="line">import os,sys</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print([ITEM FOR ITEM IN OS.LISTDIR(&#x27;.&#x27;) if item.endswith(&#x27;.py&#x27;)]);</span><br><span class="line">    print(  sys.version)</span><br><span class="line"></span><br><span class="line">if __name__ == __main__:</span><br><span class="line">    main()</span><br><span class="line">[root@bya Test_Project]# pycodestyle --show-source test.py # 使用 --show-source 显示出错源码</span><br><span class="line">test.py:1:10: E231 missing whitespace after &#x27;,&#x27;</span><br><span class="line">import os,sys</span><br><span class="line">         ^</span><br><span class="line">test.py:1:10: E401 multiple imports on one line</span><br><span class="line">import os,sys</span><br><span class="line">         ^</span><br><span class="line">test.py:3:1: E302 expected 2 blank lines, found 1</span><br><span class="line">def main():</span><br><span class="line">^</span><br><span class="line">test.py:4:70: E703 statement ends with a semicolon</span><br><span class="line">    print([ITEM FOR ITEM IN OS.LISTDIR(&#x27;.&#x27;) if item.endswith(&#x27;.py&#x27;)]);</span><br><span class="line">                                                                     ^</span><br><span class="line">test.py:5:11: E201 whitespace after &#x27;(&#x27;</span><br><span class="line">    print(  sys.version)</span><br><span class="line">          ^</span><br><span class="line">test.py:7:1: E305 expected 2 blank lines after class or function definition, found 1</span><br><span class="line">if __name__ == __main__:</span><br><span class="line">^</span><br><span class="line">[root@bya Test_Project]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用autopep8 将代码格式化</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autopep8 --in-place test.py # 相当于sed 里面的-i 选项，直接将修改结果保存到源文件中</span><br><span class="line"><span class="meta">#</span><span class="bash"> autopep8 还有--aggressive 选项，使用该选项， 会执行更多实质性的更改，多次使用，效果更佳。</span></span><br></pre></td></tr></table></figure><ul><li>pylint 代码审查工具</li></ul><h3 id="2-7-Python-工作环境管理"><a href="#2-7-Python-工作环境管理" class="headerlink" title="2.7 Python 工作环境管理"></a>2.7 Python 工作环境管理</h3><p>pyenv 用于管理不同的Python 版本：如工作时用Python 2.7.13， 学习时用Python 3.6.0</p><p>virtualenv 用于隔离不同项目的工作环境：如都在Python 2.7.13 中，项目A用flask 0.8，项目B用flask 0.9</p><p><strong>组合使用pyenv 和virtualenv，就能够构造Python 和第三方库的任意版本组合。</strong></p><p>virtualenv是一个独立工具，用户可以不用pyenv， 而单独用virtualenv，但如果用了pyenv，则需要安装pyenv-virtualenv插件。</p><ul><li><strong>安装 pyenv</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@bya Test_Project]# git clone https://github.com/yyuu/pyenv.git ~/.pyenv</span><br><span class="line">Cloning into &#x27;/root/.pyenv&#x27;...</span><br><span class="line">remote: Enumerating objects: 29, done.</span><br><span class="line">remote: Counting objects: 100% (29/29), done.</span><br><span class="line">remote: Compressing objects: 100% (23/23), done.</span><br><span class="line">remote: Total 17972 (delta 9), reused 10 (delta 3), pack-reused 17943</span><br><span class="line">Receiving objects: 100% (17972/17972), 3.55 MiB | 14.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (12236/12236), done.</span><br><span class="line">[root@bya Test_Project]# echo &#x27;export PYENV_ROOT=&quot;$HOME&quot;/.pyenv&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">[root@bya Test_Project]# echo &#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">[root@bya Test_Project]# echo &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">[root@bya Test_Project]# source ~/.bash_profile </span><br><span class="line">[root@bya Test_Project]# pyenv --help</span><br><span class="line">Usage: pyenv &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Some useful pyenv commands are:</span><br><span class="line">   commands    List all available pyenv commands</span><br><span class="line">   exec        Run an executable with the selected Python version</span><br><span class="line">   global      Set or show the global Python version(s)</span><br><span class="line">   help        Display help for a command</span><br><span class="line">   hooks       List hook scripts for a given pyenv command</span><br><span class="line">   init        Configure the shell environment for pyenv</span><br><span class="line">   install     Install a Python version using python-build</span><br><span class="line">   local       Set or show the local application-specific Python version(s)</span><br><span class="line">   prefix      Display prefix for a Python version</span><br><span class="line">   rehash      Rehash pyenv shims (run this after installing executables)</span><br><span class="line">   root        Display the root directory where versions and shims are kept</span><br><span class="line">   shell       Set or show the shell-specific Python version</span><br><span class="line">   shims       List existing pyenv shims</span><br><span class="line">   uninstall   Uninstall a specific Python version</span><br><span class="line">   version     Show the current Python version(s) and its origin</span><br><span class="line">   --version   Display the version of pyenv</span><br><span class="line">   version-file   Detect the file that sets the current pyenv version</span><br><span class="line">   version-name   Show the current Python version</span><br><span class="line">   version-origin   Explain how the current Python version is set</span><br><span class="line">   versions    List all Python versions available to pyenv</span><br><span class="line">   whence      List all Python versions that contain the given executable</span><br><span class="line">   which       Display the full path to an executable</span><br><span class="line"></span><br><span class="line">See `pyenv help &lt;command&gt;&#x27; for information on a specific command.</span><br><span class="line">For full documentation, see: https://github.com/pyenv/pyenv#readme</span><br><span class="line">[root@bya Test_Project]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>pyenv 的使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pyenv install --list # 查看支持版本</span><br><span class="line"></span><br><span class="line">pyenv install -v 3.6.0 # 安装某个Python 版本</span><br><span class="line"></span><br><span class="line">pyenv versions # 查看当前系统中的Python版本</span><br><span class="line"></span><br><span class="line">pyenv global 2.7.5 # 切换至 2.7.5 版本</span><br><span class="line"></span><br><span class="line">pyenv uninstall 2.7.5 # 删除2.7.5 版本</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>安装pyenv-virtualenv插件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@bya Test_Project]# git clone https://github.com/yyuu/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv</span><br><span class="line">Cloning into &#x27;/root/.pyenv/plugins/pyenv-virtualenv&#x27;...</span><br><span class="line">remote: Enumerating objects: 2064, done.</span><br><span class="line">remote: Total 2064 (delta 0), reused 0 (delta 0), pack-reused 2064</span><br><span class="line">Receiving objects: 100% (2064/2064), 580.31 KiB | 14.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1413/1413), done.</span><br><span class="line">[root@bya Test_Project]# echo &#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27; &gt;&gt;~/.bash_profile</span><br><span class="line">[root@bya Test_Project]# source ~/.bash_profile </span><br><span class="line">[root@bya Test_Project]# pyenv help virtualenv</span><br><span class="line">Usage: pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] &lt;virtualenv-name&gt;</span><br><span class="line">       pyenv virtualenv --version</span><br><span class="line">       pyenv virtualenv --help</span><br><span class="line"></span><br><span class="line">  -f/--force       Install even if the version appears to be installed already</span><br><span class="line"></span><br><span class="line">[root@bya Test_Project]# </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用pyenv-virtualenv插件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pyenv virtualenv 2.8.5 first_project  # 新建两个工作环境</span><br><span class="line">pyenv virtualenv 2.8.5 second_project</span><br><span class="line"></span><br><span class="line">pyenv virtualenvs # 查看工作环境</span><br><span class="line"></span><br><span class="line">pyenv activate first_project # 进入一个工作环境</span><br><span class="line">(first_project) $ pip install flask==0.8</span><br><span class="line">(first_project) $ pyenv deactivate # 退出一个工作环境</span><br><span class="line"></span><br><span class="line">pyenv virtualenv-delete first_project # 删除一个虚拟环境 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>IPython这一块没有写，setuptools 工具也没写。</p><p><strong>重点是要知道工具的存在，并且知道哪些工具解决哪些问题。</strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
            <tag> pdb </tag>
            
            <tag> pycodestyle </tag>
            
            <tag> pyenv </tag>
            
            <tag> virtualenv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 序列化模块——json</title>
      <link href="/2020/04/23/python/fundation/module-json-pickle/"/>
      <url>/2020/04/23/python/fundation/module-json-pickle/</url>
      
        <content type="html"><![CDATA[<h3 id="JSON概念"><a href="#JSON概念" class="headerlink" title="JSON概念"></a>JSON概念</h3><p>JSON(JavaScript Obeject Notation) 是一种轻量级的数据交换格式，易于人阅读与编写，同时易于机器解析和生成。JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为<strong>理想的数据交换语言</strong>。</p><p>前端与后端的交互，其实可以就是js 与 python 进行数据交互</p><p><img src="/images/js-json-py.png" alt="js-json-py"></p><ul><li>json是一种通用的数据类型，任何语言都认识</li><li>接口返回的数据类型都是json</li><li>长得像字典，形式也是k-v { }</li><li>其实json是字符串</li><li>字符串不能用key、value来取值，要先转成字典才可以</li></ul><span id="more"></span><h3 id="JSON基本语法"><a href="#JSON基本语法" class="headerlink" title="JSON基本语法"></a>JSON基本语法</h3><ul><li><p><strong>JSON 名称/值对</strong>。类似于Python中的字典，<strong>注意必须用——双引号</strong>， 如 {“name” : “Python”}</p></li><li><p><strong>JSON 值的类型</strong>。可以是数字 (整数或浮点数)，字符串 (在双引号中)，逻辑值 (True 或 False )，数组 (在中括号中)，对象 (在大括号中)，以及null。</p><ul><li>其中的value值有：<ul><li><strong>number(int, float)</strong>    </li><li><strong>“string”</strong></li><li><strong>true   /  false</strong></li><li><strong>[array]</strong></li><li><strong>(object)</strong></li><li><strong>null</strong></li></ul></li></ul></li><li><p><strong>JSON 对象</strong>。 JSON对象，在花括号 {} 中书写，对象可以包含多个名称/值对，以逗号进行分隔。</p></li><li><p><strong>JSON数组。</strong> json的数组在方括号中书写，可以包含多个JSON 对象。</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sites&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jd&quot;</span>,  <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;www.jd.com&quot;</span>   &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;taobao&quot;</span>,   <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;www.taobao.com&quot;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python操作JSON"><a href="#Python操作JSON" class="headerlink" title="Python操作JSON"></a>Python操作JSON</h3><p>Python 操作json模块，主要执行序列化和反序列化的操作。</p><ul><li><strong>序列化（encoding）</strong>：把一个 Python对象编码转化为 JSON 字符串</li><li><strong>反序列化（decoding）</strong>：把 JSON 格式字符串解码转换成 Python 数据对象</li></ul><h4 id="json模块的主要函数"><a href="#json模块的主要函数" class="headerlink" title="json模块的主要函数"></a>json模块的主要函数</h4><p>不管是dump还是load，<strong>带s的都是和字符串相关的，不带s的都是和文件相关的。</strong></p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>dumps</td><td>只完成了序列化为 str 的操作</td></tr><tr><td>dump</td><td>必须传文件描述符，将序列化的 str 写到文件中</td></tr><tr><td>loads</td><td>只完成了反序列化</td></tr><tr><td>load</td><td>接收文件描述符，完成了读文件  +  反序列化</td></tr></tbody></table><h5 id="json-dumps-函数源码："><a href="#json-dumps-函数源码：" class="headerlink" title="json.dumps() 函数源码："></a>json.dumps() 函数源码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumps</span>(<span class="params">obj, *, skipkeys=<span class="literal">False</span>, ensure_ascii=<span class="literal">True</span>, check_circular=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        allow_nan=<span class="literal">True</span>, cls=<span class="literal">None</span>, indent=<span class="literal">None</span>, separators=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        default=<span class="literal">None</span>, sort_keys=<span class="literal">False</span>, **kw</span>):</span></span><br><span class="line">    <span class="comment"># sort_keys：表示序列化JSON对象时是否对字典的key进行排序，字典默认是无序的。</span></span><br><span class="line">    <span class="comment"># indent：表示缩进，可以使数据格式可读性更强，格式化输出JSON字符串，如果ident是一个非负的整数，那么JSONarray元素和object成员将会被以相应的缩进级别进行打印输出。</span></span><br><span class="line">    <span class="comment"># separators：当使用ident参数时json模块序列化Python对象后得到的JSON字符串中的”,”号和”:”号分隔符后默认会附加一个空白字符，可以通过separators参数重新指定分隔符，去除无用的空白字符。指定的分隔符一般是一个元祖类型的数据，比如(&#x27;,&#x27;,&#x27;:&#x27;)。</span></span><br></pre></td></tr></table></figure><h5 id="json-load-函数源码："><a href="#json-load-函数源码：" class="headerlink" title="json.load()函数源码："></a>json.load()函数源码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">fp, *, cls=<span class="literal">None</span>, object_hook=<span class="literal">None</span>, parse_float=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        parse_int=<span class="literal">None</span>, parse_constant=<span class="literal">None</span>, object_pairs_hook=<span class="literal">None</span>, **kw</span>):</span></span><br></pre></td></tr></table></figure><h4 id="json字符串与Python原始类型之间的数据类型对应关系"><a href="#json字符串与Python原始类型之间的数据类型对应关系" class="headerlink" title="json字符串与Python原始类型之间的数据类型对应关系"></a>json字符串与Python原始类型之间的数据类型对应关系</h4><p><strong>Python 原始类型向JSON 类型的转化对照表</strong></p><table><thead><tr><th align="center">Python</th><th align="center">JSON</th></tr></thead><tbody><tr><td align="center"><strong>dict</strong></td><td align="center"><strong>object</strong></td></tr><tr><td align="center"><strong>list tuple</strong></td><td align="center"><strong>array</strong></td></tr><tr><td align="center"><strong>str unicode</strong></td><td align="center"><strong>string</strong></td></tr><tr><td align="center"><strong>int  long  float</strong></td><td align="center"><strong>number</strong></td></tr><tr><td align="center"><strong>True</strong></td><td align="center"><strong>true</strong></td></tr><tr><td align="center"><strong>False</strong></td><td align="center"><strong>false</strong></td></tr><tr><td align="center"><strong>None</strong></td><td align="center"><strong>null</strong></td></tr></tbody></table><p><strong>JSON 类型向 Python 原始类型的转化对照表</strong></p><table><thead><tr><th align="center">JSON</th><th align="center">Python</th></tr></thead><tbody><tr><td align="center"><strong>object</strong></td><td align="center"><strong>dict</strong></td></tr><tr><td align="center"><strong>array</strong></td><td align="center"><strong>list</strong></td></tr><tr><td align="center"><strong>string</strong></td><td align="center"><strong>str</strong></td></tr><tr><td align="center"><strong>number（int）</strong></td><td align="center"><strong>int</strong></td></tr><tr><td align="center"><strong>number（real）</strong></td><td align="center"><strong>float</strong></td></tr><tr><td align="center"><strong>true</strong></td><td align="center"><strong>True</strong></td></tr><tr><td align="center"><strong>false</strong></td><td align="center"><strong>False</strong></td></tr><tr><td align="center"><strong>null</strong></td><td align="center"><strong>None</strong></td></tr></tbody></table><h4 id="序列化操作实例"><a href="#序列化操作实例" class="headerlink" title="序列化操作实例"></a>序列化操作实例</h4><h4 id="反序列化操作实例"><a href="#反序列化操作实例" class="headerlink" title="反序列化操作实例"></a>反序列化操作实例</h4><h4 id="自定义对象的序列化"><a href="#自定义对象的序列化" class="headerlink" title="自定义对象的序列化"></a>自定义对象的序列化</h4><h4 id="json-和-pickle-模块"><a href="#json-和-pickle-模块" class="headerlink" title="json 和 pickle 模块"></a>json 和 pickle 模块</h4><p>json模块和pickle模块都有dumps、dump、loads、load四种方法，而且用法一样。不同的是，json模块序列化出来的是通用格式，其他编程语言都认识，就是普通的字符串。而pickle模块序列化出来的只有python认识，其他语言不认识，表现为乱码。不过，pickle可以序列化函数，但是其他文件想用该函数，在该文件中需要有该函数的定义（定义和参数必须相同，内容可以不同）？</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Fundation </category>
          
          <category> module </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 1 Python语言与Linux系统管理 《Python Linux系统管理与自动化运维》</title>
      <link href="/2019/09/30/python/administration/chapter01/"/>
      <url>/2019/09/30/python/administration/chapter01/</url>
      
        <content type="html"><![CDATA[<h2 id="本书特色"><a href="#本书特色" class="headerlink" title="本书特色"></a>本书特色</h2><p>本书介绍了Python语言在Linux系统管理中的应用，包括编写Python脚本管理Linux系统，使用Python编写的自动化工具管理Linux系统，以及使用Python打造专属的管理工具等。</p><p>实战类书籍，有<strong>大量实战案例</strong>。</p><span id="more"></span><h2 id="如何阅读本书？"><a href="#如何阅读本书？" class="headerlink" title="如何阅读本书？"></a>如何阅读本书？</h2><p>共11章，每一章专注于解决某一类问题，均可单独成册，择需阅读即可。</p><p>Chapter1: 为什么学Python？</p><p>Chapter2：Python的多个生态工具，解决学习Python中的环境问题。</p><p>Chapter3~7：如何用Python编写脚本管理Linux？可提高Python编程技能。</p><p>如何构建命令行工具？</p><p>如何处理文本问题？</p><p>如何进行系统管理？</p><p>如何监控Linux系统？</p><p>如何处理文档和报告？······</p><p>Chapter8~10：多个Python语言开发的工具：网络嗅探工具Scapy、自动化部署Fabric、自动部署工具Ansible，偏重运维操作。简单易用、功能强大、扩展性强，运维工程师的得力助手。</p><p><strong>Chapter11：综合案例</strong>——Python打造MySQL的数据库专家系统，以数据库为载体，介绍了Python中的高级语言特性，和Python中的系统架构。充分理解本章，可以使自身Python水平有较大提升。</p><h2 id="勘误-amp-资源"><a href="#勘误-amp-资源" class="headerlink" title="勘误&amp;资源"></a>勘误&amp;资源</h2><p><strong><a href="https://github.com/lalor/python_for_linux_system_administration">github-lalor</a></strong></p><h2 id="Python-语言的流行证明"><a href="#Python-语言的流行证明" class="headerlink" title="Python 语言的流行证明"></a>Python 语言的流行证明</h2><p>学习一门新技术，该越流行，对于初学者越友好，容易提升技能，还有求职优势。</p><p><strong>TIOBE 的编程语言排行榜</strong>——使编程语言流行趋势的一个指标，它基于互联网上有经验的工程师、课程和第三方厂商的数量，使用搜索引擎计算而得。</p><p><strong>Google Trend</strong> ：查询Python关键词搜索</p><p><strong>微信搜索指数</strong>：对比关键词</p><h2 id="why-Python-开始流行？"><a href="#why-Python-开始流行？" class="headerlink" title="why Python 开始流行？"></a>why Python 开始流行？</h2><ol><li>简单易学：专注于如何解决问题，而不是编程语言的语法和结构</li><li>语法优美：缩进标识代码块，减少大括号，句末分号等视觉杂讯，提高可读性</li><li>强大的库：battery included</li><li>开发效率高：实现相同功能，Python的代码往往只有C、C++、Java的 1/5~1/3，能够满足互联网快速迭代的需求。</li><li>应用领域广泛：Web开发、网络编程、自动化运维、自动化测试、Linux系统管理、数据分析、科学计算、人工智能、机器学习等。<strong>Python介于脚本语言和系统语言之间，所以，我们按照需求，可以将它当成一门脚本语言来编写脚本，也可以当成系统语言来编写服务。</strong></li></ol><h2 id="Python语言的缺点"><a href="#Python语言的缺点" class="headerlink" title="Python语言的缺点"></a>Python语言的缺点</h2><ol><li><strong>执行速度不够快</strong>：不是啥严重问题，一方面，网络或磁盘的延迟会抵消部分Python本身消耗的时间，另一方面，Python 和C特别容易结合，可以分离一部分需要优化速度的应用，将其转换为编译好的扩展，提高整体效率。</li><li><strong>Python中的GIL锁限制并发</strong>：Python对多处理器支持不好，GIL，即Python全局解释器锁，Global Interpreter Lock，当Python的默认解释器要执行字节码时，都需要先申请这个锁，也就是说，如果试图通过多线程扩展应用程序，将总是被这个GIL限制。</li><li><strong>Python2 和Python3 不兼容</strong></li></ol><h2 id="Python语言应用场景"><a href="#Python语言应用场景" class="headerlink" title="Python语言应用场景"></a>Python语言应用场景</h2><p><strong>应用场景几乎无限</strong></p><p>Web开发：适合快速迭代，非常适合互联网公司。如Django、Pyramid、Bottle、Tornado、Flask、web2py等。说明其能经受大规模用户的并发访问考验。</p><p>用户图形接口（GUI）：标准库tkInter，PyGObject、PyQt、PySide、Kivy、wxPython等。TKinter可轻松在不同平台间使用。</p><p>数值计算和科学计算：取代Matlab，成为科研新宠，SciPy、NumPy、Pandas等。</p><p>系统管理：OpenStack开源云计算平台即使用Python开发，除此，还有Ansible和Salt等自动化部署工具。</p><p>其他：pygame开发游戏，PIL库处理图片，NLTK进行自然语言处理等。</p><h2 id="why-Python适合Linux系统管理"><a href="#why-Python适合Linux系统管理" class="headerlink" title="why Python适合Linux系统管理"></a>why Python适合Linux系统管理</h2><ol><li>Python程序语法清晰、简单易懂，相对而言，shell作为基本功，语法复杂、可读性、可维护性差。</li><li>Python表达能力强：相对shell，有丰富的数据结构等，也可以进行多线程编程，shell办不到。</li><li>Python可跨平台：Python标准库对操作系统的接口进行了封装，如Python标准库绑定了POSIX以及其他常规操作工具，如环境变量、文件、套接字、管道、进程、多线程、正则、命令行参数、Shell命令启动器、文件名扩展等。相对于shell，有了跨平台的优势。</li><li>可方面地与操作系统集成，可以使用标准库对OS地封装，也可以在Python中执行Linux命令，完成任何管理任务。</li><li>许多Linux系统管理的开源项目：如psutil监控、IPy的IP地址管理等</li><li>许多自动化管理工具：Fabric、Ansible、SaltStack等</li><li><strong>Linux系统管理，可以发挥Python优点，避免其缺点</strong>——开发效率高，执行速度要求不高</li></ol><h2 id="Python2-vs-Python3"><a href="#Python2-vs-Python3" class="headerlink" title="Python2 vs Python3"></a>Python2 vs Python3</h2><p>通过Google统计分析</p><p>在<strong><a href="https://cloud.google.com/bigquery/querying-data">https://cloud.google.com/bigquery/querying-data</a></strong> 中执行下面的语句，查询不同Python版本依赖包的下载数据</p><p><strong>SELECT details.python, count(*)  as count FROM [the-psf:pypi.downloads20190930] GROUP BY details.python;</strong></p><p>统计中国Python版本使用情况</p><p><strong>SELECT details.python, count(*)  as count FROM [the-psf:pypi.downloads20190930] where country_code = ‘CN’ GROUP BY details.python;</strong></p><p>建议：</p><p>充分使用__<strong>future__</strong>  库，可以很好兼容Python2 和Python3 ；</p><p>可参考<a href="https://wiki.openstack.org/wiki/Python3">OpenStack</a>的做法，兼容Python2和Python3，也可用six库同时兼容2和3；</p><p>了解在Python3 中，已经弃用的Python2 语法；</p><p>版本推荐：Python2 &gt; 2.7    Python3 &gt; 3.4</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1569855067&ver=1884&signature=JqSmr4FcWkHUOixFmflaJkSN4gTMJePXfLHA9iDDclycxQKhgkIZ84nJLFz3CU-gnvS-EbMtbaLcWUgOFZD4ds5gU55zVm1wRPTQTcns2C32aDN2aoI4qJJlc9Tgu0BW&new=1">TIOBE之2019年8月编程语言排行</a></p><p><a href="https://www.zhihu.com/question/20430292">知乎-像 TIOBE 这样的编程语言排行榜是如何统计出来的？</a></p><p><a href="https://www.tiobe.com/tiobe-index/programming-languages-definition/">官网-TIOBE Programming Community Index Definition</a></p><h2 id="个人学习路线"><a href="#个人学习路线" class="headerlink" title="个人学习路线"></a>个人学习路线</h2><table><thead><tr><th>章节</th><th align="left">要求掌握程度</th></tr></thead><tbody><tr><td>chapter1</td><td align="left">了解</td></tr><tr><td>chapter2</td><td align="left">熟练应用</td></tr><tr><td>chapter 3,4,5,7</td><td align="left">熟练应用</td></tr><tr><td>chapter 6</td><td align="left">学习了解</td></tr><tr><td>chapter11</td><td align="left">重点阅读，争取掌握</td></tr><tr><td>chapter8</td><td align="left">有空再看</td></tr><tr><td>chapter9</td><td align="left">有空再看</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Roadmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 标准库学习路线梳理</title>
      <link href="/2019/09/11/python/fundation/library-index/"/>
      <url>/2019/09/11/python/fundation/library-index/</url>
      
        <content type="html"><![CDATA[<h3 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h3><h3 id="常用库总结"><a href="#常用库总结" class="headerlink" title="常用库总结"></a>常用库总结</h3><ul><li><p>基础必会</p><ul><li>文件、系统：<strong>os、os.path、sys</strong>、io</li><li>目录处理：pathlib、<strong>glob、fnmatch、shutil</strong></li><li>基本数学计算：<strong>math、random</strong>、statistics</li><li>时间、日期：<strong>time、datetime、date、timedelta、calendar</strong></li><li>文件内容管理：<strong>filecmp、hashlib、tarfile、zipfile</strong></li><li>综合：<strong>re、json、pickle、logging、unittest、pprint</strong></li><li>网络：urllib、socket、http、asyncio</li></ul></li><li><p>进阶掌握</p><ul><li><p>进程、线程、协程<strong>：threading、multiprocessing</strong>、concurrent、queue、<strong>asyncio</strong></p></li><li><p>函数式：<strong>itertools、functools</strong></p></li><li><p>数据科学：numpy、pandas、matplotlib、seaborn、scikit-learn</p></li><li><p>数据库：pymysql、pymongo、redis、elasticsearch</p></li></ul></li></ul><span id="more"></span><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>Web 开发</strong></li></ul><ul><li>用户图形接口（GUI）</li></ul><ul><li><strong>数值计算和科学计算</strong></li></ul><ul><li>爬虫</li></ul><ul><li>网络编程</li></ul><ul><li>自动化运维</li></ul><ul><li>自动化测试</li></ul><ul><li><strong>机器学习</strong></li></ul><ul><li>人工智能</li></ul><ul><li>······</li></ul><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><h4 id="官网文档（可选中文版）"><a href="#官网文档（可选中文版）" class="headerlink" title="官网文档（可选中文版）"></a><strong>官网文档</strong>（可选中文版）</h4><ul><li><p><a href="https://docs.python.org/3/">Python 3.7.4 documentation</a></p></li><li><p><a href="https://docs.python.org/3/library/">The Python Standard Library</a></p></li><li><p><a href="https://docs.python.org/3/howto/index.html">Python HOWTOs</a></p></li></ul><h4 id="优质资源"><a href="#优质资源" class="headerlink" title="优质资源"></a><strong>优质资源</strong></h4><ul><li><a href="https://pymotw.com/3/index.html">Python 3 Module of the Week</a></li></ul><p>PyMOTW-3 is a series of articles written by <a href="http://doughellmann.com/">Doug Hellmann</a> to demonstrate how to use the modules of the <a href="http://www.python.org/">Python</a> 3 standard library. It is based on the original <a href="http://pymotw.com/2/">PyMOTW</a> series, which covered Python 2.7. See <a href="https://pymotw.com/3/about.html">About Python Module of the Week</a> for details including the version of Python and tools used.</p><ul><li><a href="https://github.com/vinta/awesome-python">vinta/awesome-python · GitHub</a></li></ul><p>A curated list of awesome Python frameworks, libraries, software and resources <a href="https://awesome-python.com/">https://awesome-python.com/</a></p><ul><li><a href="https://github.com/jobbole/awesome-python-cn">jobbole/awesome-python-cn</a></li></ul><p>Python资源大全中文版，包括：Web框架、网络爬虫、模板引擎、数据库、数据可视化、图片处理等，由伯乐在线持续更新。</p><ul><li><a href="https://space.bilibili.com/441035997/channel/detail?cid=99600">bilibili ——YOOTK沐言优拓  Python从入门到项目实战</a></li></ul><h4 id="学习建议-amp-指导"><a href="#学习建议-amp-指导" class="headerlink" title="学习建议&amp;指导"></a><strong>学习建议&amp;指导</strong></h4><ul><li><a href="https://www.zhihu.com/question/22100190">知乎–应该怎样系统的学习Python标准库？</a></li><li><a href="https://www.zhihu.com/question/20501628">知乎–Python 常用的标准库以及第三方库有哪些？</a></li><li><a href="http://blog.konghy.cn/2017/04/04/python-modules/">博客–Python 模块收集</a></li><li><a href="https://zhuanlan.zhihu.com/p/22246193"><strong>Python不能不知的模块</strong></a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Fundation </category>
          
          <category> module </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Roadmap </tag>
            
            <tag> 标准库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5 Linux 系统管理 《Python Linux 系统管理与自动化运维》</title>
      <link href="/2019/09/10/python/administration/chapter05/"/>
      <url>/2019/09/10/python/administration/chapter05/</url>
      
        <content type="html"><![CDATA[<h2 id="5-Linux-系统管理"><a href="#5-Linux-系统管理" class="headerlink" title="5 Linux 系统管理"></a>5 Linux 系统管理</h2><span id="more"></span><hr><h3 id="5-1-文件读写"><a href="#5-1-文件读写" class="headerlink" title="5.1 文件读写"></a>5.1 文件读写</h3><h4 id="Python-内置的open函数"><a href="#Python-内置的open函数" class="headerlink" title="Python 内置的open函数"></a>Python 内置的open函数</h4><p>open 函数，接受文件名和打开模式作为参数，返回一个文件对象。     </p><p><strong>‘r’     默认读模式</strong>    不存在，则抛出FileNotFoundError 异常</p><p>‘w’     写模式    非空，则内容被清空，不存在，则创建</p><p>‘x’    创建新文件    已存在，则抛出FileExistsError 异常。</p><p>‘a’    追加</p><p><strong>三步：打开—操作—关闭</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="避免文件句柄泄露"><a href="#避免文件句柄泄露" class="headerlink" title="避免文件句柄泄露"></a>避免文件句柄泄露</h4><p>文件处理结束后，要及时关闭文件，文件举兵泄露可能时最常见的资源泄露问题。</p><p>方式1： finally 语句关闭句柄</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>方法2：上下文管理器——简洁，Pythonic</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure><h4 id="常见的文件操作函数"><a href="#常见的文件操作函数" class="headerlink" title="常见的文件操作函数"></a>常见的文件操作函数</h4><p>三个读：</p><p>read：读取文件中的所有内容</p><p>readline： 一次读取一行</p><p>readlines：将文件内容存储到一个列表中，列表中每一行对应于文件中的一行</p><p>两个写：</p><p>write：写字符串到文件中，并返回写入的字符数</p><p>writelines：写一个字符串列表到文件中</p><p>也可以使用print( ) 函数，将输出结果输出到文件中，更灵活。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/data.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;hello, world&#x27;</span>, sep=<span class="string">&quot;,&quot;</span>, file=f)</span><br></pre></td></tr></table></figure><h4 id="Python-的文件时一个可迭代对象"><a href="#Python-的文件时一个可迭代对象" class="headerlink" title="Python 的文件时一个可迭代对象"></a>Python 的文件时一个可迭代对象</h4><p>Python中，for循环不仅可以便利字符串、列表、元组这样的可迭代序列，还可以使用迭代器协议便利可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>) <span class="keyword">as</span> inf:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> inf:</span><br><span class="line">        <span class="built_in">print</span>(line.upper())</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-文件与文件路径管理"><a href="#5-2-文件与文件路径管理" class="headerlink" title="5.2 文件与文件路径管理"></a>5.2 文件与文件路径管理</h3><p>os模块包含与操作系统的系统环境、文件系统、用户数据库以及权限进行交互的函数，可以写出跨平台的程序。</p><p>本节专注于os模块中，与文件路径相关的一些函数。</p><h4 id="使用os-path-进行路径和文件管理"><a href="#使用os-path-进行路径和文件管理" class="headerlink" title="使用os.path 进行路径和文件管理"></a>使用os.path 进行路径和文件管理</h4><h5 id="1-拆分路径"><a href="#1-拆分路径" class="headerlink" title="1 拆分路径"></a>1 拆分路径</h5><p>os.path.split()：返回二元组，包含文件的路径和文件名</p><p>os.path.dirname()：返回文件路径</p><p>os.path.basename()：返回文件名</p><p>os.path.splitext()：返回二元组，除去文件扩展名的部分和扩展名</p><h5 id="2-构建路径"><a href="#2-构建路径" class="headerlink" title="2 构建路径"></a>2 构建路径</h5><p> os.path.expanduser():    展开用户的GHOME目录</p><p>os.path.abspath():    得到文件或路径的绝对路径</p><p>os.path.join():    <strong>根据不同操作平台，使用不同的路径分隔符拼接路径</strong>， 如 os.path.join(‘~’, ‘t’, ‘a.py’)</p><p><strong>相应的，检验是否是绝对路径： os.path.isabs()</strong></p><p><strong>_<em>file_</em></strong>  这个特殊变量表示当前代码所在的源文件，有时，需要导入当前源文件父目录下的软件包（如编写单元测试），因此，需要获取父目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CWD:&quot;</span>, os.getcwd())</span><br><span class="line">path = os.path.abspath(__file__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Full Path:&quot;</span>, path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Parent directory of current file:&quot;</span>, os.path.abspath(os.path.join(os.path.dirname(path), os.path.pardir)))</span><br></pre></td></tr></table></figure><h5 id="3-获取文件属性"><a href="#3-获取文件属性" class="headerlink" title="3 获取文件属性"></a><strong>3 获取文件属性</strong></h5><p>os.path.getatime    获取文件访问时间</p><p>os.path.getmtime    获取修改时间</p><p>os.path.getctime    获取创建时间</p><p>os.path.getsize    获取文件大小</p><h5 id="4-判断文件类型-判断类，返回Boolean值"><a href="#4-判断文件类型-判断类，返回Boolean值" class="headerlink" title="4 判断文件类型(判断类，返回Boolean值)"></a><strong>4 判断文件类型</strong>(判断类，返回Boolean值)</h5><p>os.path.exists    所指路径是否存在</p><p>os.path.ifsile    </p><p>os.path.isdir</p><p>os.path.islink</p><p>os.path.ismount</p><p><strong>充分利用os.path模块的函数，可以识现很多系统管理的功能</strong></p><h4 id="使用os模块管理文件和目录"><a href="#使用os模块管理文件和目录" class="headerlink" title="使用os模块管理文件和目录"></a>使用os模块管理文件和目录</h4><p>os 模块封装了操作系统的API，工程师可以用同一的接口编写跨平台的应用程序。</p><p>os.unlink / os.remove    删除path所指向的文件</p><p>os.rmdir    删除文件夹，该文件夹必须为空，否则报错</p><p>os.mkdir    创建文件夹</p><p>os.rename    重命名文件或文件夹</p><p>os.chmod    修改权限</p><p>os.access    判断权限</p><p><strong>权限表示：读、写、执行 对应 R_OK、W_OK、X_OK</strong></p><hr><h3 id="5-3-查找文件"><a href="#5-3-查找文件" class="headerlink" title="5.3 查找文件"></a>5.3 查找文件</h3><h4 id="使用fnmatch-找到特定的文件"><a href="#使用fnmatch-找到特定的文件" class="headerlink" title="使用fnmatch 找到特定的文件"></a><strong>使用fnmatch 找到特定的文件</strong></h4><p>大部分情况下，使用字符串的前缀匹配和后缀匹配查找特定类型的文件，就可以满足要求；如果更灵活的话，可以使用<strong>fnmatch库</strong>——专门用来进行文件名匹配，只有四个函数</p><p>fnmatch.fnmatch    判断文件名是否符合特定模式</p><p>fnmatch.fnmatchcase    判断文件名是否符合特定模式，<strong>不区分大小写</strong></p><p>fnmatch.filter    <strong>返回输入列表</strong>中，符合特定模式的文件名列表   <strong>第一个参数为文件名列表，第二个为文件名模式</strong></p><p>fnmatch.translate    将通配符模式转为正则表达式</p><p>其中，fnmatch支持的通配符有 </p><p>*  匹配任意数量字符</p><p>？ 匹配单个字符</p><p>[seq]     匹配seq中的字符</p><p>[!seq]     匹配除了seq以外的任何字符</p><h4 id="使用glob找到特定的文件"><a href="#使用glob找到特定的文件" class="headerlink" title="使用glob找到特定的文件"></a><strong>使用glob找到特定的文件</strong></h4><p><strong>相当于 os.listdir 加上 fnmatch</strong>，使用glob之后，不需要再调用os.listdir获取文件列表。</p><p>glob.glob( )</p><p>Python的字符串匹配功能，有<strong>字符串后缀匹配、fnmatch匹配、glob模式匹配，三种，其中需求简单，用第一个，需求更多，用后两个。</strong></p><h4 id="使用os-walk-遍历目录树"><a href="#使用os-walk-遍历目录树" class="headerlink" title="使用os.walk 遍历目录树"></a><strong>使用os.walk 遍历目录树</strong></h4><p>如果要查找某个目录和其子目录中的所有文件，可用os.walk函数。</p><p>walk 返回一个三元组<strong>（dirpath,  dirnames,  filenames）</strong></p><p>其中 ，<strong>dirpath: 当前目录、dirnames：当前目录下的子目录列表、filenames：当前目录下的文件列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#遍历目录的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到目录下最大（最老）的十个文件</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-4-高级文件处理接口-shutil"><a href="#5-4-高级文件处理接口-shutil" class="headerlink" title="5.4 高级文件处理接口 shutil"></a>5.4 高级文件处理接口 shutil</h3><p>os模块定位是对操作系统的接口进行封装，<strong>主要作用是跨平台</strong>；</p><p>shutil 模块包含复制、移动、重命名、和删除文件及目录的函数，<strong>主要作用是文件和目录的管理</strong>。</p><p>两者互补，并不冲突，对于文件操作，应该尽量用shutil。</p><h4 id="复制文件和文件夹"><a href="#复制文件和文件夹" class="headerlink" title="复制文件和文件夹"></a><strong>复制文件和文件夹</strong></h4><p>shutil.copy(‘a.py’ , ‘b.py’)</p><p>shutil.copytree(‘dir1’ , ‘dir2’)</p><h4 id="文件和文件夹的移动和重命名"><a href="#文件和文件夹的移动和重命名" class="headerlink" title="文件和文件夹的移动和重命名"></a><strong>文件和文件夹的移动和重命名</strong></h4><p><strong>shutil.move(src, dst)</strong>,几乎等同于Linux下的mv命令</p><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a><strong>删除目录</strong></h4><p>和os的区别：os.rmdir()  和os.removedirs() 要求被删除的目录为空，否则不能强制删除，而shutil.rmtree()不管目录是否为非空，直接删除。</p><p><strong>一般用os.unlink 删除单个文件，用shutil.rmtree 删除整个目录</strong></p><hr><h3 id="5-5-文件内容管理"><a href="#5-5-文件内容管理" class="headerlink" title="5.5 文件内容管理"></a>5.5 文件内容管理</h3><p>管理服务器时，可能有如下问题：</p><p>1）两个目录中文件到底有什么差别？</p><p>2）系统中有多少重复文件？</p><p>3）如何找到并删除系统中的重复文件？</p><h4 id="目录和文件比较"><a href="#目录和文件比较" class="headerlink" title="目录和文件比较"></a><strong>目录和文件比较</strong></h4><p>filecmp 模块</p><p>filecmp.cmp()    比较两个文件是否相同，同则True</p><p>filecmp.cmpfiles()      <strong>同时比较两个不同目录下的多个文件</strong>，并返回一个三元组</p><p><strong>其中，三元组包括相同文件、不同文件、和无法比较的文件</strong></p><p>filecmp.dircmp()     用来比较两个目录，可以通过读取其属性的方式，获得目录之间的差异</p><p>注意，<strong>并不会递归到子目录</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d = filecmp.dircmp(<span class="string">&#x27;dir1&#x27;</span>, <span class="string">&#x27;dir2&#x27;</span>)</span><br><span class="line"><span class="comment">#获取dir1 和dir2的基本差别</span></span><br><span class="line">d.report() </span><br><span class="line"><span class="comment">#获取dir1的文件及文件夹列表</span></span><br><span class="line">d.left_list</span><br><span class="line"><span class="comment">#获取只在dir1中的文件及文件夹</span></span><br><span class="line">d.left_only</span><br><span class="line"></span><br><span class="line"><span class="comment">#右侧同理</span></span><br><span class="line">d.right_list</span><br><span class="line">d.right_only</span><br></pre></td></tr></table></figure><h4 id="MD5校验和比较"><a href="#MD5校验和比较" class="headerlink" title="MD5校验和比较"></a><strong>MD5校验和比较</strong></h4><p>校验码时通过散列函数计算而成，理论上，一个MD5哈希值可对应无限个文件，一般用于文件完整性的检查，尤其时用于检测文件传输、磁盘错误或其他情况下文件的正确性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bya Python_exercise]# md5sum /etc/passwd</span><br><span class="line">358b7d4722d0f902077068c118c06128  /etc/passwd</span><br></pre></td></tr></table></figure><p>Python中，应用hashlib模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">d = hashlib.md5()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        d.update(line)</span><br><span class="line">        </span><br><span class="line">d.hexdigest()</span><br></pre></td></tr></table></figure><h4 id="综合案例：寻找目录下的重复文件"><a href="#综合案例：寻找目录下的重复文件" class="headerlink" title="综合案例：寻找目录下的重复文件"></a><strong>综合案例</strong>：寻找目录下的重复文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-6-管理压缩包"><a href="#5-6-管理压缩包" class="headerlink" title="5.6 管理压缩包"></a>5.6 管理压缩包</h3><h4 id="使用tarfile库读取和创建-tar包"><a href="#使用tarfile库读取和创建-tar包" class="headerlink" title="使用tarfile库读取和创建    tar包"></a><strong>使用tarfile库读取和创建    tar包</strong></h4><p>tar包仅仅把多个文件进行打包便于传输，并不执行压缩操作。</p><p><strong>读取tar包</strong></p><p>与Python的文件管理操作类似，读取一个压缩包，需要打开，同时指定打开模式，并在操作完毕之后关闭文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">with</span> tarfile.<span class="built_in">open</span>(<span class="string">&#x27;tarfile_add.tar&#x27;</span>) <span class="keyword">as</span> t:</span><br><span class="line">    <span class="keyword">for</span> member_info <span class="keyword">in</span> t.getmembers():</span><br><span class="line">        <span class="built_in">print</span>(member_info.name)</span><br></pre></td></tr></table></figure><p>tarfile库中，最常用的函数有：</p><p>getnames    获取tar包中的文件列表</p><p>extract    提取单个文件</p><p>extractall    提取所有文件</p><p><strong>创建tar包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">with</span> tarfile.<span class="built_in">open</span>(<span class="string">&#x27;tarfile_add.tar&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out:</span><br><span class="line">    out.add(<span class="string">&#x27;README.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="使用tarfile库读取和创建-压缩包"><a href="#使用tarfile库读取和创建-压缩包" class="headerlink" title="使用tarfile库读取和创建    压缩包"></a><strong>使用tarfile库读取和创建    压缩包</strong></h4><p>只需要在打开文件时，指定压缩算法即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读取用gzip 压缩的tar包</span></span><br><span class="line"><span class="keyword">with</span> tarfile.<span class="built_in">open</span>(<span class="string">&#x27;tarfile_add.tar&#x27;</span>, mode=<span class="string">&#x27;r:gz&#x27;</span>) <span class="keyword">as</span> out:</span><br><span class="line"><span class="comment">#创建用bzip2算法压缩的tar包</span></span><br><span class="line"><span class="keyword">with</span> tarfile.<span class="built_in">open</span>(<span class="string">&#x27;tarfile_add.tar&#x27;</span>, mode=<span class="string">&#x27;w:bz2&#x27;</span>) <span class="keyword">as</span> out:</span><br></pre></td></tr></table></figure><h4 id="备份指定文件到压缩包中"><a href="#备份指定文件到压缩包中" class="headerlink" title="备份指定文件到压缩包中"></a><strong>备份指定文件到压缩包中</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#待总结</span></span><br></pre></td></tr></table></figure><h4 id="使用zipfile库创建和读取zip压缩包"><a href="#使用zipfile库创建和读取zip压缩包" class="headerlink" title="使用zipfile库创建和读取zip压缩包"></a>使用zipfile库创建和读取zip压缩包</h4><p>一般，在windows下，使用zip压缩格式</p><p><strong>读取zip文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line">example_zip = zipfile.ZipFile(<span class="string">&#x27;example.zip&#x27;</span>)</span><br><span class="line">example_zip.namelist()</span><br></pre></td></tr></table></figure><p>常用方法：</p><p>namelist：    返回zip文件中包含所有文件和文件夹的字符串列表</p><p>extract：    从zip中提取单个文件</p><p>extractall：从zip中提取所有文件</p><p><strong>创建zip文件</strong></p><p>如要创建，必须以写模式打开zip文件，与tarfile不同，ZipFile的对象时通过write方法添加文件的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line">newZip = zipfile.ZipFile(<span class="string">&#x27;new.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">newZip.write(<span class="string">&#x27;spam.txt&#x27;</span>)</span><br><span class="line">newZip.close()</span><br></pre></td></tr></table></figure><p><strong>使用Python的命令行工具创建zip格式的压缩包</strong></p><p>大部分Linux操作系统没装unzip工具，所以解压zip格式压缩包会比较麻烦</p><p><strong>zipfile可以提供命令行接口</strong>，一般包含以下几个选项</p><p>-l  现实zip包的文件列表</p><p>-c 创建zip压缩包</p><p>-e 提取zip压缩包</p><p>-t 验证文件时一个有效的zip压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m zipfile -c test.zip photo.jpg note.txt</span><br><span class="line">python -m zipfile -e test.zip for_test/</span><br><span class="line">python -m zipfile -l test.zip</span><br></pre></td></tr></table></figure><h4 id="使用shutil-创建和读取压缩包"><a href="#使用shutil-创建和读取压缩包" class="headerlink" title="使用shutil 创建和读取压缩包"></a><strong>使用shutil 创建和读取压缩包</strong></h4><p>shutil是高层次的问价接口，shutil支持的格式可以通过<strong>get_archive_formats</strong>函数获取，有bztar，gztar，tar，zip格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line">shutil.get_archive_formats()</span><br></pre></td></tr></table></figure><p><strong>shutil 创建压缩包</strong></p><p>shutil.make_archive() 有多个参数，但是只有<strong>base_name</strong>（压缩包名称，不包含扩展名） 和 <strong>format</strong>（压缩格式）者两个参数是必传的。其中，第三个餐宿是<strong>root_dir</strong>，用来指定创建压缩包的目录，默认是当前目录。</p><p><strong>python2 中，只有创建压缩包的函数，没有解压函数，python3 中，有解压函数，即 unpack_archive</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.unpack_archive(filename, extract_dir=<span class="literal">None</span>, <span class="built_in">format</span>=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>一般，shutil可以根据扩展名猜到压缩格式，不需要指定format函数</p><hr><h3 id="5-7-Python中执行外部命令"><a href="#5-7-Python中执行外部命令" class="headerlink" title="5.7 Python中执行外部命令"></a>5.7 Python中执行外部命令</h3><p>在Linux 操作中，总免不了在Python中执行shell命令，启动紫禁城，捕获命令的输出和退出状态码。目前就用subprocess模块，来创建和管理子进程。它提供了高层次的接口，用来替换os.system()，os.spawn*()，os.popen*()，popen2.*() 和commands.* 等模块与函数。</p><h4 id="subprocess模块的便利函数"><a href="#subprocess模块的便利函数" class="headerlink" title="subprocess模块的便利函数"></a>subprocess模块的便利函数</h4><p>包括call，check_call，check_output函数</p><p><strong>call 函数格式：subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>subprocess.call([<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;-l&#x27;</span>])</span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root   <span class="number">0</span> Sep <span class="number">11</span> <span class="number">22</span>:<span class="number">14</span> c.jpg</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root   <span class="number">0</span> Sep <span class="number">11</span> <span class="number">22</span>:<span class="number">14</span> d.jpg</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">231</span> Sep <span class="number">11</span> <span class="number">22</span>:<span class="number">14</span> history.py</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>subprocess.call(<span class="string">&quot;echo 123&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="comment">#如果设置了shell=True，则可以使用一个字符串命令，Python将先运行一个shell，再用shell来解释整个字符串</span></span><br></pre></td></tr></table></figure><p><strong>check_call 函数</strong>:  与call类似，区别在于异常情况下的返回形式不同，call成功返回0，不成功，返回非0；check_call则是成功返回0，<strong>不成功抛出subprocess.CalledProcessError异常。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>subprocess.call(<span class="string">&quot;exit 1&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>subprocess.check_call(<span class="string">&quot;exit 1&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/usr/lib64/python2.7/subprocess.py&quot;</span>, line <span class="number">542</span>, <span class="keyword">in</span> check_call</span><br><span class="line">    <span class="keyword">raise</span> CalledProcessError(retcode, cmd)</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">&#x27;exit 1&#x27;</span> returned non-zero exit status <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>check_output函数</strong>：call和check_call是直接将命令的输出结果打印到命令行终端，但是如果要进一步操作获取结果，或者将输出打印到日志文件中，可用check_output函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>output = subprocess.check_output([<span class="string">&#x27;df&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(output)</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   47G  <span class="number">6.0</span>G   42G  <span class="number">13</span>% /</span><br><span class="line">devtmpfs                 897M     <span class="number">0</span>  897M   <span class="number">0</span>% /dev</span><br><span class="line">tmpfs                    912M     <span class="number">0</span>  912M   <span class="number">0</span>% /dev/shm</span><br><span class="line">tmpfs                    912M   17M  895M   <span class="number">2</span>% /run</span><br><span class="line">tmpfs                    912M     <span class="number">0</span>  912M   <span class="number">0</span>% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  179M  836M  <span class="number">18</span>% /boot</span><br><span class="line">tmpfs                    183M  <span class="number">4.0</span>K  183M   <span class="number">1</span>% /run/user/<span class="number">42</span></span><br><span class="line">tmpfs                    183M   32K  183M   <span class="number">1</span>% /run/user/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = output.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">&#x27;Filesystem               Size  Used Avail Use% Mounted on&#x27;</span>, <span class="string">&#x27;/dev/mapper/centos-root   47G  6.0G   42G  13% /&#x27;</span>, <span class="string">&#x27;devtmpfs                 897M     0  897M   0% /dev&#x27;</span>, <span class="string">&#x27;tmpfs                    912M     0  912M   0% /dev/shm&#x27;</span>, <span class="string">&#x27;tmpfs                    912M   17M  895M   2% /run&#x27;</span>, <span class="string">&#x27;tmpfs                    912M     0  912M   0% /sys/fs/cgroup&#x27;</span>, <span class="string">&#x27;/dev/sda1               1014M  179M  836M  18% /boot&#x27;</span>, <span class="string">&#x27;tmpfs                    183M  4.0K  183M   1% /run/user/42&#x27;</span>, <span class="string">&#x27;tmpfs                    183M   32K  183M   1% /run/user/0&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> lines[<span class="number">1</span>:-<span class="number">1</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> line:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(line.split()[-<span class="number">2</span>])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">13</span>%</span><br><span class="line"><span class="number">0</span>%</span><br><span class="line"><span class="number">0</span>%</span><br><span class="line"><span class="number">2</span>%</span><br><span class="line"><span class="number">0</span>%</span><br><span class="line"><span class="number">18</span>%</span><br><span class="line"><span class="number">1</span>%</span><br><span class="line"><span class="number">1</span>%</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>check_output函数通过返回值来返回命令的执行结果，但是不会返回退出状态码表示异常，因此，可以通过抛出一个subprocess.CalledProcessError异常来表示命令执行出错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    output = subprocess.check_out([<span class="string">&#x27;cmd&#x27;</span>,<span class="string">&#x27;arg1&#x27;</span>,<span class="string">&#x27;arg2&#x27;</span>])</span><br><span class="line"><span class="keyword">except</span> subprocess.CallProcessError <span class="keyword">as</span> e:</span><br><span class="line">    output = e.output</span><br><span class="line">    code = e.returncode</span><br><span class="line"><span class="comment">#默认只捕获命令的标准输出，若想捕获错误输出，需重定向</span></span><br><span class="line">output = subprocess.check_output([<span class="string">&#x27;cmd&#x27;</span>,<span class="string">&#x27;arg1&#x27;</span>,<span class="string">&#x27;arg2&#x27;</span>], stderr=subprocess.STDOUT)</span><br></pre></td></tr></table></figure><h4 id="subprocess-模块的Popen类"><a href="#subprocess-模块的Popen类" class="headerlink" title="subprocess 模块的Popen类"></a><strong>subprocess 模块的Popen类</strong></h4><p>subprocess提供的便利函数，都是对Popen类的封装，当便利函数无法满足业务的需求时，也可以直接使用Popen类。</p><p>Popen对象创建后，子进程便会运行，Popen类提供了若干方法来控制子进程的运行，包括：</p><p>wait    等待子进程结束</p><p>poll    检查子进程状态</p><p>kill     给子进程发送SIGKILL信号中止子进程</p><p>send_signal    向子进程发送信号</p><p>terminate    给子进程发送SIGTERM 终止子进程</p><p>communicate    与子进程交互——包括输入数据，获取自命令的标准输出和错误输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如下函数对Popen执行shell命令进行封装,成功，返回状态码和标准输出，失败，返回状态码和错误输出</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute_cmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    p = subprocess.Popen(cmd,</span><br><span class="line">    shell=<span class="literal">True</span>,</span><br><span class="line">                        stdin=subprocess.PIPE,</span><br><span class="line">                        stdout=subprocess.PIPE,</span><br><span class="line">                        stderr=subprocess.PIPE)</span><br><span class="line">    stdout, stderr = p.communicate()</span><br><span class="line">    <span class="keyword">if</span> p.returncode != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> p.returncode, stderr</span><br><span class="line">    <span class="keyword">return</span> p.returncode, stdout</span><br><span class="line"><span class="comment">#可以从此使用subprocess在Python中执行复杂的linux命令</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-8-综合案例：使用Python部署MongoDB"><a href="#5-8-综合案例：使用Python部署MongoDB" class="headerlink" title="5.8 综合案例：使用Python部署MongoDB"></a>5.8 综合案例：使用Python部署MongoDB</h3><hr><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 3 命令行工具《Python Linux 系统管理与自动化运维》</title>
      <link href="/2019/09/08/python/administration/chapter03/"/>
      <url>/2019/09/08/python/administration/chapter03/</url>
      
        <content type="html"><![CDATA[<h3 id="3-打造命令行工具"><a href="#3-打造命令行工具" class="headerlink" title="3 打造命令行工具"></a>3 打造命令行工具</h3><p>在没有一个能满足需求的命令行工具时，编写一个命令行工具很重要，Python既可以当脚本语言，也可以用来编写大型服务，作为脚本语言的Python，提供了很多功能来编写命令行工具，用来替代Shell脚本，同时也有很多Python的开源项目，能够帮助我们快速构建命令行工具。</p><span id="more"></span><h4 id="3-1-与命令行相关的Python语言"><a href="#3-1-与命令行相关的Python语言" class="headerlink" title="3.1 与命令行相关的Python语言"></a>3.1 与命令行相关的Python语言</h4><h5 id="使用-sys-argv-获取命令行参数"><a href="#使用-sys-argv-获取命令行参数" class="headerlink" title="使用 sys.argv 获取命令行参数"></a><strong>使用 sys.argv 获取命令行参数</strong></h5><p>sys.argv 列表，保存了所有的命令行参数，其中第一个元素时命令行程序的名称，如果有其他的命令行参数，则所有参数都以字符串的形式保存到 sys.argv 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment">#为了避免直接运行程序，访问sys.argv[1] 出现索引越界的错误，添加一个空的字符串</span></span><br><span class="line">    sys.argv.append(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">        <span class="keyword">raise</span> SystemExit(filename + <span class="string">&#x27; does not exists&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> os.access(filename, os.R_OK):</span><br><span class="line">        <span class="keyword">raise</span> SystemExit(filename + <span class="string">&#x27; is not accessible&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(filename + <span class="string">&#x27; is accessible&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h5 id="使用sys-stdin-和fileinput读取标准输入"><a href="#使用sys-stdin-和fileinput读取标准输入" class="headerlink" title="使用sys.stdin 和fileinput读取标准输入"></a>使用sys.stdin 和fileinput读取标准输入</h5><p>shell脚本有一个其他脚本语言都没有的优点——管道！Python语言中使用它，可以结合Shell管道和Python语言的优势。</p><p>sys库中，有三个文件描述符，分别是stdin、stdout和stderr，其中，sys.stdin是一个普通的文件对象，可以调用sys.stdin.read 函数读取标准输入中的所有内容，调用sys.stdin.readlines 函数将标准输入的内容读取到一个列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content</span>():</span></span><br><span class="line">    <span class="keyword">return</span> sys.stdin.readlines()</span><br><span class="line"><span class="built_in">print</span>(get_content())</span><br></pre></td></tr></table></figure><p>Python 语言有比 awk 应用领域广泛、可读性好、功能强大、愈发清晰等诸多优点，完全可以在Linux下使用Python替代awk进行数据处理。</p><p><strong>fileinput库，可以进行多文件处理</strong>，默认遍历sys.argv[1:]列表，并按行依次读取列表中的文件，如果列表为空，则默认读取标准输入中的内容。</p><p>fileinput 读取文件比sys.stdin更灵活，既可以从文件中读，也可以从标准输入中读取。</p><p>其中常用的方法有：</p><p>filename：    当前正在读取的文件名</p><p>fileno：    文件的描述符</p><p>filelineno：    正在读取的行是当前文件的第几行</p><p>isfirstline：    正在读取的行是否为当前文件的第一行</p><p>isstdin：    正在读取文件还是标准输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[baiyongan@bya Python_exercise]$ cat read_from_fileinput.py </span><br><span class="line">from __future__ import print_function</span><br><span class="line">import fileinput</span><br><span class="line"></span><br><span class="line">for line in fileinput.input():</span><br><span class="line">    meta = [fileinput.filename(), fileinput.fileno(), fileinput.filelineno(), fileinput.isfirstline(), fileinput.isstdin()]</span><br><span class="line">print(*meta, end=&quot;&quot;)</span><br><span class="line">print(line, end=&quot;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="使用SystemExit-异常打印错误信息"><a href="#使用SystemExit-异常打印错误信息" class="headerlink" title="使用SystemExit 异常打印错误信息"></a>使用SystemExit 异常打印错误信息</h5><p>Python脚本执行出错时，向错误输出中输出错误信息，并且以非零的返回码退出程序。这个需求可以通过抛出一个SystemExit异常来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stderr.write(<span class="string">&#x27;Error Message&#x27;</span>)</span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="使用getpass-库读取密码"><a href="#使用getpass-库读取密码" class="headerlink" title="使用getpass 库读取密码"></a>使用getpass 库读取密码</h5><p>非常简单，只有getuser 和getoass函数，getpass不会将密码显示在命令行下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line">user = getpass.getuser()</span><br><span class="line">passwd = getpass.getpass(<span class="string">&#x27;your passwd: &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(user,passwd)</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-使用ConfigParse-解析配置文件"><a href="#3-2-使用ConfigParse-解析配置文件" class="headerlink" title="3.2 使用ConfigParse 解析配置文件"></a>3.2 使用ConfigParse 解析配置文件</h4><p>应用场景：管理git时，会读取<del>/.git/config、MySQL 数据库客户端默认使用/etc/mysql/my.cnf、pip配置文件位于</del>/.pip/pip.conf文件中。</p><p>配置文件的好处是，配置成功后，不需要每次使用时都指定相应的参数。ini格式的配置文件，与变成语言无关，可读性强，易于处理。典型格式是一到多个章节（section），每个章节下包含一到多个选项（option）。</p><hr><h4 id="3-3-使用-argparse-解析命令行参数"><a href="#3-3-使用-argparse-解析命令行参数" class="headerlink" title="3.3 使用 argparse 解析命令行参数"></a>3.3 使用 argparse 解析命令行参数</h4><hr><h4 id="3-4-使用-logging-记录日志"><a href="#3-4-使用-logging-记录日志" class="headerlink" title="3.4 使用 logging 记录日志"></a>3.4 使用 logging 记录日志</h4><hr><h4 id="3-5-与命令行相关的开源项目"><a href="#3-5-与命令行相关的开源项目" class="headerlink" title="3.5 与命令行相关的开源项目"></a>3.5 与命令行相关的开源项目</h4><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令行工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4 文本处理 《Python Linux 系统管理与自动化运维》</title>
      <link href="/2019/09/07/python/administration/chapter04/"/>
      <url>/2019/09/07/python/administration/chapter04/</url>
      
        <content type="html"><![CDATA[<h2 id="4-文本处理"><a href="#4-文本处理" class="headerlink" title="4 文本处理"></a>4 文本处理</h2><p>Linux下的文本处理工具有：<strong>grep、awk、sed、wc、tr、cut、cat</strong> 等。</p><p>但其<strong>限制</strong>一般有如下</p><p>1）在Windows下处理很不方便；</p><p>2）对于中文处理支持不友好；</p><p>3）大量依赖正则表达式，而RE 的学习曲线比较陡峭。</p><p>而python内嵌的字符类型包含大量的文本处理函数，标准库对文本处理提供了很好支持，此外，一些开源项目对Python处理复杂文本提供支持，如模板处理、解析xml和html的标准库和第三方库等。</p><p>so， 人生苦短，我用python ~ </p><span id="more"></span><hr><h3 id="4-1-字符串常量"><a href="#4-1-字符串常量" class="headerlink" title="4.1 字符串常量"></a>4.1 字符串常量</h3><h4 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h4><p><strong>Python中不区分字符和字符串</strong>，可以使用单引号、双引号来定义字符串。</p><p>在编程语言中，使用 \  来定义转义字符，在 URL中，使用%定义转义字符。</p><p>除了使用转义符外，还可以使用原始字符串（raw string） ，原始字符串会一直所有转义。</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">r&quot;c:\next&quot;</span></span><br><span class="line"><span class="built_in">print</span>(path)</span><br></pre></td></tr></table></figure><p><strong>多行字符串</strong>：使用三个引号定义的字符串，起止都是三个单引号或三个双引号。其中，所有的引号、换行符、制表符等特殊字符，都会被认为使普通字符。</p><p>Python中，两个相连的字符串会自动组成一个新的字符串。</p><h4 id="字符串是不可变的有序集合"><a href="#字符串是不可变的有序集合" class="headerlink" title="字符串是不可变的有序集合"></a>字符串是不可变的有序集合</h4><p>Python语言字符串的两大特点：</p><p><strong>1）字符串不可变</strong>，无法直接对其修改。</p><ul><li>（但是可以通过字符运算、切片操作、格式化表达式和字符串调用等创建新字符串，再赋值给最初的变量名）</li></ul><p><strong>2）字符串是字符的有序集合。</strong></p><ul><li>可通过下标和切片进行访问。</li><li>下标每次只能访问一个元素，切片每次可以访问一个范围，可指定切片操作的起点、终点和步长。</li></ul><p>Tips：</p><ul><li>因为每个新的字符串会占用一块独立内存，因此，<strong>操作字符串时，尽量避免产生太多不必要的中间结果。</strong></li><li>尽量不要同时制定切片操作的起点、终点和步长，可读性不好。<ul><li>如 置逆字符串操作，使用<strong>s[: : -1]</strong> 不如 <strong>‘  ‘.join(reversed(s))**</strong></li></ul></li></ul><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p>Python中，与字符串处理相关的方法有两大类：</p><ul><li>一类可用于多种类型的<strong>通用操作</strong>，以内置函数或表达式方式提供；</li><li>Python中，字符串、列表和元组具有一些共性，即都是元素的有序集合。</li><li>一类<strong>只作用于字符串</strong>的<strong>特定类型</strong>操作，以方法调用的形式提供。</li></ul><p><strong>通用操作</strong></p><p>下标访问 s[0]、序列切片、求长度 len[s] 、判断存在与否 ‘x’ in s</p><p><strong>与大小写相关的方法</strong></p><p>upper  lower</p><p>isupper  islower</p><p>swapcase ：大换小，小换大</p><p>capitalize：首字母换为大写</p><p>istitle：判断字符串是不是标题</p><p>应用：判断用户输入是否为yes，统一将Yes，YES，yeS等换为yes</p><p><strong>判断类方法</strong></p><p>s.isalpha</p><p>s.isdecimal</p><p>s.isalnum</p><p>s.isspace  包含空格、制表符、换行符，且非空，返回True</p><p><strong>字符串方法 startwith 和 endswith</strong></p><p>startswith</p><p>endswith</p><p>实际工作中，更多用前缀匹配，如日志的处理，查看所有MongoDB文件大小，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">mongod_logs = [item <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(<span class="string">&#x27;/var/mongo/log&#x27;</span>) <span class="keyword">if</span> item.startswith(<span class="string">&#x27;mongod.log&#x27;</span>)]</span><br><span class="line">sum_size = <span class="built_in">sum</span>(os.path.getsize(os.path.join(<span class="string">&#x27;/var/mongo/log&#x27;</span>, item)) <span class="keyword">for</span> item <span class="keyword">in</span> mongod_logs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>查找类函数</strong></p><p>find：查找字串出现在字符串中的位置，失败则返回 -1，还可以指定查找范围</p><p>index：查找失败，抛出ValueError 异常</p><p>rfind：与find类似，是从后向前查</p><p>rindex：与index类似，从后向前查</p><p>对于判断一个字符串是否是另一个字符串的子串，正确做法是用in 和 not in。</p><p><strong>字符串操作方法</strong></p><p>join 函数：连接</p><p>split 函数：拆分</p><p>strip 函数：两边裁剪（多用于去除两边的空白字符，也可传递被裁剪参数）；lstrip：左裁剪；rstrip：右裁剪</p><p>replace 函数：替换子串</p><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><p>Python中，存在两种格式化字符串的方法，<strong>即% 表达式和format函数</strong>，format才是未来趋势。</p><p>通过{} 表示一个占位符，Python会将format函数参数依次传递给 {} 占位符，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&#123;&#125; is better than &#123;&#125;. &#123;&#125; is better than &#123;&#125;.&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Beautiful&#x27;</span>, <span class="string">&#x27;ugly&#x27;</span>, <span class="string">&#x27;Explicit&#x27;</span>, <span class="string">&#x27;implicit&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Beautiful is better than ugly. Explicit is better than implicit.&#x27;</span></span><br></pre></td></tr></table></figure><p>也可以通过下标方式访问format函数参数，即{1}，{2}等，或者{keyword1}，{keyword2}等；</p><p>也可以直接访问对象的属性，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>, <span class="string">&#x27;name age sex&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xm = Person(<span class="string">&#x27;Roger&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;p.name&#125; is &#123;p.age&#125; old this year&quot;</span>.<span class="built_in">format</span>(p=xm)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Roger is 25 old this year&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="4-2-正则表达式"><a href="#4-2-正则表达式" class="headerlink" title="4.2 正则表达式"></a>4.2 正则表达式</h3><p>原则：大部分情况下，用Python 内置的字符串处理函数解决文本问题，少数情况下，用简单的正则处理。</p><h4 id="正则语法"><a href="#正则语法" class="headerlink" title="正则语法"></a><strong>正则语法</strong></h4><p><strong>正则表达式的核心</strong>——<strong>定义模式以及熟悉模式的定义规则。</strong>由普通文本和具有特殊意义的符号组成。</p><p>如：</p><p>匹配所有单词：     ？[a-zA-Z]+</p><p>匹配IP地址：         [0-9]{1,3}\. [0-9]{1,3}\. [0-9]{1,3}\. [0-9]{1,3}</p><h4 id="利用re库处理正则表达式"><a href="#利用re库处理正则表达式" class="headerlink" title="利用re库处理正则表达式"></a><strong>利用re库处理正则表达式</strong></h4><p>两种方式：一是直接使用re中的函数；一是创建一个特定模式编译的正则表达式对象，然后使用这个对象中的方法。</p><p>数据量大，建议用编译后的方式，更省时。如seq 10000000 &gt;&gt; <strong>data.txt</strong>，读取文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@bya Python_exercise]# seq 10000000 &gt;&gt; data.txt</span><br><span class="line">[root@bya Python_exercise]# ll -h</span><br><span class="line">total 76M</span><br><span class="line">-rw-r--r-- 1 root root 76M Sep  8 16:59 data.txt</span><br><span class="line">-rw-r--r-- 1 root root 206 Sep  8 17:05 re_compile.py</span><br><span class="line">-rw-r--r-- 1 root root 182 Sep  8 17:04 re_nocompile.py</span><br><span class="line">[root@bya Python_exercise]# cat re_nocompile.py </span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    pattern = &quot;[0-9]+&quot;</span><br><span class="line">    with open(&#x27;data.txt&#x27;) as f:</span><br><span class="line">        for line in f:</span><br><span class="line">            re.findall(pattern, line)</span><br><span class="line">    </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line">[root@bya Python_exercise]# cat re_compile.py </span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    pattern = &quot;[0-9]+&quot;</span><br><span class="line">    re_obj = re.compile(pattern)</span><br><span class="line">    with open(&#x27;data.txt&#x27;) as f:</span><br><span class="line">        for line in f:</span><br><span class="line">            re_obj.findall(line)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line">[root@bya Python_exercise]# time python re_nocompile.py </span><br><span class="line"></span><br><span class="line">real0m9.870s</span><br><span class="line">user0m9.818s</span><br><span class="line">sys0m0.046s</span><br><span class="line">[root@bya Python_exercise]# time python re_compile.py </span><br><span class="line"></span><br><span class="line">real0m4.762s</span><br><span class="line">user0m4.741s</span><br><span class="line">sys0m0.010s</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常用的re方法"><a href="#常用的re方法" class="headerlink" title="常用的re方法"></a>常用的re方法</h4><p><strong>匹配类函数</strong></p><p>re.findall() 返回匹配的所有结果</p><p>re.finditer() 同样返回匹配的所有结果，返回一个迭代器。</p><p>re.match() ，类似于字符串中的startwith函数，但能用正则，更强大。</p><p>re.search()，在任意地方进行匹配，但只查找第一次匹配，而match仅对开始部分匹配。</p><p>match和search 共同点——匹配成功，返回一个SRE_Match类型的对象；匹配失败，返回一个None。</p><p><strong>修改类函数</strong></p><p>re.sub(), 类似于字符串中的replace函数，能用正则，更强大。</p><p>re.split(),类似于字符串中的split函数，能用正则，更强大，能制定多个分隔符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&quot;MySQL slave binlog position: master host &#x27;10.172.33.45&#x27;,filename &#x27;mysql-bin.000002&#x27;, position &#x27;52342359&#x27;&quot;</span></span><br><span class="line">result = re.split(<span class="string">r&quot;[&#x27;:,\s]+&quot;</span>, text.strip(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><strong>大小写不敏感</strong></p><p>查找或替换时，常要忽略字符大小写</p><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.findall(<span class="string">&#x27;python&#x27;</span>, text, flags=re.IGNORECASE)</span><br><span class="line">re.sub(<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;snake&#x27;</span>, text, flags=re.IGNORECASE)</span><br></pre></td></tr></table></figure><p><strong>非贪婪匹配</strong></p><p>默认使用贪婪匹配，即匹配最长的字符串，如果使用非贪婪匹配，在匹配字符串时，加上一个<strong>？</strong></p><hr><h3 id="4-3-字符集编码"><a href="#4-3-字符集编码" class="headerlink" title="4.3 字符集编码"></a>4.3 字符集编码</h3><hr><h3 id="4-4Jinja2-模板"><a href="#4-4Jinja2-模板" class="headerlink" title="4.4Jinja2 模板"></a>4.4Jinja2 模板</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本处理 </tag>
            
            <tag> 字符集编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 推导式</title>
      <link href="/2019/09/06/python/fundation/comprehension/"/>
      <url>/2019/09/06/python/fundation/comprehension/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="推导式-解析式"><a href="#推导式-解析式" class="headerlink" title="推导式(解析式)"></a>推导式(解析式)</h2><p><strong>推导式comprehensions</strong>（又称解析式），是Python的一种独有特性。</p><p>推导式是可以从一个数据序列构建另一个新的数据序列的结构体。 共有三种推导，在Python2和3中都有支持：</p><ul><li><strong>列表(list)推导式</strong></li><li><strong>字典(dict)推导式</strong></li><li><strong>集合(set)推导式</strong></li></ul><span id="more"></span><hr><h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h2><p>python的 range() 函数可用来创建一个整数列表，一般用在 for 循环中.</p><p><strong>range()语法:</strong>  </p><p><strong>range(start, stop[, step])</strong></p><p>start:    计数从start开始,默认是从0开始(闭区间),如:range(5)等价于range(0,5).</p><p>stop:    计数到stop结束,但不包括stop(开区间).如:range(0,5)是[0, 1, 2, 3, 4],不包含5.</p><p>step:    步长,相邻两个值的差值,默认为1.如:range(0,5)相当于range(0, 5, 1).</p><p>列表推导式是通过一个可迭代对象来生成列表的, range()可以说是列表推导式中最常用的可迭代对象了.对列表推导式来说, range() 是其中的精髓之一.</p><hr><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p><strong>基本格式为：</strong></p><p><strong>[表达式 for 变量 in 列表] 或者   [表达式 for 变量 in 列表 if 条件]</strong></p><p> <strong>具体可分为两种：</strong></p><p> <strong>[x for x in data if condition]</strong></p><p>此处if主要起条件判断作用，data数据中只有满足if条件的才会被留下，最后统一生成为一个数据列表。</p><p><strong>[exp1 if condition else exp2 for x in data]</strong></p><p>此处if…else主要起赋值作用，当data中的数据满足if条件时将其做exp1处理，否则按照exp2处理，最后统一生成为一个数据列表。</p><p> 例1：过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(new_names)</span><br><span class="line">[<span class="string">&#x27;ALICE&#x27;</span>, <span class="string">&#x27;JERRY&#x27;</span>, <span class="string">&#x27;WENDY&#x27;</span>, <span class="string">&#x27;SMITH&#x27;</span>]</span><br></pre></td></tr></table></figure><p>例2：生成间隔5分钟的时间列表序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>time = [<span class="string">&#x27;%.2d:%.2d&#x27;</span>%(h,m )<span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>) <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(time)</span><br><span class="line">[<span class="string">&#x27;00:00&#x27;</span>, <span class="string">&#x27;00:05&#x27;</span>, <span class="string">&#x27;00:10&#x27;</span>, <span class="string">&#x27;00:15&#x27;</span>, <span class="string">&#x27;00:20&#x27;</span>, <span class="string">&#x27;00:25&#x27;</span>, <span class="string">&#x27;00:30&#x27;</span>, <span class="string">&#x27;00:35&#x27;</span>, <span class="string">&#x27;00:40&#x27;</span>, <span class="string">&#x27;00:45&#x27;</span>, <span class="string">&#x27;00:50&#x27;</span>, <span class="string">&#x27;00:55&#x27;</span>, <span class="string">&#x27;01:00&#x27;</span>, <span class="string">&#x27;01:05&#x27;</span>, <span class="string">&#x27;01:10&#x27;</span>, <span class="string">&#x27;01:15&#x27;</span>, <span class="string">&#x27;01:20&#x27;</span>, <span class="string">&#x27;01:25&#x27;</span>, <span class="string">&#x27;01:30&#x27;</span>, <span class="string">&#x27;01:35&#x27;</span>, <span class="string">&#x27;01:40&#x27;</span>, <span class="string">&#x27;01:45&#x27;</span>, <span class="string">&#x27;01:50&#x27;</span>, <span class="string">&#x27;01:55&#x27;</span>, <span class="string">&#x27;02:00&#x27;</span>, <span class="string">&#x27;02:05&#x27;</span>, <span class="string">&#x27;02:10&#x27;</span>, <span class="string">&#x27;02:15&#x27;</span>, <span class="string">&#x27;02:20&#x27;</span>, <span class="string">&#x27;02:25&#x27;</span>, <span class="string">&#x27;02:30&#x27;</span>, <span class="string">&#x27;02:35&#x27;</span>, <span class="string">&#x27;02:40&#x27;</span>, <span class="string">&#x27;02:45&#x27;</span>, <span class="string">&#x27;02:50&#x27;</span>, <span class="string">&#x27;02:55&#x27;</span>, <span class="string">&#x27;03:00&#x27;</span>, <span class="string">&#x27;03:05&#x27;</span>, <span class="string">&#x27;03:10&#x27;</span>, <span class="string">&#x27;03:15&#x27;</span>, <span class="string">&#x27;03:20&#x27;</span>, <span class="string">&#x27;03:25&#x27;</span>, <span class="string">&#x27;03:30&#x27;</span>, <span class="string">&#x27;03:35&#x27;</span>, <span class="string">&#x27;03:40&#x27;</span>, <span class="string">&#x27;03:45&#x27;</span>, <span class="string">&#x27;03:50&#x27;</span>, <span class="string">&#x27;03:55&#x27;</span>, <span class="string">&#x27;04:00&#x27;</span>, <span class="string">&#x27;04:05&#x27;</span>, <span class="string">&#x27;04:10&#x27;</span>, <span class="string">&#x27;04:15&#x27;</span>, <span class="string">&#x27;04:20&#x27;</span>, <span class="string">&#x27;04:25&#x27;</span>, <span class="string">&#x27;04:30&#x27;</span>, <span class="string">&#x27;04:35&#x27;</span>, <span class="string">&#x27;04:40&#x27;</span>, <span class="string">&#x27;04:45&#x27;</span>, <span class="string">&#x27;04:50&#x27;</span>, <span class="string">&#x27;04:55&#x27;</span>, <span class="string">&#x27;05:00&#x27;</span>, <span class="string">&#x27;05:05&#x27;</span>, <span class="string">&#x27;05:10&#x27;</span>, <span class="string">&#x27;05:15&#x27;</span>, <span class="string">&#x27;05:20&#x27;</span>, <span class="string">&#x27;05:25&#x27;</span>, <span class="string">&#x27;05:30&#x27;</span>, <span class="string">&#x27;05:35&#x27;</span>, <span class="string">&#x27;05:40&#x27;</span>, <span class="string">&#x27;05:45&#x27;</span>, <span class="string">&#x27;05:50&#x27;</span>, <span class="string">&#x27;05:55&#x27;</span>, <span class="string">&#x27;06:00&#x27;</span>, <span class="string">&#x27;06:05&#x27;</span>, <span class="string">&#x27;06:10&#x27;</span>, <span class="string">&#x27;06:15&#x27;</span>, <span class="string">&#x27;06:20&#x27;</span>, <span class="string">&#x27;06:25&#x27;</span>, <span class="string">&#x27;06:30&#x27;</span>, <span class="string">&#x27;06:35&#x27;</span>, <span class="string">&#x27;06:40&#x27;</span>, <span class="string">&#x27;06:45&#x27;</span>, <span class="string">&#x27;06:50&#x27;</span>, <span class="string">&#x27;06:55&#x27;</span>, <span class="string">&#x27;07:00&#x27;</span>, <span class="string">&#x27;07:05&#x27;</span>, <span class="string">&#x27;07:10&#x27;</span>, <span class="string">&#x27;07:15&#x27;</span>, <span class="string">&#x27;07:20&#x27;</span>, <span class="string">&#x27;07:25&#x27;</span>, <span class="string">&#x27;07:30&#x27;</span>, <span class="string">&#x27;07:35&#x27;</span>, <span class="string">&#x27;07:40&#x27;</span>, <span class="string">&#x27;07:45&#x27;</span>, <span class="string">&#x27;07:50&#x27;</span>, <span class="string">&#x27;07:55&#x27;</span>, <span class="string">&#x27;08:00&#x27;</span>, <span class="string">&#x27;08:05&#x27;</span>, <span class="string">&#x27;08:10&#x27;</span>, <span class="string">&#x27;08:15&#x27;</span>, <span class="string">&#x27;08:20&#x27;</span>, <span class="string">&#x27;08:25&#x27;</span>, <span class="string">&#x27;08:30&#x27;</span>, <span class="string">&#x27;08:35&#x27;</span>, <span class="string">&#x27;08:40&#x27;</span>, <span class="string">&#x27;08:45&#x27;</span>, <span class="string">&#x27;08:50&#x27;</span>, <span class="string">&#x27;08:55&#x27;</span>, <span class="string">&#x27;09:00&#x27;</span>, <span class="string">&#x27;09:05&#x27;</span>, <span class="string">&#x27;09:10&#x27;</span>, <span class="string">&#x27;09:15&#x27;</span>, <span class="string">&#x27;09:20&#x27;</span>, <span class="string">&#x27;09:25&#x27;</span>, <span class="string">&#x27;09:30&#x27;</span>, <span class="string">&#x27;09:35&#x27;</span>, <span class="string">&#x27;09:40&#x27;</span>, <span class="string">&#x27;09:45&#x27;</span>, <span class="string">&#x27;09:50&#x27;</span>, <span class="string">&#x27;09:55&#x27;</span>, <span class="string">&#x27;10:00&#x27;</span>, <span class="string">&#x27;10:05&#x27;</span>, <span class="string">&#x27;10:10&#x27;</span>, <span class="string">&#x27;10:15&#x27;</span>, <span class="string">&#x27;10:20&#x27;</span>, <span class="string">&#x27;10:25&#x27;</span>, <span class="string">&#x27;10:30&#x27;</span>, <span class="string">&#x27;10:35&#x27;</span>, <span class="string">&#x27;10:40&#x27;</span>, <span class="string">&#x27;10:45&#x27;</span>, <span class="string">&#x27;10:50&#x27;</span>, <span class="string">&#x27;10:55&#x27;</span>, <span class="string">&#x27;11:00&#x27;</span>, <span class="string">&#x27;11:05&#x27;</span>, <span class="string">&#x27;11:10&#x27;</span>, <span class="string">&#x27;11:15&#x27;</span>, <span class="string">&#x27;11:20&#x27;</span>, <span class="string">&#x27;11:25&#x27;</span>, <span class="string">&#x27;11:30&#x27;</span>, <span class="string">&#x27;11:35&#x27;</span>, <span class="string">&#x27;11:40&#x27;</span>, <span class="string">&#x27;11:45&#x27;</span>, <span class="string">&#x27;11:50&#x27;</span>, <span class="string">&#x27;11:55&#x27;</span>, <span class="string">&#x27;12:00&#x27;</span>, <span class="string">&#x27;12:05&#x27;</span>, <span class="string">&#x27;12:10&#x27;</span>, <span class="string">&#x27;12:15&#x27;</span>, <span class="string">&#x27;12:20&#x27;</span>, <span class="string">&#x27;12:25&#x27;</span>, <span class="string">&#x27;12:30&#x27;</span>, <span class="string">&#x27;12:35&#x27;</span>, <span class="string">&#x27;12:40&#x27;</span>, <span class="string">&#x27;12:45&#x27;</span>, <span class="string">&#x27;12:50&#x27;</span>, <span class="string">&#x27;12:55&#x27;</span>, <span class="string">&#x27;13:00&#x27;</span>, <span class="string">&#x27;13:05&#x27;</span>, <span class="string">&#x27;13:10&#x27;</span>, <span class="string">&#x27;13:15&#x27;</span>, <span class="string">&#x27;13:20&#x27;</span>, <span class="string">&#x27;13:25&#x27;</span>, <span class="string">&#x27;13:30&#x27;</span>, <span class="string">&#x27;13:35&#x27;</span>, <span class="string">&#x27;13:40&#x27;</span>, <span class="string">&#x27;13:45&#x27;</span>, <span class="string">&#x27;13:50&#x27;</span>, <span class="string">&#x27;13:55&#x27;</span>, <span class="string">&#x27;14:00&#x27;</span>, <span class="string">&#x27;14:05&#x27;</span>, <span class="string">&#x27;14:10&#x27;</span>, <span class="string">&#x27;14:15&#x27;</span>, <span class="string">&#x27;14:20&#x27;</span>, <span class="string">&#x27;14:25&#x27;</span>, <span class="string">&#x27;14:30&#x27;</span>, <span class="string">&#x27;14:35&#x27;</span>, <span class="string">&#x27;14:40&#x27;</span>, <span class="string">&#x27;14:45&#x27;</span>, <span class="string">&#x27;14:50&#x27;</span>, <span class="string">&#x27;14:55&#x27;</span>, <span class="string">&#x27;15:00&#x27;</span>, <span class="string">&#x27;15:05&#x27;</span>, <span class="string">&#x27;15:10&#x27;</span>, <span class="string">&#x27;15:15&#x27;</span>, <span class="string">&#x27;15:20&#x27;</span>, <span class="string">&#x27;15:25&#x27;</span>, <span class="string">&#x27;15:30&#x27;</span>, <span class="string">&#x27;15:35&#x27;</span>, <span class="string">&#x27;15:40&#x27;</span>, <span class="string">&#x27;15:45&#x27;</span>, <span class="string">&#x27;15:50&#x27;</span>, <span class="string">&#x27;15:55&#x27;</span>, <span class="string">&#x27;16:00&#x27;</span>, <span class="string">&#x27;16:05&#x27;</span>, <span class="string">&#x27;16:10&#x27;</span>, <span class="string">&#x27;16:15&#x27;</span>, <span class="string">&#x27;16:20&#x27;</span>, <span class="string">&#x27;16:25&#x27;</span>, <span class="string">&#x27;16:30&#x27;</span>, <span class="string">&#x27;16:35&#x27;</span>, <span class="string">&#x27;16:40&#x27;</span>, <span class="string">&#x27;16:45&#x27;</span>, <span class="string">&#x27;16:50&#x27;</span>, <span class="string">&#x27;16:55&#x27;</span>, <span class="string">&#x27;17:00&#x27;</span>, <span class="string">&#x27;17:05&#x27;</span>, <span class="string">&#x27;17:10&#x27;</span>, <span class="string">&#x27;17:15&#x27;</span>, <span class="string">&#x27;17:20&#x27;</span>, <span class="string">&#x27;17:25&#x27;</span>, <span class="string">&#x27;17:30&#x27;</span>, <span class="string">&#x27;17:35&#x27;</span>, <span class="string">&#x27;17:40&#x27;</span>, <span class="string">&#x27;17:45&#x27;</span>, <span class="string">&#x27;17:50&#x27;</span>, <span class="string">&#x27;17:55&#x27;</span>, <span class="string">&#x27;18:00&#x27;</span>, <span class="string">&#x27;18:05&#x27;</span>, <span class="string">&#x27;18:10&#x27;</span>, <span class="string">&#x27;18:15&#x27;</span>, <span class="string">&#x27;18:20&#x27;</span>, <span class="string">&#x27;18:25&#x27;</span>, <span class="string">&#x27;18:30&#x27;</span>, <span class="string">&#x27;18:35&#x27;</span>, <span class="string">&#x27;18:40&#x27;</span>, <span class="string">&#x27;18:45&#x27;</span>, <span class="string">&#x27;18:50&#x27;</span>, <span class="string">&#x27;18:55&#x27;</span>, <span class="string">&#x27;19:00&#x27;</span>, <span class="string">&#x27;19:05&#x27;</span>, <span class="string">&#x27;19:10&#x27;</span>, <span class="string">&#x27;19:15&#x27;</span>, <span class="string">&#x27;19:20&#x27;</span>, <span class="string">&#x27;19:25&#x27;</span>, <span class="string">&#x27;19:30&#x27;</span>, <span class="string">&#x27;19:35&#x27;</span>, <span class="string">&#x27;19:40&#x27;</span>, <span class="string">&#x27;19:45&#x27;</span>, <span class="string">&#x27;19:50&#x27;</span>, <span class="string">&#x27;19:55&#x27;</span>, <span class="string">&#x27;20:00&#x27;</span>, <span class="string">&#x27;20:05&#x27;</span>, <span class="string">&#x27;20:10&#x27;</span>, <span class="string">&#x27;20:15&#x27;</span>, <span class="string">&#x27;20:20&#x27;</span>, <span class="string">&#x27;20:25&#x27;</span>, <span class="string">&#x27;20:30&#x27;</span>, <span class="string">&#x27;20:35&#x27;</span>, <span class="string">&#x27;20:40&#x27;</span>, <span class="string">&#x27;20:45&#x27;</span>, <span class="string">&#x27;20:50&#x27;</span>, <span class="string">&#x27;20:55&#x27;</span>, <span class="string">&#x27;21:00&#x27;</span>, <span class="string">&#x27;21:05&#x27;</span>, <span class="string">&#x27;21:10&#x27;</span>, <span class="string">&#x27;21:15&#x27;</span>, <span class="string">&#x27;21:20&#x27;</span>, <span class="string">&#x27;21:25&#x27;</span>, <span class="string">&#x27;21:30&#x27;</span>, <span class="string">&#x27;21:35&#x27;</span>, <span class="string">&#x27;21:40&#x27;</span>, <span class="string">&#x27;21:45&#x27;</span>, <span class="string">&#x27;21:50&#x27;</span>, <span class="string">&#x27;21:55&#x27;</span>, <span class="string">&#x27;22:00&#x27;</span>, <span class="string">&#x27;22:05&#x27;</span>, <span class="string">&#x27;22:10&#x27;</span>, <span class="string">&#x27;22:15&#x27;</span>, <span class="string">&#x27;22:20&#x27;</span>, <span class="string">&#x27;22:25&#x27;</span>, <span class="string">&#x27;22:30&#x27;</span>, <span class="string">&#x27;22:35&#x27;</span>, <span class="string">&#x27;22:40&#x27;</span>, <span class="string">&#x27;22:45&#x27;</span>, <span class="string">&#x27;22:50&#x27;</span>, <span class="string">&#x27;22:55&#x27;</span>, <span class="string">&#x27;23:00&#x27;</span>, <span class="string">&#x27;23:05&#x27;</span>, <span class="string">&#x27;23:10&#x27;</span>, <span class="string">&#x27;23:15&#x27;</span>, <span class="string">&#x27;23:20&#x27;</span>, <span class="string">&#x27;23:25&#x27;</span>, <span class="string">&#x27;23:30&#x27;</span>, <span class="string">&#x27;23:35&#x27;</span>, <span class="string">&#x27;23:40&#x27;</span>, <span class="string">&#x27;23:45&#x27;</span>, <span class="string">&#x27;23:50&#x27;</span>, <span class="string">&#x27;23:55&#x27;</span>]</span><br></pre></td></tr></table></figure><p>例3: 求(x,y),其中x是0-5之间的偶数，y是0-5之间的奇数组成的元祖列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">list</span> = [(x,y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">if</span> y%<span class="number">2</span> == <span class="number">1</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure><p>例4: 求M中斜线1,5,9组成的列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;M = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">&gt;&gt;&gt;list_1 = [M[x][x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M)) ]</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(list_1)</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><blockquote><blockquote><p>使用()生成generator：</p><p>将俩表推导式的[]改成()即可得到生成器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multiples = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(multiples))</span><br><span class="line"></span><br><span class="line">Output: &lt;<span class="built_in">type</span> <span class="string">&#x27;generator&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><hr><h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p><strong>基本格式为：</strong></p><p><strong>{ key:value for key, value in existing_data_structure }</strong></p><p> 这里和list有所不同，因位dict里面有两个关键的属性，key 和 value，但大同小异，我们现在的expression部分可以同时对 key 和 value 进行操作 :</p><p> 例1: 用字典推导式配合枚举的使用案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strings = [<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;is&#x27;</span>,<span class="string">&#x27;with&#x27;</span>,<span class="string">&#x27;if&#x27;</span>,<span class="string">&#x27;file&#x27;</span>,<span class="string">&#x27;exception&#x27;</span>,<span class="string">&#x27;shim&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span> = &#123;k:v <span class="keyword">for</span> v,k <span class="keyword">in</span> <span class="built_in">enumerate</span>(strings)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">dict</span>)</span><br><span class="line">&#123;<span class="string">&#x27;import&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;is&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;with&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;if&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;file&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;exception&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;shim&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;lucy&#x27;</span>: <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>上题的k是字符串，v是序列。如果我们更换k v：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strings = [<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;is&#x27;</span>,<span class="string">&#x27;with&#x27;</span>,<span class="string">&#x27;if&#x27;</span>,<span class="string">&#x27;file&#x27;</span>,<span class="string">&#x27;exception&#x27;</span>,<span class="string">&#x27;shim&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span> = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(strings)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">dict</span>)</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;import&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;is&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;with&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;if&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;file&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;exception&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;shim&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;lucy&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p> <strong>其中，enumerate（）函数参考：</strong><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.runoob.com%2Fpython%2Fpython-func-enumerate.html">https://www.runoob.com/python/python-func-enumerate.html</a></p><p>例2：源数据的key是字母的大小写混在一起，我们想统计同一个字母（不论大小写）的key所对应的键值对的和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">20</span>,<span class="string">&#x27;A&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;B&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line">num_frequency  = &#123;k.lower():nums.get(k.lower(),<span class="number">0</span>) + nums.get(k.upper(),<span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">for</span> k <span class="keyword">in</span> nums.keys() &#125;</span><br><span class="line"><span class="comment">#nums是字典，nums.get(k.lower(),0)的意思是在字典nums中查找小写Key</span></span><br><span class="line"><span class="comment">#找到了返回KEY对应的Value,否则返回参数0,nums.get(k.upper(),0)同上</span></span><br><span class="line"><span class="built_in">print</span>(num_frequency)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">15</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">23</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p><strong>基础格式为：</strong></p><p><strong>{ expression for item in Sequence if conditional }</strong></p><p> 其实集合推导式和list的推导式很像，但是既然是集合，肯定会配合利用Set的特有属性来实现我们的目的。</p><p>例1：首先，我们来看一个根据Set值唯一的特性的例子，我们有一个list叫names，用来存储名字，其中的数据很不规范，有大写，小写，还有重复的，我们想要去重并把名字的格式统一为首字母大写，实现方法便是用Set推导式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [ <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;JOHN&#x27;</span>, <span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;ALICE&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;JAMES&#x27;</span>,<span class="string">&#x27;jAMeS&#x27;</span> ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_names = &#123;n[<span class="number">0</span>].upper() + n[<span class="number">1</span>:].lower() <span class="keyword">for</span> n <span class="keyword">in</span> names&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(new_names)</span><br><span class="line">&#123;<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>[1] <a href="https://www.airpair.com/python/posts/python-comprehension-syntax">Python Tutorial: Comprehensions</a></p><p>[2] <a href="https://mp.weixin.qq.com/s?src=11&timestamp=1567785751&ver=1836&signature=GxW-PlO0utKuA76I6jg23WwqFXL5kI71lf9SoReUx-CJ613gpRwNtGiL0rXi0LeX2YIWM0KHVrxpbE3*tt6jrF3MvL6yLe3yQmWiF7bdXyyWjfXqVwt7VnZ2QPE-0-s0&new=1">Python常用的推导式</a></p><p>[3] <a href="https://www.jianshu.com/p/0a269715a742">python各种推导式（超级详细）</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推导式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python lambda 表达式</title>
      <link href="/2019/09/02/python/fundation/lambda/"/>
      <url>/2019/09/02/python/fundation/lambda/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda-函数的功能及用途"><a href="#Lambda-函数的功能及用途" class="headerlink" title="Lambda 函数的功能及用途"></a>Lambda 函数的功能及用途</h2><p>Lambda函数也叫匿名函数，即没有具体名称的函数，它允许快速定义单行函数，类似于C语言的宏，可以用在任何需要函数的地方。这有别于def定义的函数。 </p><p>lambda与def的区别：<br>        1）def创建的方法是有名称的，而lambda没有。<br>        2）lambda会返回一个函数对象，但这个对象不会赋给一个标识符，而def则会把函数对象赋值给一个变量（函数名）。<br>        3）lambda只是一个表达式，而def则是一个语句。<br>        4）lambda表达式” : “后面，只能有一个表达式，def则可以有多个。<br>        5）像if或for或print等语句不能用于lambda中，def可以。<br>        6）lambda一般用来定义简单的函数，而def可以定义复杂的函数。<br>        7）lambda函数不能共享给别的程序调用，def可以。 </p><span id="more"></span><h2 id="语法格式-lambda-argument-list-expression"><a href="#语法格式-lambda-argument-list-expression" class="headerlink" title="语法格式    lambda argument_list : expression"></a>语法格式    <strong>lambda argument_list : expression</strong></h2><p>其中，lambda是Python预留的<strong>关键字</strong>，argument_list和expression由<strong>用户自定义</strong>。</p><p>具体介绍如下。</p><p>这里的argument_list是<strong>参数列表</strong>。它的结构与Python中函数(function)的参数列表是一样的。具体来说，argument_list可以有非常多的形式。例如：</p><ul><li><p>a, b</p></li><li><p>a=1, b=2</p></li><li><p>*args</p></li><li><p>**kwargs</p></li><li><p>a, b=1, *args</p></li><li><p>空</p></li><li><p>……</p></li></ul><p>这里的expression是一个关于参数的<strong>表达式</strong>。表达式中出现的参数需要在argument_list中有定义，并且表达式只能是<strong>单行</strong>的。以下都是合法的表达式：</p><ul><li><p>1</p></li><li><p>None</p></li><li><p>a + b</p></li><li><p>sum(a)</p></li><li><p>1 if a &gt;10 else 0</p></li><li><p>……</p></li></ul><p>这里的 lambda argument_list: expression表示的是一个<strong>函数</strong>。这个函数叫做<strong>lambda函数</strong>。</p><h2 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a><strong>三个特性</strong></h2><ol><li>lambda函数是<strong>匿名</strong>的：所谓匿名函数，通俗地说就是没有名字的函数。lambda函数没有名字。</li><li>lambda函数有<strong>输入</strong>和<strong>输出</strong>：输入是传入到参数列表argument_list的值，输出是根据表达式expression计算得到的值。</li><li>lambda函数一般<strong>功能简单</strong>：单行expression决定了lambda函数不可能完成复杂的逻辑，只能完成非常简单的功能。</li></ol><p>下面是一些lambda函数示例：</p><ul><li>lambda x, y: x<em>y；函数输入是x和y，输出是它们的积x</em>y</li><li>lambda:None；函数没有输入参数，输出是None</li><li>lambda *args: sum(args); 输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)</li><li>lambda **kwargs: 1；输入是任意键值对参数，输出是1</li></ul><h2 id="四个用法"><a href="#四个用法" class="headerlink" title="四个用法"></a><strong>四个用法</strong></h2><p>在实际中，根据这个lambda函数应用场景的不同，可以将lambda函数的用法扩展为以下几种：</p><ul><li><strong>将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数。</strong></li></ul><p>例如，执行语句 add=lambda x, y: x+y，定义了加法函数lambda x, y: x+y，并将其赋值给变量add，这样变量add便成为具有加法功能的函数。例如，执行add(1,2)，输出为3。</p><ul><li><strong>将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换。</strong></li></ul><p>例如，为了把标准库time中的函数sleep的功能屏蔽(Mock)，我们可以在程序初始化时调用：time.sleep=lambda x : None。这样，在后续代码中调用time库的sleep函数将不会执行原有的功能。例如，执行time.sleep(3)时，程序不会休眠3秒钟，而是什么都不做。</p><ul><li><strong>将lambda函数作为其他函数的返回值，返回给调用者。</strong></li></ul><p>函数的返回值也可以是函数。例如return lambda x, y: x+y返回一个加法函数。这时，lambda函数实际上是定义在某个函数内部的函数，称之为嵌套函数，或者内部函数。对应的，将包含嵌套函数的函数称之为外部函数。内部函数能够访问外部函数的局部变量，这个特性是<strong>闭包(Closure)编程</strong>的基础，在这里我们不展开。</p><ul><li><strong>将lambda函数作为参数传递给其他函数。</strong></li><li>部分Python<strong>内置函数</strong>接收函数作为参数。典型的此类内置函数有这些。</li><li><strong>filter函数</strong>。对于序列中的元素进行筛选，最终获取符合条件的序列</li></ul><img src="/images/python-filter.png" height="400" width="800"><p>此时lambda函数用于指定过滤列表元素的条件。</p><p>例如filter(lambda x: x % 3 == 0, [1, 2, 3])指定将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3]。</p><ul><li><strong>sorted函数</strong>。</li></ul><p>此时lambda函数用于指定对列表中所有元素进行排序的准则。</p><p>例如sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。</p><ul><li><p><strong>map函数</strong>。遍历序列，对序列中每个元素进行操作，最终获取新的序列。</p><img src="/images/python-map.png" height="400" width="800"><p>此时lambda函数用于指定对列表中每一个元素的共同操作。</p><p>例如map(lambda x: x+1, [1, 2,3])将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]。</p></li><li><p><strong>reduce函数。</strong>对于序列内所有元素进行累计操作</p><img src="/images/python-reduce1.png" height="400" width="800"><img src="/images/python-reduce2.png" height="600" width="800"><p>此时lambda函数用于指定列表中两两相邻元素的结合条件。</p><p>例如reduce(lambda a, b: ‘{}, {}’.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是’1, 2, 3, 4, 5, 6, 7, 8, 9’。</p></li></ul><p>另外，部分Python<strong>库函数</strong>也接收函数作为参数，例如gevent的spawn函数。此时，lambda函数也能够作为参数传入。</p><h2 id="使用争议"><a href="#使用争议" class="headerlink" title="使用争议"></a>使用争议</h2><p>事实上，关于lambda在Python社区是存在<strong>争议</strong>的。Python程序员对于到底要不要使用lambda意见不一致。</p><ul><li><strong>支持方</strong>认为使用lambda编写的代码更紧凑，<strong>更“pythonic”</strong>。</li><li><strong>反对方</strong>认为，lambda函数能够支持的功能十分有限，其不支持多分支程序if…elif…else…和异常处理程序try …except…。并且，lambda函数的功能被隐藏，对于编写代码之外的人员来说，理解lambda代码需要耗费一定的<strong>理解成本</strong>。他们认为，使用for循环等来替代lambda是一种更加直白的编码风格。</li></ul><p>关于lambda的争执没有定论。在实际中，是否使用lambda编程取决于程序员的个人喜好。</p><p>以上就是关于Python中的lambda的“<strong>一个语法，三个特性，四个用法，一个争论</strong>”。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>[1] <a href="https://www.python-course.eu/lambda.php">Lambda, filter, reduce and map</a></p><p>[2] <a href="https://mp.weixin.qq.com/s?src=11&timestamp=1567786052&ver=1836&signature=4VN7paXz5z-WcFqACQNpxF9XffWTyeCmA3kx*KdrmCP0CVMzRHoo5jH3HguTxYZOrEFFV1GR8TdX69F6P67HSO6IaAWte4EcBH*RO12um2Onomp8pIetTq0kYz1bpFsU&new=1">关于Python中的lambda，这可能是你见过的最完整的讲解</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《学习之道》 书摘</title>
      <link href="/2019/08/29/booknote/the-art-of-learning/"/>
      <url>/2019/08/29/booknote/the-art-of-learning/</url>
      
        <content type="html"><![CDATA[<div class="douban-card-block"><a class="douban-card" href="https://book.douban.com/subject/2345548"><div class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/subject/s/public/s6507306.jpg');"></div><div class="douban-card-left"><div class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/subject/s/public/s6507306.jpg');"></div></div><div class="douban-card-right" style="line-height: 1.7;"><div class="douban-card-item"><span>书名: </span><strong>学习之道（第2版）</strong></div><div class="douban-card-item"><span>作者: </span><span>[美]乔希·维茨金(JoshWaitzkin)</span></div><div class="douban-card-item"><span>出版年份: </span><span>2011-4</span></div><div class="douban-card-item"><span>评分: </span><span>8.2</span></div></div></a></div><style>.douban-card-block {display: flex;justify-content: center;align-items: center;width: 100%;max-height: 400px;}.douban-card {display: flex;margin: 30px 10px;padding: 15px;border-radius: 10px;position: relative;justify-content: center;align-items: center;overflow: hidden;color: antiquewhite;text-decoration: none;}.douban-card:hover {text-decoration: none;}.douban-card-bgimg {position: absolute;width: 115%;height: 115%;filter: blur(15px) brightness(0.6);background-size: 100%;background-position: center;background-repeat: no-repeat;}.douban-card-img {position: relative;height: 130px;width: 80px;background-size: 100%;background-position: center;background-repeat: no-repeat;}.douban-card-img {position: relative;height: 130px;width: 80px;}.douban-card-left {position: relative;display: flex;flex-direction: column;align-items: center;}.douban-card-right {position: relative;display: flex;flex-direction: column;margin-left: 12px;font-size: 16px;font-family: 'Courier New', Courier, monospace;line-height: 1.3;color: antiquewhite;}.douban-card-item {margin-top: 4px;}</style><h2 id="为什么读《学习之道》？"><a href="#为什么读《学习之道》？" class="headerlink" title="为什么读《学习之道》？"></a>为什么读《学习之道》？</h2><p>最近发现上了岁数后，特容易走神，虽然有在一直进行知识或者信息的摄取，但是存留率和转化率都存在严重的问题。无论是想走技术路线， 将理论转化为经验，以便跳槽-加薪-打拼事业；还是平日里的阅读体验（功利性阅读为主了），都没有形成一个明显的正反馈，很是焦虑，也许我还是有些急功近利吧。Anyway，向内探求，learn from the master，开启一段学习总结之旅~~</p><p>我希望：</p><p>了解真正精进掌握一项技能，是什么样子的心理体验？</p><p>了解怎样最快速涉猎一个领域，如何做到知识迁移？</p><p>并且，将他人实践验证过的、关于学习能力的优秀，正确观念，植入到我的头脑中，刷新，抑或颠覆旧有的认知体系。</p><p>一共20章，15万字，每天三章进行阅读+笔记总结，浸淫其中一周时间，最后看整体效果。</p><p>That’s all,  go with it.</p><p>——2019/8/30 夜</p><span id="more"></span><h2 id="笔记摘录"><a href="#笔记摘录" class="headerlink" title="笔记摘录"></a>笔记摘录</h2><ul><li><h3 id="Chapter-1-：《无心之举》"><a href="#Chapter-1-：《无心之举》" class="headerlink" title="Chapter 1 ：《无心之举》"></a>Chapter 1 ：《无心之举》</h3></li></ul><p>第一任导师：幸运的是，布鲁斯的教育理念非常契合我的性格。他并没有把自己当成博学之人，更多地是把自己当成是我成长过程中的向导，而非权威。如果我与他意见不一致的话，我们就会面对面进行探讨，而不是单方面的训话。</p><p>事实上，在处于困境时，他们才最具威胁性。许多很聪明的小孩子期望能顺利获胜，而当遇到麻烦时，他们马上就慌了手脚。</p><p>或许我在比赛中最关键的一个因素就是我的棋风，它与我的个性完全保持了一致。</p><ul><li><h3 id="Chapter-2：《转败为胜》"><a href="#Chapter-2：《转败为胜》" class="headerlink" title="Chapter 2：《转败为胜》"></a>Chapter 2：《转败为胜》</h3></li></ul><p>远离激烈竞争与压力的这些短期旅行，已经成为，并将继续成为我取得成功的不可或缺的一部分。</p><p>不管我们如何想保持自己的心态，但我们的感情却随着各种比赛结果而起伏不定，对此我们也没有办法。赢得大的赛事后，一切都那么美好，连天也是蓝的；而输掉比赛时，一切就变了样，连梦想都那么荒诞不经。</p><p>在决定强势回归时，我对想起所作的承诺，已远远超出了乐趣与荣耀，而是热爱、苦痛与激情，激励自己不断跨越，不断提升。</p><ul><li><h3 id="Chapter-3：《整体理论与渐进理论》"><a href="#Chapter-3：《整体理论与渐进理论》" class="headerlink" title="Chapter 3：《整体理论与渐进理论》"></a>Chapter 3：《整体理论与渐进理论》</h3></li></ul><p>追求卓越的关键在于，要坚持充满活力、长期的学习过程，不再满足于原地踏步、平平庸庸。</p><p>从长期来看，痛苦的失败比获胜更有价值。拥有健康的心态，能够从每次经历（不论好与坏）中有所心得，这样的人才能一路走下去，并且一路都能走得很开心。当然，真正的挑战是，面临着危险或在战斗中受了伤，如何能继续保持这种长期视角。<strong>这一点，或许是我们最大的障碍，恰恰就是学习艺术的核心所在。</strong></p><p>他们努力避开挑战，但最终是现实的世界主动找到了他们。他们的自信心是那么脆弱，不堪一击。对他们来说，失败永远是一场危机，而不是一个成长的机遇。因为获胜所以成了赢家，但新的失败会让他们成为败将。</p><p>—— 2019/8/31 傍晚</p><hr><ul><li><h3 id="Chapter-4：《爱上学习》"><a href="#Chapter-4：《爱上学习》" class="headerlink" title="Chapter 4：《爱上学习》"></a>Chapter 4：《爱上学习》</h3></li></ul><p>我本性喜欢闹腾，棋局越乱我越拿手，我向来喜欢雷雨、暴雪、飓风、怒海和鲨鱼区。</p><p>我是一个随性的人，不受心理因素影响，总是追求创新与飞跃。</p><p>过多的逃避结果可谓坏处多多。成功的道路绝非一帆风顺，否则岂不是人人都能当上冠军，因此我们需要做好充足的思想准备，应对沿途上的种种挑战，而真的遇到问题时，学会游泳的唯一办法就是下水。</p><p>一个很棒的对手能让我们看到自己的不足，推动我们达到自身的极限。</p><p>作为大人，我们要自己承担责任，培养一种健康、自由的思维方式。</p><p>唯有推动自我，探寻自身能力的极限，我们才会收获，才会进步。</p><p>有那么几次难忘的时刻，让我深深地意识到，荣耀与快乐或长期的成功并不相关。</p><ul><li><h3 id="Chapter-5：《软区域》"><a href="#Chapter-5：《软区域》" class="headerlink" title="Chapter 5：《软区域》"></a>Chapter 5：《软区域》</h3></li></ul><p>一方面，对手就是敌人；而另一方面，没有人比你的对手更了解你，也没有人比他更能挑战你的极限，或能如此不留情面地逼你成长、成就卓越。</p><p>在行为训练中，<strong>首先我们要学着心平气和对待一切已发生之事；之后，我们要学着将这些事情为我所用；最后，我们要学着做到完全自给自足，创造出我们自己的地震，这样，我们的思维过程可以自己创造突破性创新想法，而无须通过外因刺激。</strong></p><p>我意识到，在顶级比赛中，我不能指望周围有一个安静的环境，因此唯一的选择就是，平心静气应对嘈杂声。</p><p>对这类状况（棋风不正的心理战术）的解决方案不应是否定自己的情绪，而是将其为我所用。不去压抑自己的情感，而是将其导向高度专注。</p><p><strong>我的本能向来是寻找挑战，而不是避开难题。</strong></p><ul><li><h3 id="Chapter-6：《漩涡效应》"><a href="#Chapter-6：《漩涡效应》" class="headerlink" title="Chapter 6：《漩涡效应》"></a>Chapter 6：《漩涡效应》</h3></li></ul><p>站在高处来看，在势均力敌的情况下，过分迫切地要求赢，结果往往是输。</p><p>输赢之间的距离是很微小的，有很多办法都能将胜利从失败的手里夺回来。所有伟大的选手都深知这个道理。</p><p>音乐家，演员，运动员，哲学家，科学家，作家，他们都明白，接触的作品通常都是从小的错误中得来的。</p><p>在错误发生了以后，人会习惯性地呆在之前的情感舒适区域，可是也会产生一种令人不安的预感，事情已经变得越来越糟糕了。</p><p>——2019/9/1 夜</p><hr><ul><li><h3 id="Chapter-7：《改变本能反应》"><a href="#Chapter-7：《改变本能反应》" class="headerlink" title="Chapter 7：《改变本能反应》"></a>Chapter 7：《改变本能反应》</h3></li></ul><p>我生活在两个世界里，穿梭在各种赛事中，这让我产生了一种很怪异的分离感。有时候我似乎在对面的房间里下棋，却又能看见自己在思考。</p><p>我喜欢阅读海明威、多斯托夫斯基、海塞、加缪和杰克·凯鲁亚克他们的作品。</p><p>我孜孜不倦地研究国际象棋，现在一直鞭策我不断进步的，不是凌云壮志的野心，更多的是探求自我的渴求。</p><p>我的思绪如飞一般自由地奔跑，越跑越快，直到我在棋局之中忘了自我。有时候我会一动不动地坐上五六个小时来研究，也有的时候是每个星期都要花上三十个小时来研究。我就像是在一个迷宫里生活，呼吸和睡觉，突然有一天所有错综复杂的谜团都解开了，我于是恍然大悟。</p><p>在各种国际象棋的比赛中，当双方的对峙发生性质上的改变时，我会先做几个深呼吸来使我的头脑变得更加敏锐。而在现实生活中，我一直致力于去接受变化，而不是与之抗衡。</p><p>一旦当我认识到一个竞赛者往往会在强大的压力之下暴露出他深埋于心底的秘密这一点时，我对国际象棋的研究就成了一种心理分析。</p><p>这个心理学上的主题包含了一系列的内容，例如各种过渡性的转变，能够复原的专注力，意识的流动性，控制力，对未知事物的迅速转换，对高压的忍受能力，漩涡效应，当身体或者心理感觉不适的时候要保持头脑冷静，忍受疲劳感，情绪的波动，另外还包含了在国际象棋中走的每一步，总是会对应在生活里的某一点的某一时刻。无论何时当我发现一个缺点，我都会去接受它。</p><p>那段年少轻狂的，总是自豪地认为自己什么都懂的日子已经一去不复返了。我变得遇事谨慎自省了，但却缺少了那份独一无二的特质，正是那种特质一直驱使着我全身心投入到国际象棋的研究和学习当中去，并令我成为冠军。作为国际象棋的学习者和热爱者，我可以自由自在地翱翔，而作为一名艺术家和表演者，我却被紧紧缚住了手脚。</p><ul><li><h3 id="Chapter-8-：《驯服野马》"><a href="#Chapter-8-：《驯服野马》" class="headerlink" title="Chapter 8 ：《驯服野马》"></a>Chapter 8 ：《驯服野马》</h3></li></ul><p>马克·德沃思基和尤里·拉祖维被大众评为全世界最伟大的国际象棋指导者。</p><p>与尤里·拉祖维见面会让你感到非常平静。他拥有一种佛教僧侣般谦卑而平和的气质，总是带着一种亲切而又稍有嘲讽的笑容。······他温和的评论听上去像是佛家禅语，而与他交谈总像是如沐春风，令人受益匪浅。当把棋盘拿出来的时候，拉祖维的表情习惯性地表现出一种放松的专注，而他的眼神开始变得锐利起来，如同刀刃一般敏锐的思考就要出现了。</p><p>在现实生活中，德沃斯基是一个体格魁梧的高个子，他戴着一副厚厚的眼镜，很难见他洗澡或换衣服。他的社交能力非常糟糕，当他在没有谈论象棋和下棋的时候，就像一条在沙子里啪嗒啪嗒打滚的大鱼一样，跟这个社会格格不入。</p><p>拉祖维的训练方法，是建立在对每一个学生的个人性格和天赋素质的敏锐观察上的。</p><p>疾病是健康派来的最有说服力的大使。</p><p>人类的思想要定义一件事物，都是要以另外一件事物来作为参考的——没有光明，就不会有所谓的黑暗。</p><p>有时两种完全不同的结果之间存在着一种联系。</p><p><strong>研究形式的目的就是要摆脱形式。</strong></p><p>想要驯服一匹野马有两种最基本的方法。一种是把它紧紧地绑起来，从精神上令它崩溃。还有一种方法，能让你成为马语者。你要和它有相同的愿望，说同样的语言。你不要去破坏马的精神。</p><p>这其中至关重要的是，在人与动物的关系中，动物并不是充当一个被彻底打败了的角色。</p><p>德沃斯基想要用“从震惊到畏惧”的方法锻炼我，但是拉祖维却希望我能尽情地展现出我的自然光辉。</p><p>有时候我们不得不放弃现有的一些观点来吸收更多新的知识，却绝对不能放弃太多我们独一无二的内在天赋。必须用实际的战术意识来改造朝气蓬勃的、有创造力的理想主义。</p><p>作为一名棋手，背离了我本质的反应所产生的影响是致命的。然而从时间的角度看，我这才明白实际上我所收获的是一个怎会的成长机会。</p><p>——2019/9/2 夜</p><hr><ul><li><h3 id="Chapter-9：《初学者》"><a href="#Chapter-9：《初学者》" class="headerlink" title="Chapter 9：《初学者》"></a>Chapter 9：《初学者》</h3></li></ul><p>《在路上》—《达摩流浪者》—《道德经》</p><p>我之前对冥想的尝试很混乱——神经扭成一团，思维也随之冻结。但现在我的内心接受到了信息，思维欢快地穿梭于空间之中。</p><p>太极最重要的就是释放障碍，从而让身体和思想能够慢慢地融合到一起。</p><ul><li><h3 id="Chapter-10：《以退为进》"><a href="#Chapter-10：《以退为进》" class="headerlink" title="Chapter 10：《以退为进》"></a>Chapter 10：《以退为进》</h3></li></ul><p>为了有所成长，他需要舍弃现在的思维方式。他需要学会先输后赢。</p><p><strong>他们太不愿意出错，以至于被框住而无法前进。</strong></p><p>当你还是个初学者时，要保持初学者的思维并且愿意以退为进并不是多么困难，但是当人们都在看着你，期待你的表现时，要仍然保持谦虚和乐于学习就要难得多了。</p><p>我们必须允许我们并不总处于最佳状态，为人在一次次磨练中乐意承受挫折。</p><ul><li><h3 id="Chapter-11：《划小圈》"><a href="#Chapter-11：《划小圈》" class="headerlink" title="Chapter 11：《划小圈》"></a>Chapter 11：《划小圈》</h3></li></ul><p>《摩托车维护艺术》</p><p>学习的基本原则就是要钻研微观的细节事物，从而来理解时什么促成了这些宏观上的问题。我们面对的阻碍就是我们生活在一种关注度不足的文化里面。我们面对来自电视、收音机、手机、视频游戏以及网络的各种信息。这种不断的刺激有可能会让我们逐渐上瘾，不停地想去追求新事物，不停地愉悦自己。当没有新鲜有趣的事物时，我们可能就会感到无聊，无法集中注意力。所以我们就去寻找新的娱乐项目，搜索各个频道，翻阅各种杂志。如果有了这种生活节奏，那我们就像是浅水的小鱼，不知下面还有绚丽的海底世界。</p><p>太极体系可以被视为是吸收优秀的基本原理，释放紧张感和培养能量意识的一个综合实验室。</p><p>身怀绝技的武林高手过招和好莱坞武打电影中的花哨招式是非常不同的。造诣高的习武之人一般都没有什么很大的动作，他们知道如何解读来袭。</p><p>有效地2压缩技能的外在表现同时又紧紧围绕技能的内在实质。一段时间之后，广度就会慢慢缩小而力量则会逐渐增加。我把这种方法叫做“划小圈”。</p><p>在象棋和武术中，选手会倾向于使用各种花哨的技巧而忽视细微的吸收和完善，其实它们要比学到的招式数量重要得多。</p><p>事实就是在激烈的比赛中取胜的往往是那些把技能磨练得更深刻得选手。我们能成为顶尖选手并没有什么秘诀，而是对可能是基本技能得东西有更深的理解。每天都要学得更深一点而不是更广一点，因为学得更深可以把我们潜力中那些看不到、感受不到但又极具创造力得部分挖掘出来。</p><p>—— 2019/9/3 夜</p><hr><ul><li><h3 id="Chapter-12：《化困境为优势》"><a href="#Chapter-12：《化困境为优势》" class="headerlink" title="Chapter 12：《化困境为优势》"></a>Chapter 12：《化困境为优势》</h3></li></ul><p>我介绍过一个能随机应变的表演者在混乱的情况下要做到处事不惊有三个重要步骤。第一，要学会平静对待生活中的不完美之处。第二，把不完美之处转换成我们的优势。第三，隶属于表演心理学，即学习如何在我们的意识中制造一些欺负和小的波动来激励我们前进，所以我们要一直激励自己，不管外部条件是否有激励性。</p><p>后来我意识到这好像有点偏离了事情的本质。于是我花了一周时间来做一些柔软安静的练习来锻炼节奏、认知、阅读、控制对手呼吸方式和内在灵感。</p><p>我的手臂还打着石膏，所以右手根本不可能做动作——但我却能感觉到一股能量流入了右手的肌肉之中。虽然只是一种臆想，但却确实起到了作用。</p><p>在我的武术生涯中，我每次身体受伤，像我母亲那样的好心人就会建议我先停止几个星期不要参加训练。但是它们没有意识到的是如果我一受伤就停止训练，那我就得坐一整年的冷板凳了。基本上，我总会在受伤的第二天就会回到训练场，想着如何利用这种新情况来提高我某些方面的技能。如果我想做到最好，那我就不得不冒别人想避免的险，不得不经常充分挖掘当时的学习潜力，逆转困境为我所用。</p><p>当你想要做到最好时，你需要一种全神贯注并善于搜寻的思维模式。</p><p>比起屈服于这种挫折，你应该更好地应对受伤或是失败。我们太容易被我们的日常生活方式所桎梏，从而在学习过程中失去创造性。</p><p>一旦我们学会了如何把困境转化为优势，我们就可以制造有用的成长机会而又不至于带来真正的危险或伤害。</p><p>—— 2019/9/5 夜</p><ul><li><h3 id="Chapter-13：《让时间慢下来》"><a href="#Chapter-13：《让时间慢下来》" class="headerlink" title="Chapter 13：《让时间慢下来》"></a>Chapter 13：《让时间慢下来》</h3></li></ul><p>很显然，有一种生存技能可以让人类在生死存亡关头把身体和思维能力发挥到一个令人惊讶的程度。但我们能随心所欲地达到这种状态么？</p><p>在我看来，直觉时我们在这个世界上最珍贵地指南针，它是无意和有意思维之间地桥梁，我们一定要和使直觉起作用地因素保持联系。如果我们因为没有真正地理解直觉而忽略了直觉，那么我们就会失去跟我们自己地创造性源泉敞开心扉交流地绝好机会。</p><p>处在高水平中的每个人都对象棋有很多深入的了解，而成就伟大的原因很大一部分就在于内在的风度和思维意识的放松，后者可以让非意识自由流淌。</p><p>—— 2019/9/6 夜</p><ul><li><h3 id="Chapter-14：《揭开神秘的面纱》"><a href="#Chapter-14：《揭开神秘的面纱》" class="headerlink" title="Chapter 14：《揭开神秘的面纱》"></a>Chapter 14：《揭开神秘的面纱》</h3></li></ul><p>18世纪太极宗师王宗岳武学心得：动急则急应，动缓则缓随。</p><p>很多中国古代道家学派的教义不能完全按照字面意思来理解，简短玄妙的字面背后隐藏着的通常是庞大精深的实践中的真理，而后者才是真正的核心。</p><p>在和技艺超群且思维敏捷的对手交锋时，心理战变得尤其微妙。两个人的交锋变成了一场无声的心理战：你要读懂对方的每一种呼吸节奏和每一次眼神闪烁，要在对方毫无察觉之下施展自己的操控技巧。一旦我能够更深入细致地领悟这一系列地行为，就可以在对手不知不觉中操控了他的意志。</p><p>实际上，在每一项身体竞技体育中，一旦你精通并能掌控步法，你就会成为场上不可小觑的一员。</p><p>这种心理交锋几乎是所有高水平交手过程的核心——这里指的是广义的“交手“。</p><p>当两个头脑训练有素的人在任何场合中针锋相对，双方就将比拼谁能掌控对方的思维。这种你来我往的交锋，就好像一场势均力敌的网球比赛，交战双方轮流强占着上风，其中一个选手抓住了对方暴露的一个似有若无的软肋，而对方觉察出了危险，赶紧将之赶出自己的思维领域。</p><p>你需要明白这种交锋远远超过了传统意义。当双方有一个比另一个更深谙此道时，设计心理反射就容易得多了。</p><p><strong>领悟这些心理交锋的技术基础是很关键的。与有些所谓功夫大师自大的宣称不同，操控对手的意念，实际上并没有什么神秘色彩。这只是和诸多其他技巧一样可以逐渐培养的能力。</strong></p><p>——2019/9/16 夜</p><ul><li><h3 id="Chapter-15：《自在从容的力量》"><a href="#Chapter-15：《自在从容的力量》" class="headerlink" title="Chapter 15：《自在从容的力量》"></a>Chapter 15：《自在从容的力量》</h3></li></ul><p>大师们知道如何抓住最微妙的机会以制胜。要想达到这种境界唯一能做的就是坦然接受痛苦，直到我能将数小时让人麻木的头脑煎熬当成是闲庭信步。毕竟这虎钳，只存在于我的头脑里。</p><p>在每一个领域，区分强者和弱者的标准很大程度上取决于在危机关头是否能够保持清醒的头脑，保持冷静，从容自如。</p><p>更微妙的是，这种心理战术或许对需要独立完成的比如写作、绘画、学术思考或研究来说更为重要。在没有外部推动的情况下，我们必须成为我们自己的监督者，有多从容成了最好的标尺。</p><p>那些高人一筹的人都是能将创造潜力发挥到极致的人。</p><p>在实际生活中我们越从容，就意味着在比赛中，在董事会上，在考试中，在手术台上，在更大的舞台上，我们就能把从容这一品质发挥得更好。<strong>如果我们还想追求卓越，那么我们就必须适应自我激励和控制的生活方式。</strong>从容应对所发生的一切，像呼吸一样自如。</p><ul><li><h3 id="Chapter-16：《释放压力》"><a href="#Chapter-16：《释放压力》" class="headerlink" title="Chapter 16：《释放压力》"></a>Chapter 16：《释放压力》</h3></li></ul><p>和凯达诺夫交战时，我觉得自己就像笼中的猛虎，身上冒着原始的能量。我赢了这两场比赛，还下出了我最有灵魂的招数，然而有趣的是之后我就完全被挖空了，在这两种情况下，我的锦标赛夜立即一败涂地。</p><p>我知道在短跑种怎样爆发冲刺，但在马拉松跑种，我却跑没了油。细水长流成了一个要命的问题。我是该学一门学问了，那就是要有一个长久、健康、能自我保持的巅峰表现。</p><p>LGE——人类表现研究所，佛罗里达州的奥兰多 运动营养学家和体格训练师共同建立。</p><p>我的身心咋全力以赴和彻底放松之间浮动。随着我保持这样的训练，我的心脏恢复所需要的时间逐渐减少。不久，我间隔休息的时间只要四十五秒，而我能快速运动的时间加长了。</p><p>一旦恢复状态的这种行为根植到我们的血液，我们就能在最危险最紧张的情况下使用它，变成能自我更新、创造小小避难所的大师，观众可能都不会发现这样片刻的休息。</p><p>我们在日常生活中释放压力，过后身心都底气十足的能力会越来越强，我们在集中注意力、调节兴奋度、体力运用和放松自我之间能游刃有余，充满自信。</p><p>无意识的脑袋是一个大有潜力的工具，怎样在压力下放松则是挖掘这一潜力的关键的第一步。</p><p>要成为一个细水长流、有长足发展的表现者，间断性工作起着举足轻重的作用。</p><p>——2019/9/19 夜</p><ul><li><h3 id="Chapter-17：《激发最佳状态》"><a href="#Chapter-17：《激发最佳状态》" class="headerlink" title="Chapter 17：《激发最佳状态》"></a>Chapter 17：《激发最佳状态》</h3></li></ul><p>通常情况下，我们生活中的高潮时刻是跟随在非高潮的、正常的和单调的许多时时刻刻、日日夜夜、岁岁年年。那么当我们人生的高潮时刻突然来临时，我们该如何阔步上前，勇敢面对呢？</p><p>我们不仅必须善于等待，还必要享受等待。<strong>因为等待不仅仅是等待，它还是生活</strong>。</p><p>我崇尚简单。深入到平凡之中，发现隐藏于生活之中的丰富才是成功还有幸福的所在。</p><p>我曾观察发现几乎所有人都有一种或两种能让他们感动的活动，但是人们通常忽视它们，把它们仅仅看作是“休息”。</p><p>如果在你的生活中，没有任何事情让你感到内心平静，冥想是帮助你发现自己的兴奋点并且找到适合自己的固定修炼的最完美的爱好。</p><p>太极冥想动作的精髓是当人在打太极拳的时候，随着各种武术动作，不间断地聚集和释放身体与心灵。当我吸气时，精神开始复苏，我可以看见力量从脚尖流到指尖。呼气时，精神开始放松，身体没有了力量，障碍消失不见，气流随之上升，身体准备好下一次的吸气。从本质上来说，如果你忽略各种招式的实际力量，太极冥想时关于盛衰、刚柔、阴阳和变化的修炼。</p><p>这本书是关于学习和竞技的，它也是一本关于我人生的书。<strong>存在本身教会了我如何生活。</strong></p><p>—— 2019/10/3 夜</p><ul><li><h3 id="Chapter-18：《化情绪为力量》"><a href="#Chapter-18：《化情绪为力量》" class="headerlink" title="Chapter 18：《化情绪为力量》"></a>Chapter 18：《化情绪为力量》</h3></li></ul><p>最具有决定性的情绪之一——愤怒，这种情绪可以成就一名选手，也可以毁了一名选手。</p><p>我用了很长时间才认识到压抑自己的本能情绪并非问题的解决办法。我不应该被愤怒控制或否认自己的愤怒，而是必须从某种程度上将我的愤怒引导到一种极度全神贯注的状态。直到我进入武术行当，我才学会了这么做。</p><p>世上总有讨厌的人，而我必须学会怎样以冷静的头脑应对。愤怒失控会让我的人生止步不前。</p><p>愤怒和恐惧以及喜悦是从我们内心深处发出的，我认为抑制这些情绪是人为强加的习惯。</p><p><strong>成功的唯一方法便是承认现实，超越现实，鼓起勇气并善用之。</strong></p><p>我坚信最高境界的舞者必须对自己真实。不能对自己的个性有所否认或压抑，否则产生的结果必然是错误的——武者将会远离自己内心本能的声音。</p><p>首先，我们要培养自己的“软区域”，我们要能够适应自己的情绪，观察他们，研究他们，了解如何让它们自然地宣泄，学习如何利用它们来激发自己内心情绪的薄发，勇气将提升我们的比赛状态，恐惧会使我们产生警觉，愤怒将让我们更加专注。然后，我们要找到哪一种情感状态可以激发最佳竞技状态。</p><p>人人都会不同。要内省。发现什么状态最适合你，像卡斯帕罗夫一样，制造能够引发你最佳状态的因素，这样你就能随心所欲利用它来激发自己的潜能。</p><ul><li><h3 id="Chapter-19：《万物合一》"><a href="#Chapter-19：《万物合一》" class="headerlink" title="Chapter 19：《万物合一》"></a>Chapter 19：《万物合一》</h3></li></ul><p>只有当我们的工作超越熟练阶段二成为自身的一种表达的时候，学习才成为一门真正的艺术。</p><p>真正的大师懂得控制。</p><p>冠军几乎毫无例外地都是这样的一些人，他们知道自己独有的优势，从而形成了自己特有的风格，而且比别人更善于把比赛引向有利于自己的方向。</p><p>我们创造的技巧使全新的，极具个性的，完全符合个人优势。大多数是心理方面的，有关于摸清对手的想法，跟上他的节奏，用细微的技巧控制他的意图。</p><ul><li><h3 id="Chapter-20：《决战》"><a href="#Chapter-20：《决战》" class="headerlink" title="Chapter 20：《决战》"></a>Chapter 20：《决战》</h3></li></ul><p>刹那间，一切都结束了，再也没有任何的竞技，武术的狂暴也平息下来，取而代之的，是伤痛，是成熟，是友情。</p><p>—— 2019/10/22 夜</p><h2 id="感悟体会"><a href="#感悟体会" class="headerlink" title="感悟体会"></a>感悟体会</h2><ul><li>循循善诱的导师和和睦的家人关系</li><li>发展心理学：整体理论 vs 渐进理论 模式的差别</li><li><strong>一想到为人父母，居然不用考试，就觉得真是太可怕了。</strong>——伊坂幸太郎 </li><li>万事万物到达一定层次的高度以后，都是相通的。</li><li>千里马常有而伯乐不常有，follow your heart，follow the fitful mentor</li><li>认识自己，遵从天性</li><li>心理学要学就学深学透，一知半解比无知更可怕。</li><li><strong>不要急功近利，流于形式，而是专注于细节的把握，以及深度的提升。</strong>——very useful advice</li><li>劳逸结合，自在从容</li><li>善始善终，方能成功</li></ul><h2 id="主题拓展"><a href="#主题拓展" class="headerlink" title="主题拓展"></a>主题拓展</h2><p><a href="https://book.douban.com/subject/27047949/"><strong>《学习之道》</strong></a></p><p><a href="https://book.douban.com/subject/30353486/">《认知天性》</a></p><p><a href="https://book.douban.com/subject/26895993/">《刻意练习》</a></p><p><a href="https://book.douban.com/subject/30216218/">《终身学习》</a></p><p><a href="https://read.douban.com/ebook/46037783/?dcs=subject-rec&dcm=douban&dct=30216218">《心流》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Booknote </category>
          
          <category> 学习能力 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习能力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 快捷键</title>
      <link href="/2019/07/14/python/fundation/pycharm-keyboard-shortcuts/"/>
      <url>/2019/07/14/python/fundation/pycharm-keyboard-shortcuts/</url>
      
        <content type="html"><![CDATA[<h3 id="1、编辑（Editing）"><a href="#1、编辑（Editing）" class="headerlink" title="1、编辑（Editing）"></a>1、编辑（Editing）</h3><p>Ctrl + Space 基本的代码完成（类、方法、属性）</p><p>Ctrl + Alt + Space 快速导入任意类</p><p>Ctrl + Shift + Enter 语句完成</p><p><strong>Ctrl + P 参数信息（在方法中调用参数）</strong></p><p><strong>Ctrl + Q 快速查看文档</strong></p><p>F1 Web帮助文档主页</p><span id="more"></span><p>Shift + F1 选中对象的Web帮助文档</p><p><strong>Ctrl + 悬浮/单击鼠标左键 简介/进入代码定义</strong></p><p><strong>Ctrl + Z 撤销上次操作</strong></p><p><strong>Ctrl + Shift + Z 重做,恢复上次的撤销</strong></p><p>Ctrl + F1 显示错误描述或警告信息</p><p>Alt + Insert 自动生成代码</p><p>Ctrl + O 重新方法</p><p>Ctrl + Alt + T 选中</p><p><strong>Ctrl + / 行注释/取消注释</strong></p><p><strong>Ctrl + Shift + / 块注释</strong></p><p>Ctrl + W 选中增加的代码块</p><p>Ctrl + Shift + W 回到之前状态</p><p>Ctrl + Shift + ]/[ 选定代码块结束、开始</p><p>Alt + Enter 快速修正</p><p>Ctrl + Alt + L 代码格式化</p><p>Ctrl + Alt + O 优化导入</p><p><strong>Ctrl + Alt + I 自动缩进</strong></p><p><strong>Tab / Shift + Tab 缩进、不缩进当前行</strong></p><p>Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板</p><p>Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板</p><p>Ctrl+V/Shift+Insert 从剪贴板粘贴</p><p>Ctrl + Shift + V 从最近的缓冲区粘贴</p><p><strong>Ctrl + D 复制选定的区域或行</strong></p><p><strong>Ctrl + Y 删除选定的行</strong></p><p>Ctrl + Shift + J 添加智能线</p><p>Ctrl + Enter 智能线切割</p><p><strong>Shift + Enter 另起一行</strong></p><p>Ctrl + Shift + U 在选定的区域或代码块间切换</p><p><strong>Ctrl + Delete 删除到字符结束</strong></p><p><strong>Ctrl + Backspace 删除到字符开始</strong></p><p><strong>Ctrl + Numpad+/- 展开/折叠代码块（当前位置：函数、注释等）</strong></p><p><strong>Ctrl + Shift + Numpad+/- 展开/折叠所有代码块</strong></p><p>Ctrl + F4 关闭运行的选项卡</p><h3 id="2、查找-替换-Search-Replace"><a href="#2、查找-替换-Search-Replace" class="headerlink" title="2、查找/替换(Search/Replace)"></a>2、查找/替换(Search/Replace)</h3><p>F3 下一个</p><p>Shift + F3 前一个</p><p><strong>Ctrl + R 替换</strong></p><p><strong>Ctrl + Shift + R 全局替换</strong></p><p>Ctrl + Shift + F 全局查找（可以在整个项目中查找某个字符串什么的，如查找某个函数名）</p><p><strong>连续敲击两次Shift键 查找函数</strong></p><h3 id="3、运行-Running"><a href="#3、运行-Running" class="headerlink" title="3、运行(Running)"></a>3、运行(Running)</h3><p>Alt + Shift + F10 运行模式配置</p><p>Alt + Shift + F9 调试模式配置</p><p>Shift + F10 运行</p><p>Shift + F9 调试</p><p><strong>Ctrl + Shift + F10 运行编辑器配置</strong></p><p><strong>Ctrl + Alt + R 运行manage.py任务</strong></p><h3 id="4、调试-Debugging"><a href="#4、调试-Debugging" class="headerlink" title="4、调试(Debugging)"></a>4、调试(Debugging)</h3><p>F8 跳过</p><p>F7 进入</p><p>Shift + F8 退出</p><p>Alt + F9 运行游标</p><p>Alt + F8 验证表达式</p><p>Ctrl + Alt + F8 快速验证表达式</p><p>F9 恢复程序</p><p><strong>Ctrl + F8 断点开关</strong></p><p><strong>Ctrl + Shift + F8 查看断点</strong></p><h3 id="5、导航-Navigation"><a href="#5、导航-Navigation" class="headerlink" title="5、导航(Navigation)"></a>5、导航(Navigation)</h3><p><strong>Ctrl + N 跳转到类</strong></p><p>Ctrl + Shift + N 跳转到符号</p><p>Alt + Right/Left 跳转到下一个、前一个编辑的选项卡（代码文件）</p><p><strong>Alt + Up/Down跳转到上一个、下一个方法</strong></p><p>F12 回到先前的工具窗口</p><p>Esc 从工具窗口回到编辑窗口</p><p>Shift + Esc 隐藏运行的、最近运行的窗口</p><p>Ctrl + Shift + F4 关闭主动运行的选项卡</p><p>Ctrl + G 查看当前行号、字符号</p><p>Ctrl + E 在当前文件弹出最近使用的文件列表</p><p>Ctrl+Alt+Left/Right 后退、前进</p><p>Ctrl+Shift+Backspace 导航到最近编辑区域（差不多就是返回上次编辑的位置）</p><p>Alt + F1 查找当前文件或标识</p><p>Ctrl+B / Ctrl+Click 跳转到声明</p><p>Ctrl + Alt + B 跳转到实现</p><p>Ctrl + Shift + I 查看快速定义</p><p>Ctrl + Shift + B 跳转到类型声明</p><p>Ctrl + U 跳转到父方法、父类</p><p>Alt + Up/Down 跳转到上一个、下一个方法</p><p>Ctrl + ]/[ 跳转到代码块结束、开始</p><p>Ctrl + F12 弹出文件结构</p><p>Ctrl + H 类型层次结构</p><p>Ctrl + Shift + H 方法层次结构</p><p>Ctrl + Alt + H 调用层次结构</p><p>F2 / Shift + F2 下一条、前一条高亮的错误</p><p>F4 / Ctrl + Enter 编辑资源、查看资源</p><p>Alt + Home显示导航条F11 书签开关</p><p>Ctrl + Shift + F11 书签助记开关</p><p>Ctrl + #[0-9] 跳转到标识的书签</p><p>Shift + F11 显示书签</p><h3 id="6、搜索相关-Usage-Search"><a href="#6、搜索相关-Usage-Search" class="headerlink" title="6、搜索相关(Usage Search)"></a>6、搜索相关(Usage Search)</h3><p>Alt + F7/Ctrl + F7 文件中查询用法</p><p>Ctrl + Shift + F7 文件中用法高亮显示</p><p>Ctrl + Alt + F7 显示用法</p><h3 id="7、重构-Refactoring"><a href="#7、重构-Refactoring" class="headerlink" title="7、重构(Refactoring)"></a>7、重构(Refactoring)</h3><p>Alt + Delete 安全删除</p><p>Shift + F6 重命名文件</p><p>Ctrl + F6 更改签名</p><p>Ctrl + Alt + N 内联</p><p>Ctrl + Alt + M 提取方法</p><p>Ctrl + Alt + V 提取属性</p><p>Ctrl + Alt + F 提取字段</p><p>Ctrl + Alt + C 提取常量</p><p>Ctrl + Alt + P 提取参数</p><h3 id="8、控制VCS-Local-History"><a href="#8、控制VCS-Local-History" class="headerlink" title="8、控制VCS/Local History"></a>8、控制VCS/Local History</h3><p>Ctrl + K 提交项目</p><p>Ctrl + T 更新项目</p><p>Alt + Shift + C 查看最近的变化</p><p>Alt + BackQuote(‘) VCS快速弹出</p><h3 id="9、模版-Live-Templates"><a href="#9、模版-Live-Templates" class="headerlink" title="9、模版(Live Templates)"></a>9、模版(Live Templates)</h3><p>Ctrl + Alt + J 当前行使用模版</p><p>Ctrl + J 插入模版</p><h3 id="10、基本-General"><a href="#10、基本-General" class="headerlink" title="10、基本(General)"></a>10、基本(General)</h3><p>Alt + #[0-9] 打开相应的工具窗口</p><p>Ctrl + Alt + Y 同步</p><p>Ctrl + Shift + F12 最大化编辑开关</p><p>Alt + Shift + F 添加到最喜欢</p><p>Alt + Shift + I 根据配置检查当前文件</p><p>Ctrl + BackQuote(‘) 快速切换当前计划</p><p>Ctrl + Alt + S 打开设置页</p><p>Ctrl + Shift + A 查找编辑器里所有的动作</p><p><strong>Ctrl + Tab 在窗口间进行切换</strong></p><p>Web帮助文档默认快捷键说明：</p><p><a href="https://www.jetbrains.com/help/pycharm/keyboard-shortcuts-and-mouse-reference.html">https://www.jetbrains.com/help/pycharm/keyboard-shortcuts-and-mouse-reference.html</a></p><p>Pycharm中打开Help-&gt;Keymap Reference可查看默认快捷键帮助文档：</p><h3 id="快捷键图例"><a href="#快捷键图例" class="headerlink" title="快捷键图例"></a>快捷键图例</h3><p><img src="/images/PyCharm.png" alt="PyCharm"></p><p><img src="/images/pycharm_for_windows.jpg" alt="pycharm_for_windows"></p><p><img src="/images/pycharm_for_mac.jpg" alt="pycharm_for_mac"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Fundation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令掌握的阶段性总结</title>
      <link href="/2019/03/28/linux/command-personal-experience-and-suggestions/"/>
      <url>/2019/03/28/linux/command-personal-experience-and-suggestions/</url>
      
        <content type="html"><![CDATA[<h2 id="命令类型概览"><a href="#命令类型概览" class="headerlink" title="命令类型概览"></a>命令类型概览</h2><div id="command1" style="width: 1000px; height: 800px;"></div><script type="text/javascript" src="/Echarts_js/echarts.js"></script><script type="text/javascript" src="/Echarts_js/linux_total_command_list.js"></script>## 个人学习经验梳理<h3 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a><strong>免责声明</strong></h3><p>就我的Linux 操作技术而言，自我客观地评价，目前应该算是在应用层级上的中上游水平。所以，我的所有经验，肯定囿于目前的能力与视野，不过先写下来也无妨，日后好进行修正与精进。简言之，这些仅仅是个人的使用经验与学习习惯的总结，更多的是以linux 命令工具的学习掌握为例，反思我个人的学习模式。因为我发现工具、技能的应用范围必然有限，但背后的学习模式是基本普适的，并可以迁移至其他领域，且得到不断优化提高的。</p><span id="more"></span><h3 id="学习的基本流程：调研—实践—总结"><a href="#学习的基本流程：调研—实践—总结" class="headerlink" title="学习的基本流程：调研—实践—总结"></a>学习的基本流程：调研—实践—总结</h3><p><strong>资料的搜集与筛选：</strong>信息搜集整理能力</p><p>目前，只要掌握基本的网络搜索功能，想要获得一项技能的学习资料，是轻而易举的，而且还能得到海量的学习资源。但是其中存在一些典型的思维误区，以为信息就是知识，储备即能掌握，这是非常自欺欺人的。所以，既要有基本的检索技能，也要能够客观判断自身能力水平，并依此筛选适合目前能力水平的资料。</p><p><strong>学习计划的制订与执行：</strong>规划力与执行力</p><p>网上以及现实工作交流中，经验丰富的工程师，会提供一些他们认为切实有效的学习建议与学习路线，这时候，就可以结合自身的需求与兴趣，制定大致的学习计划，并贯彻执行。因为每个人的具体情况不一样，所以，学习计划应该是根据自身期望（要学什么，掌握到什么水平）与学习习惯制定并执行的。</p><p><strong>实践中的反馈与总结：</strong>客观理性以及自省反思能力</p><p>投入到实际的运用中去，从中暴露出方方面面的隐性问题，并依此得到最切实中肯的反馈，使得自身技术能力迅速得到良性提升。这就既要dive into it，figure it out，也要能从全局角度看待问题，把握进度与方向。</p><p>所以，简而言之，这套流程还是学生时期以来，最简单的预习—学习—复习流程，只不过是针对陌生领域，变成了调研—掌握—总结的模式。</p><h3 id="技能晋级的模式：基础-进阶-高级"><a href="#技能晋级的模式：基础-进阶-高级" class="headerlink" title="技能晋级的模式：基础-进阶-高级"></a>技能晋级的模式：基础-进阶-高级</h3><p>与上面学习流程对应的，是由浅入深的学习模式。不同阶段，对于技能的要求程度（掌握程度和熟练程度）是不一样的。</p><p><strong>基础阶段：有的放矢，80/20原则</strong></p><p>掌握最常用，最高频的用法即可，懂得基础的知识点与概念，熟练程度为中等，掌握程度为中等，心中有个大致知识框架，并了解具体的应用场景。</p><p><strong>进阶阶段：术业有专攻</strong>，<strong>选择 &gt; 努力</strong></p><p>吾生也有涯，而学也无涯，以有涯随无涯，则殆已。只要大致明白具体的应用有哪些，再结合岗位要求和自身的兴趣需求，朝着想要努力的方向，主动投入资源（包括时间、精力、金钱），必然能得到技术的精进。</p><p><strong>高级阶段：游刃有余，熟能生巧</strong></p><p>通过解决实际问题，与项目经验的积累，这时候，能够进一步精进技术细节等，形成自己特有的风格，技术的熟练度和掌握度得到进一步强化，以致熟能生巧，从心所欲。就像专业网球选手一样，虽然最开始学的都是标准教材一样的动作，但是经过基础训练+实际比赛之后，最终，每个人都会形成自己的风格习惯，whatever，这才是diversity的魅力所在。虽然可能风格迥异，但此时都已然不惑于工具的使用，能更客观地鉴别评判其优劣，知道能够优雅操作更好，不过切实有效的才是最好的。而且作为技能高手，必然有其相似之处——熟练，精准，深刻，灵活，客观，全局，远瞻等等（自忖还没到~~瞎琢磨的）。</p><h3 id="相应的心态转变"><a href="#相应的心态转变" class="headerlink" title="相应的心态转变"></a>相应的心态转变</h3><p>为了避免从入门到放弃这种尴尬局面（其实<strong>快速试错</strong>是<strong>很有必要</strong>的），这其中就要求前期搜集与宏观大致规划，以及中期坚决执行与灵活调整，后期及时反馈与修正的能力。经历过上述过程以后，心态会随之慢慢变化，大致是从一个萌新菜鸡，到中级进阶者，再到高级引导者级别的转变，个中滋味，每个有一技之长的人，大都能有切身体会（约略像王国维的为学三境界？）。此时，回想起曾经跨专业找工作时，迷茫又自卑的我，受一个科大师兄面试官所点拨的一样：<strong>不管你干什么，干好就行</strong>。的确如此，只要能把事情做好，就会体验到正确的心态及行事逻辑，然后自然而然，在习惯的驱使下，导致良性的正反馈循环。毕竟，也不过就是一项项技能而已，天赋高低，可能会决定一个人的上限，但努力与否，则决定了一个人的下限。</p><h3 id="具体的学习技巧与习惯"><a href="#具体的学习技巧与习惯" class="headerlink" title="具体的学习技巧与习惯"></a>具体的学习技巧与习惯</h3><p>针对Linux 命令行工具的掌握而言，因为它的使用场景是Linux系统下的操作与管理，所以，是以实践性质为主。下面则是我的一些使用习惯与思考，其中一些点，譬如说交流沟通等，我自己有些做的不足之处，但是先记录下来，待以后再来审视（是的，道理都懂，但还是过不好这一生）：</p><p><strong>养成良性的习惯：</strong></p><p>命令行操作 &amp; 英文工作环境 &amp; 官方文档 &amp; 优质参考书 or 教学视频</p><p>慢慢摆脱之前在 windows下的鼠标操作，查询基础命令用法时，尽量第一选择是阅读官方manual，其次是优秀的搜索引擎如 google 与专业论坛等，习惯英文原文资料的阅读。浸淫其中，才能逐渐建立新的习惯。同时，follow the <strong>fitful</strong> mentor，无论是视频学习还是书本阅读，选择权威，口碑好的，适合自己的，大概率总是没错，不贪多，但求精。</p><p><strong>选择合适的工具：</strong></p><p>工欲善其事，必先利其器，一个合适称手的工具，能够让学习事半功倍。</p><p>建议个人版 Ubuntu，企业版 CentOS，虚拟机安装VMWare，命令行客户端 Xshell，文本编辑器VIM，或Sublime。一开始就定好一个业界普遍使用的工具，把它的<strong>快捷键，常用功能，高级功能</strong>等掌握好，能减少很多不必要的时间浪费。</p><p><strong>最少必要知识的掌握：</strong></p><p>学中文汉字时，学童启蒙阶段，除了基本的拼音读法和常用汉字等，接着要学习查阅字典的方法。这样，即使碰见一个生僻字，只要会查阅字典的部首索引，或者猜测读音，也能找到并认识它。很显然，不需要先背下整个汉语词典，才去组词造句，构思行文，只要掌握了查阅字典的方式即可。而<strong>Linux命令的最少必要知识，则是——命令的模式pattern+常用cases，manual的查阅能力（俗称的面向API文档编程，呵呵) + google/baidu的搜索能力（俗称的面向stack overflow編程，哈哈）</strong>。</p><p><strong>学习中的衡量与取舍：</strong></p><p>一个或者一组命令的常见功能，应用场景，使用频度、难度等，心中有个大概衡量与认识即可。只有在具体的使用中，才能潜移默化的理解。比如，对于ls、cd，mkdir，scp这种高频基础命令，要尽量掌握80%，乃至100%的功能。<strong>原则就是用最小的时间，精力成本，学习掌握并运用到实际需求中。</strong>其实也只有应用的多了，才知道哪些高频使用，哪些是冷僻的。然后就知道有所侧重。</p><p><strong>重要度排序：高频 + 低难度 &gt;= 高频 + 高难度 &gt;低频+低难度 &gt;低频+高难度</strong></p><p>对应的掌握排序：依此则是熟练应用&gt;掌握&gt;基本识记即可。</p><div id="command2" style="width: 1200px; height: 900px;"></div><script type="text/javascript" src="/Echarts_js/echarts.js"></script><script type="text/javascript" src="/Echarts_js/linux_common_command_list.js"></script>**以问题为导向的实践练习：**<p>学习掌握工具的目的是为了解决实际工程问题，而不是为了应用该工具。要知君子不器，要使工具为我所用，而不是成为工具的奴隶，也不要把自己当作一个工具来看待，这是其一。其二，一如学习烹饪，并不是拿着一本烹饪大全，背记下食谱步骤，就能一步到位。而是先磕磕绊绊，手忙脚乱地做个简单的菜，熟悉下流程，然后精进掌握厨艺，同样，学习大部分linux命令，更多是problem-solving type，learning by doing，学习完命令的基本pattern和高频用法后，再结合具体的使用场景，相辅相成，得以迅速掌握。</p><p><strong>及时的笔记总结：</strong></p><p>从接触一个新单词到实际应用，其中大致会有5~6遍的识记过程，但是并不可以直接跳到第七第八次就能掌握的（至少目前不能，羡慕《Matrix I》里面Neo的学习模式），谨记日积跬步，功不唐捐，这样才能从日常碎片化的零散学习，逐渐积累沉淀，最终能到框架化的全局掌握。仅就我个人的习惯，建议笔记类使用OneNote，记忆类用Anki（听说是神器，暂时没有用）。</p><p><strong>优质社群的交流与分享：</strong></p><p>独学而无友，如果有一二个经验丰富的指导者，或者优质的交流社区等<strong>（俗称的面向github编程）</strong>，<strong>变被动学习为主动学习</strong>，何乐而不为？分享知识与见解，才能产生有趣的思维碰撞与有效的信息交换。在专业的氛围下，进行交流讨论与学习，这样可以不受限于个人所处的现实环境，因为如果没有明显觉知的话（后知后觉如我），现实环境对于人的影响是潜移默化且十分巨大的，它也会很大程度上促进、抑或限制一个人的思维和行为。</p><p><img src="/images/Cone_of_Learning.jpg" alt="Cone_of_Learning"></p><p><strong>业务层级的深度拓展：</strong></p><p>掌握了基本的命令工具之后，就可以完成一些简单的操作，但是如果要处理稍微复杂的自动化任务的话，则需要能够组合应用，并能够编写shell脚本，并接触业务层级的东西等。在计算机领域，各类企业级工具层出不穷，迭代迅速，很多技术工具由盛转衰，而Linux系统的命令工具相对来说，并不易被淘汰。所以<strong>坚持扎实基本功</strong>，<strong>钻研基本技术</strong>是相对更明智的选择。</p><p><strong>自我驱动学习逻辑的迁移：</strong></p><p>形成一套内在的学习逻辑，就可以进行有效的迁移：</p><p>譬如对于类Unix命令如LSF体系命令等的学习，Python 及其标准库的学习，git 的学习等，莫不如此。</p><p>以Python的学习为例：</p><p>背景了解调研：</p><p>其应用场景有哪些，工具优劣，选择一本口碑比较好的入门级别的书 《Learn python the hard way》；</p><p>选择合适的工具：</p><p>IDE如PyCharm，交互式如IPython，jupyter notebook等。 </p><p>最少必要知识：</p><p>基本的语法语义，数据结构等，高效的查阅方法<strong>dir() help()</strong>，<strong>google Python xxx keyword</strong></p><p>学习中的取舍：</p><p>首先熟练深入掌握一些高频的常用库：os、shutil、sys、glob、re、math、datetime库等，其他的，真正用到了再查就好（有两个行话：STFW 和 RTFM，前已有述，此处不表）。后续进阶则选择学习某个应用领域的库工具：如数据分析领域，numpy、scipy、pandas、matplotlib等。</p><p>解决复杂工程问题：</p><p>从易到难，从简单到复杂的处理实际问题等，然后获得进一步提升，总结反思，继续精进。</p><p>一如《心流》里面所提及的心流体验一样，在此不表。</p><p><img src="/images/flow.jpg" alt="flow"></p><p>——补写于 2019/9/13 未完待续</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><p><strong>《快乐的Linux命令行》</strong></p></li><li><p><strong>《Linux 鸟哥的私房菜》</strong>·</p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjE3ODU3MQ==&mid=2650444436&idx=1&sn=8558f6a93cddfdf0bfd8c17acebd11cd&chksm=83bbf770b4cc7e660626b058904986ba7958a68bc9d58a2a3ad33e68f416e3c23153a70190fe&scene=21#wechat_redirect"><strong>Linux 命令汇总</strong></a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md"><strong>github - jlevy/the-art-of-command-line</strong></a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/73341354"><strong>知乎专栏 - Linux上，最常用的一批命令解析</strong></a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484231&idx=1&sn=4cf217a4d692a7aba804e5d96186b15b&chksm=ebd74246dca0cb5024de2f1d9f9e2ecb631e49752713c25bbe44f44856e919df5a973049c189&scene=21#wechat_redirect"><strong>看完这篇Linux基本的操作就会了</strong></a></p></li><li><p><a href="https://www.xinli001.com/info/100406701"><strong>「心流」是种怎样的极致生活体验？</strong></a></p></li><li><p><a href="https://www.jianshu.com/p/58ef791b872a"><strong>心流，一种最优的幸福体验</strong></a></p></li></ul><h1 id=""><a href="#" class="headerlink" title=""></a></h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Intermediate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
            <tag> commamds </tag>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Environment Modules 环境变量模块化管理工具的使用</title>
      <link href="/2019/02/23/engineering/environment-module/"/>
      <url>/2019/02/23/engineering/environment-module/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Modules-功能简介"><a href="#1-Modules-功能简介" class="headerlink" title="1. Modules 功能简介"></a>1. Modules 功能简介</h3><p>​         超级计算机的硬件设施和应用软件，分别是整个超算系统的最底层和最顶层，在它们之间，还存在着我们称之为软件栈（software stack）的系统软件：包括编译器、并行运行环境、作业调度系统、性能分析和调试工具等等。一般较为成熟的超算平台，都必备多种版本、不同种类的编译器、MPI 库，以及数学库等；并在此基础之上，进行各类应用软件的编译与环境配置。于普通使用者而言，因使用需求的变化，其所需的使用场景也不尽相同。若用户自行配置，则可能因为对命令行操作生疏等原因，导致环境变量配置出错，学习成本高，影响使用效率。</p><p>Environment module 工具，常用于高性能计算集群（即HPC ：High  Perfermance Computing ）的环境配置管理上。它可以将软件编译器，MPI库，数学库、应用软件（计算类软件、分析类软件等）等，以模块的方式，统一到一个框架下，使得用户可以动态切换环境变量，便捷高效。且由于很多资源调度软件，如LSF、PBS、MOAB等，可以通过脚本文件来提交作业。所以，module工具同样可以在shell scripts中使用。</p><span id="more"></span><p>若要充分发挥Environment  module 工具的功用，只需要记住两点即可:</p><ul><li><ol><li>编写modulefiles，将应用软件所需的环境变量等写入其中，配置成模块。</li></ol></li><li><ol start="2"><li>使用module command(s)，动态调用已经配置好的模块。</li></ol></li></ul><h3 id="2-Modules-安装及配置"><a href="#2-Modules-安装及配置" class="headerlink" title="2. Modules 安装及配置"></a>2. Modules 安装及配置</h3><h4 id="2-0-测试环境"><a href="#2-0-测试环境" class="headerlink" title="2.0 测试环境"></a>2.0 测试环境</h4><p>CentOS 7.2系统，modules版本为4.2.1，源码安装方式，安装位置为/opt目录。</p><h4 id="2-1-源码编译"><a href="#2-1-源码编译" class="headerlink" title="2.1  源码编译"></a>2.1  源码编译</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">上传module 压缩包至/opt目录</span><br><span class="line">cd /opt</span><br><span class="line">tar -xvf  modules-4.2.1.tar.gz</span><br><span class="line">./configure --help #查看帮助页面</span><br><span class="line">./configure --prefix=/opt/modules/modules421 #指定安装目录为/opt/modules/modules421</span><br><span class="line">make install</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">设置软链接，实现登录启动modules工具</span><br><span class="line">ln -s  /opt/modules/modules421/init/profile.sh /etc/profile.d/modules.sh</span><br><span class="line">ln -s  /opt/modules/modules421/init/profile.csh /etc/profile.d/modules.csh</span><br><span class="line">source /etc/profile #或重新登录命令行界面之后，则可以使用module 的一系列命令</span><br><span class="line"></span><br><span class="line">修改modulerc文件，自定义$MODULEPATH变量</span><br><span class="line">在/opt/modules/modules421/init文件夹下的modulerc文件，可以自定义多个modulefiles所在的文件夹</span><br><span class="line"></span><br><span class="line">[root@node02 init]#  echo $MODULEPATH   #查看默认的module path</span><br><span class="line">/opt/modules/modules421/modulefiles</span><br><span class="line">cd $MODULEPATH</span><br><span class="line">mkdir  &#123;application,compiler,cuda,mathlib,mpi,python,tool&#125;</span><br><span class="line">更新modulerc文件。</span><br><span class="line">vim /opt/modules/modules421/init/modulerc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">%Module1.0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This file defines  the initial setup <span class="keyword">for</span> the modulefiles search path</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and modulefiles you  want to load by default <span class="keyword">for</span> all users. It should</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> contains a lines of  module <span class="built_in">command</span> like <span class="string">&#x27;module use path&#x27;</span> and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&#x27;module load mod&#x27;</span></span></span><br><span class="line"></span><br><span class="line">module use --append  &#123;/opt/modules/modules421/modulefiles/application&#125;</span><br><span class="line">module use --append  &#123;/opt/modules/modules421/modulefiles/compiler&#125;</span><br><span class="line">module use --append  &#123;/opt/modules/modules421/modulefiles/cuda&#125;</span><br><span class="line">module use --append  &#123;/opt/modules/modules421/modulefiles/mathlib&#125;</span><br><span class="line">module use --append  &#123;/opt/modules/modules421/modulefiles/mpi&#125;</span><br><span class="line">module use --append  &#123;/opt/modules/modules421/modulefiles/python&#125;</span><br><span class="line">module use --append  &#123;/opt/modules/modules421/modulefiles/tool&#125;</span><br><span class="line"></span><br><span class="line">重新登陆，查看自定义的MODULEPATH。</span><br><span class="line">[root@node02 init]#  source /etc/profile</span><br><span class="line">[root@node02 init]#  echo $MODULEPATH</span><br><span class="line">/opt/modules/modules421/modulefiles/application:/opt/modules/modules421/modulefiles/compiler:/opt/modules/modules421/modulefiles/cuda:/opt/modules/modules421/modulefiles/mathlib:/opt/modules/modules421/modulefiles/mpi:/opt/modules/modules421/modulefiles/python:/opt/modules/modules421/modulefiles/tool</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-编写配置modulefiles文件"><a href="#2-2-编写配置modulefiles文件" class="headerlink" title="2.2 编写配置modulefiles文件"></a>2.2 编写配置modulefiles文件</h4><h5 id="modulefile文件创建"><a href="#modulefile文件创建" class="headerlink" title="modulefile文件创建"></a>modulefile文件创建</h5><p>以gcc-4.8.5为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node02  modulefiles]# pwd</span><br><span class="line">/opt/modules/modules421/modulefiles</span><br><span class="line">[root@node02  modulefiles]# mkdir -p compiler/&#123;gcc,intel,pgi&#125;</span><br><span class="line">[root@node02  modulefiles]# tree compiler/</span><br><span class="line">compiler/</span><br><span class="line">├── gcc</span><br><span class="line">├── intel</span><br><span class="line">└── pgi</span><br><span class="line">3 directories, 0 files</span><br><span class="line"></span><br><span class="line">命名规则：一般&quot;foldername/modulefile&quot;  即 以&quot;软件名/版本号&quot;进行区分，gcc-4.8.5 编译器的modulefile文件，则命名为4.8.5。</span><br></pre></td></tr></table></figure><h5 id="modulefile编写规范"><a href="#modulefile编写规范" class="headerlink" title="modulefile编写规范"></a>modulefile编写规范</h5><p>以一个典型的modulefile为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">%Module 1.0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#Edited by BYA in  2018/3/6</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Modified by BYA one  day <span class="keyword">in</span> the future</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">conflict</span>               </span><br><span class="line">module-whatis   Intel Compiler version 2015.3.187  (icc,icpc,ifort)</span><br><span class="line"><span class="meta">#</span><span class="bash">module load</span></span><br><span class="line">prepend-path    PATH             /opt/intel/composer_xe_2015.3.187/bin/intel64</span><br><span class="line">prepend-path    LIBRARY_PATH     /opt/intel/composer_xe_2015.3.187/compiler/lib/intel64</span><br><span class="line">prepend-path    LD_LIBRARY_PATH  /opt/intel/composer_xe_2015.3.187/compiler/lib/intel64</span><br><span class="line">prepend-path    MANPATH          /opt/intel/composer_xe_2015.3.187/man</span><br><span class="line"></span><br><span class="line">setenv          CC              icc</span><br><span class="line">setenv          CXX             icpc</span><br><span class="line">setenv          FC              ifort</span><br><span class="line">setenv          F77             ifort</span><br><span class="line">setenv          F90             ifort</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###</span></span> </span><br></pre></td></tr></table></figure><p>其中：</p><p><strong>#%Module 1.0</strong>    抬头须存在；</p><p><strong>conflict</strong>   一行，代表与本模块冲突的软件模块，若没有，可#注释；</p><p><strong>module-whatis</strong>     指明模块的简单介绍，使用”module whatis 模块名”命令的时候可以查看；</p><p><strong>module load</strong>，代表该模块之前需要预先加载的其他模块；</p><p><strong>prepend-path  环境变量名 具体路径</strong></p><p>一般的环境变量有PATH、LIBRARY_PATH、LD_LIBRARY_PATH、MANPATH等，prepend-path 会把指定路径，<strong>追加</strong>到对应的环境变量中 ；</p><p><strong>setenv</strong>    <strong>环境变量名 具体值</strong>   </p><p>setenv 会设定环境变量的具体值。 </p><h4 id="2-3-整体规划与实施"><a href="#2-3-整体规划与实施" class="headerlink" title="2.3 整体规划与实施"></a>2.3 整体规划与实施</h4><p>若要配置比较大规模的超算环境，需要将软件需求，协调规范到一个整体框架之下，如果不清楚如何配置，可以调研参考下各大超算平台的配置：如<strong>中科大超算中心</strong>，<strong>中科院超算中心</strong>等。</p><p>如下为针对某项目需求，所制定的设计初稿：</p><p><img src="/images/plan_on_hpc.png" alt="plan_on_hpc"></p><p>最终的实现结果如下：</p><p><img src="/images/hpc_module.png" alt="hpc_module"></p><h3 id="3-Modules-使用方式"><a href="#3-Modules-使用方式" class="headerlink" title="3. Modules 使用方式"></a>3. Modules 使用方式</h3><h4 id="3-1-modules-常用指令"><a href="#3-1-modules-常用指令" class="headerlink" title="3.1 modules 常用指令"></a>3.1 modules 常用指令</h4><p>显示manual ：module  或 module –h，man module </p><p>查看可用模块：module  avail  </p><p>查看已加载模块：module  list   </p><p>加载模块：module load/add  MODULE_NAME  </p><p>卸载模块：module unload/rm  MODULE_NAME  </p><p>切换模块：module  switch/swap OLD_MODULE NEW_MODULE</p><p>卸载所有已加载的模块：module  purge</p><p>显示模块说明：module whatis  MODULE_NAME</p><p>显示该模块内容：module  display/show MODULE_NAME</p><h4 id="3-2-modules-使用示例"><a href="#3-2-modules-使用示例" class="headerlink" title="3.2 modules 使用示例"></a>3.2 modules 使用示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">示例使用：</span><br><span class="line">[root@hpc-material02  ~]# module purge</span><br><span class="line">[root@hpc-material02  ~]# module list</span><br><span class="line">No Modulefiles  Currently Loaded.</span><br><span class="line">[root@hpc-material02  ~]# module load openmpi/1.6.5/gcc/4.8.5</span><br><span class="line">[root@hpc-material02  ~]# module list</span><br><span class="line">Currently Loaded  Modulefiles:</span><br><span class="line">1) openmpi/1.6.5/gcc/4.8.5  </span><br><span class="line">[root@hpc-material02  ~]# module whatis openmpi/1.6.5/gcc/4.8.5</span><br><span class="line">----------------------------------------  /opt/modules/ModuleFiles/mpi -----------------------------------------</span><br><span class="line">openmpi/1.6.5/gcc/4.8.5:  Openmpi-1.6.5 compiled by gcc-4.8.5</span><br><span class="line">[root@hpc-material02  ~]# module display openmpi/1.6.5/gcc/4.8.5</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">/opt/modules/ModuleFiles/mpi/openmpi/1.6.5/gcc/4.8.5:</span><br><span class="line">module-whatis       Openmpi-1.6.5  compiled by gcc-4.8.5</span><br><span class="line">prepend-path        PATH        /opt/openmpi/openmpi-1.6.5_gcc-4.8.5/bin</span><br><span class="line">prepend-path        LD_LIBRARY_PATH        /opt/openmpi/openmpi-1.6.5_gcc-4.8.5/lib</span><br><span class="line">prepend-path        MANPATH        /opt/openmpi/openmpi-1.6.5_gcc-4.8.5/share/man</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">[root@hpc-material02  ~]# echo $PATH | sed &#x27;s/:/\n/g&#x27;</span><br><span class="line">/opt/openmpi/openmpi-1.6.5_gcc-4.8.5/bin</span><br><span class="line">/usr/local/sbin</span><br><span class="line">/usr/local/bin</span><br><span class="line">/usr/sbin</span><br><span class="line">/usr/bin</span><br><span class="line">/root/bin</span><br><span class="line">[root@hpc-material02  ~]# echo $LD_LIBRARY_PATH | sed &#x27;s/:/\n/g&#x27;</span><br><span class="line">/opt/openmpi/openmpi-1.6.5_gcc-4.8.5/lib</span><br><span class="line">[root@hpc-material02  ~]# module rm openmpi/1.6.5/gcc/4.8.5 </span><br><span class="line">[root@hpc-material02  ~]# echo $PATH | sed &#x27;s/:/\n/g&#x27;</span><br><span class="line">/usr/local/sbin</span><br><span class="line">/usr/local/bin</span><br><span class="line">/usr/sbin</span><br><span class="line">/usr/bin</span><br><span class="line">/root/bin</span><br><span class="line">[root@hpc-material02  ~]# echo $LD_LIBRARY_PATH | sed &#x27;s/:/\n/g&#x27;</span><br><span class="line"> </span><br><span class="line">[root@hpc-material02  ~]# </span><br></pre></td></tr></table></figure><h3 id="4-使用建议"><a href="#4-使用建议" class="headerlink" title="4. 使用建议"></a>4. 使用建议</h3><p>作业调度的时候，module可以写入提交脚本之中，需要先将<strong>MODULEPATH</strong>变量export 一下，然后使用module 相关的命令即可；</p><p>编译与配置的时候，可参考下INSTALL.txt文件。</p><h3 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h3><p>[1] <a href="https://en.wikipedia.org/wiki/Environment_Modules_(software)">Environment Modules (software) wikipedia</a></p><p>[2] <a href="https://www.cnblogs.com/li12242/p/9994633.html">Environment Modules 简明教程</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> modules </tag>
            
            <tag> HPC </tag>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>私人阅读史之两年时间读书分析</title>
      <link href="/2018/11/24/thought/personal-reading-analysis-of-past-2-years/"/>
      <url>/2018/11/24/thought/personal-reading-analysis-of-past-2-years/</url>
      
        <content type="html"><![CDATA[<div id="myreading" style="width: 100% ;height: 600px;"></div><script type="text/javascript" src="/Echarts_js/echarts.js"></script><script type="text/javascript" src="/Echarts_js/jquery.js"></script><script type="text/javascript" src="/Echarts_js/reading_details.js"></script><div id="myanalysis" style="width: 900; height: 600px;"></div><script type="text/javascript" src="/Echarts_js/echarts.js"></script><script type="text/javascript" src="/Echarts_js/jquery.js"></script><script type="text/javascript" src="/Echarts_js/reading_analysis.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>读书原为自己受用，且是非常个性化的体验，阅读不过一种自己选择的生活方式，已从刻意为之变为习以为常之事，故而，本不该拿出来标榜。不过，我对数据可视化&amp;设计，向来偏爱有加，爱鼓捣一些视频，图像等作品出来，并常常有想要炫耀的天然冲动。之前的可视化创作呢，更多的是一时灵感而已，但该阅读数据的记录，则是两年时间，锱铢积累而成的。一开始也并非意图明确，只是从最简单的时间记录开始，到后来，则渐渐区分功用类别，并不断完善、优化，最终，偶然接触 Echarts，甚爱之，折腾一番，将读书记录得以可视化出来，更爱之。所以呢，勉强可称为铺陈了两年的局，故而，还是有别于一般可视化的cheap fancy tricks的。既然图都摆出来了，要没些文字相互映衬，还是显得有些华而不实。也只好搜索枯肠，挤上几句，可阅读量着实一般，阅读技能也亟待提升，愿为人师又自忖不够格，还是做做反思吧。</p><span id="more"></span><p>以上两个图表，呈现的是2016年8月5日至2018年8月4日两年内，个人的业余阅读事件，分学生时期一年，工作时期一年。总阅读时间为693小时，平均每天57分钟，实际仅占用总体时间的3.96%，数据大体准确，的确难说得上嗜书如命，记录的数据中，没有技术类书籍的阅读，基本以非功利性阅读为主。因为掌握技能，不必要仅通过阅读的方式，且借以视频、实践、交流讨论等方式，往往更加直接高效。</p><p><strong>气泡图</strong>，是对单次阅读事件的具体记录。横轴代表日期跨度，纵轴代表一天24h，旋转滚轮，可切换全景/局部进行查看。每个圆圈就是一个具体的阅读事件，书籍的功用类别用颜色区分，阅读时长借由圆圈的大小区分，鼠标悬停其上，可以查看数据细节。</p><p><strong>饼图</strong>，则是对各书籍阅读时长的统计分析。功用类别暂分十种，按照在本人心目中的重视程度，依次顺时针排列。鼠标悬停，点击，可查看具体数据统计。</p><h2 id="我的书籍分类"><a href="#我的书籍分类" class="headerlink" title="我的书籍分类"></a><strong>我的书籍分类</strong></h2><p>至于书籍为什么这么分类？没遵循多少客观逻辑，纯粹是主观需求与偏好的综合。毕竟，中图法也都这么社会主义特色（分五大类部：<strong>马列毛邓</strong>；哲学；社会科学；自然科学；综合性图书。），不是么？我何必按传统的学科来区分呢？</p><p><strong>百读不厌</strong>：位列于此的，自然是留下深刻阅读体验的书籍。有上乘的文字游戏如《围城》，也有晓畅幽默而兼具通达深刻的《明朝那些事儿》系列、文学艺术巅峰之作《红楼梦》，以及启迪我踏上经典阅读之路的《1978—2008私人阅读史》。</p><p><strong>国学根基：</strong>之前也是煞有介事地阅读西方哲学，崇拜尼采，尼采著作及其相关传记，文学作品等：《查拉图斯特拉如是说》，《尼采：在世纪的转折点上》，《当尼采哭泣》等（我确能理解及同情尼采的偏头痛、追求莎乐美的疯魔），是青年蓬勃生命力时期的读物。但实际上，没踏实看过几本他的著作，就按耐不住浮躁的心性，干过蠢事，后来看《悲剧的诞生》等，看不懂，还得要看希腊神话，基督教的东西，倦懒，作罢。至于国故，依少年心性，向来是觉得其老旧不堪，嗤之以鼻的。但是发现我专业课的美女老师在看《道德经》，想想李耳先生应该不一般，便从公开课学起，然后断断续续地扩展开来。记得当初，就是为了和室友攀比吹嘘，而背的《道德经》。不过，读着读着，虽说还是一知半解，但隐约已有种文化上的亲近感，心灵上慢慢有了依傍，感觉找到了中华文化的根，便打算沿着这个精神主脉一路走下去了（好事如我，还特意对比过《论语》、《老子》的中英版本，就算翻译地再信、达、雅，单纯文字上的魅力也差去好多，大约自此，更激发出一种文化上由衷的自豪感）。其实，若有意扎实国学根底，这其中一些源头之书，趁着幼年时期记忆力强，熟读成诵多好。但我小时候既没这么个意愿，也没这个氛围，大概是忙着玩泥巴、捉蜻蜓之类的吧。</p><p><strong>灵感激发：</strong>这个要激发的灵感其实很窄，就是关于读书旨趣培养的。因为我对阅读的内容比较在乎，但对读书方式完全不挑剔，怎么简单怎么来，基本依靠网络资源的搜集，便够看的了，即使是特模糊的影印版pdf，都忍得下去。很多时候，连去图书馆借书这一环节都省了。若看电子书，就是捧个手机或kindle，几乎没有仪式感。如今积习已成，日常完全电子化阅读，即便入手实体书，更多的也是已阅之后，纪念为主。</p><p><strong>明达人生：</strong>其实是想看看，那些活的比较通达，或是比较不那么蒙昧的人都是什么个想法。</p><p><strong>视野拓展：</strong>主要一些近来口碑还行，也广为流行的作品，非虚构类为主。</p><p><strong>思维锻炼：</strong>这个方面不够重视，分配的精力有些少了，真的应该扎扎实实打下基础的。</p><p><strong>性格砥砺：</strong>基本上是人物传记类的书籍，精神上的挚友&amp;导师的人生历程，足以促进青年的发愤。</p><p><strong>思想启蒙：</strong>一些启发不同角度思考，观察社会的作品。</p><p><strong>文学涵养：</strong>一些影响力较大的文学名著吧。</p><p><strong>娱乐消遣：</strong>现在说来，<strong>I never read just for fun，I read to be powerful</strong>，已经过了读小说消遣的年纪，什么武侠、科幻等，畅销榜单的书籍等等，曾经也稍稍浏览过，并不多。</p><p>如今看来，发现上述分类过于剑走偏锋了，阅读之路上，没有一个流畅的衔接过程，更多还是随性而为。其实若是不知道自己兴趣、钟情所在，还想胸有乾坤，有所作为，那就必然要经历个广泛涉猎的阶段，没有一定的阅读量做基础，纯粹空谈。不过，更聪明的做法，是从一开始，就秉着构建一个足够客观，相对完善的知识体系的这一初衷去读书，多研究下中图法、杜威十进分类法等，观其大略，先有个宏观的知识脉络与目标，再按图索骥，开展实际的阅读。与此同时，也不排斥偶然的际遇，不断修正、完善认知体系。这样，也就不至于理工科训练出身，以为读过几本课外书，便不着边际起来，反倒惯出个闲散慵懒的心性。我的阅读分类可以称之为主观偏见了，而在<strong>《猜测和偏见》</strong>一书的末尾，作者何帆有一个可借鉴的书单，分类还算周全，总之比我的定义靠谱的多（这我承认，我的阅读史才起步不过几年，及时认识到问题就好），但若是我嘛，则会倾向于给心理学 &amp; 数学科普类更高的权重，所以说到底，阅读体验还是自己的，合不合适，自己做决定，途径只有一个——<strong>just read it</strong>。</p><ul><li><p><strong>历史</strong></p></li><li><p><strong>政治学、社会学、宏观经济学</strong></p></li><li><p><strong>微观经济学、博弈论</strong></p></li><li><p><strong>脑神经科学、遗传学、进化生物学、心理学、行为经济学</strong></p></li><li><p><strong>科技创新、工程学</strong></p></li><li><p><strong>逻辑学、统计学、数学、物理学、复杂科学、科学哲学</strong></p></li><li><p><strong>哲学</strong></p></li><li><p><strong>文学</strong></p><p>——总结自《猜测和偏见》附录</p></li></ul><h2 id="阅读需求的改变"><a href="#阅读需求的改变" class="headerlink" title="阅读需求的改变"></a><strong>阅读需求的改变</strong></h2><p>工作之后，求生欲盖过了求知欲，体现在阅读上也很明显，（参考气泡图全景图，左半边明显比右半边密集）无论是阅读量，书目的难度、时间分配上等等，基本上是全方位的退步。曾有些伤怀，但后来想到，实际上，<strong>社会是一本大书，这本书不是人人能读懂，不是人人需要去读，也不是人人想读，但是，人人又都参与其中的书写创作。</strong>现实问题常使人无措，失落，很棘手，很恼人，却绝非靠埋头读书就能解决，抑或躲避得了的，<strong>书籍该是我不渝的陪伴，而不应是我的避难所</strong>，<strong>that‘s too coward</strong>。（其实即使曾经生猛如我，被社会时不时锤上一锤，也不再刚愎自用了）而目前，体现在个人的阅读需求上，其重心便已经有意识地进行转变：<strong>从消遣性阅读转为功利性阅读</strong>，并在上述分类之外，又添加了一个<strong>经世致用</strong>的子类。既然身处其中，收起年少的张狂，认清局面，端正态度就好。否则，下述很可能就是我的成长之路啊？!</p><p><strong>无钱无闲&gt;&gt;无钱有闲&gt;&gt;有钱无闲 &gt;&gt;有钱有闲</strong>？！（<strong>无钱无闲again？！</strong>）</p><p><strong>高中备考的愣头小子&gt;&gt;大学浪来浪去的二货青年&gt;&gt;给资本大佬卖命的倔强小韭菜&gt;&gt;附庸风雅的油腻中年大叔？！</strong>（<strong>恓恓遑遑的窘迫中年大叔？！</strong>）（人越中年，若琐事缠身，加之感受力变得迟钝，读书的诉求估计会越来越淡。）</p><p>No way，拒绝油腻，拒绝犬儒，还是趁年轻，keep reading，我还需要通过它来change mindset，keep my mind wide open呢。</p><p>总之，上述也只是二十几岁青年两年时间的阅读经历，以及关于读书的一些看法与反思。其实即使在读书这件小事上面，也一如<strong>乔帮主</strong>所说的，<strong>you can’t connect the dots looking forward; you can only connect them looking backwards。</strong>虽说精神主脉已定，但未来的路还很长，未知的际遇也在远方的某段时期，待我赴去，共同经历，与之思想碰撞交汇。</p><p><img src="/images/connect_the_dots.png" alt="connect_the_dots"></p><h2 id="一些阅读上的建议"><a href="#一些阅读上的建议" class="headerlink" title="一些阅读上的建议"></a><strong>一些阅读上的建议</strong></h2><p><strong>阅读技巧：</strong></p><p><strong>《如何阅读一本书》</strong>高屋建瓴，把阅读能力的“初-中-高-特”级层次，阐述得清晰明了。</p><p><strong>《如何有效阅读一本书》</strong>，”搜集—选购—阅读—笔记“，较实用，结合自身情况完善各环节，对知识存留率的提升会有很大帮助。</p><p><strong>经验分享：</strong></p><p><strong>《1978—2008私人阅读史》</strong>中有很多人关于30年阅读历程的反思之作，读起来挺触动的。</p><p><strong>《谈修养》</strong>朱光潜【著】谈读书的见解。这个就在当时点拨了浮躁的我，懂得了一些怎么选书、怎么读书的道理。</p><p><strong>《像名人那样读书》</strong>吴金敦、刘新勇【编著】（这本书是近期图书馆偶遇的，a little bit surprise，有人已经帮忙把我想看的整理好了），这其中一些过来人的经验之谈，若是能真的践行一下，还是很受用的。</p><p><strong>《读书这么好的事》</strong>张新颖【著】简单有趣，反复读了好几遍，算是成功给自己洗脑——我爱看书，我爱看书，我爱看书~~</p><p>一些《像名人那样读书》中，对我比较有用的经验之谈，总结如下：</p><blockquote><p>读书有三种态度：一种是绝对信从的态度，凡是书上说的话就是天经地义；一种是批判的态度，用现实生活来检验，凡是对现实生活有益处的，取它，否则就不取；又一种是随随便便的态度，从书上学到些什么，用来装点自己，以便同人家谈闲天的时候可以应付，不致受人家讥笑，认为一窍不通。······青年应当抱而且必须抱的是第二种态度。要知道处理现实生活是目的，读书只是达到这个目的的许多手段之一。不要盲从“开卷有益”的成语，也不要相信“为读书而读书”的迂谈。要使书为你所用，不要让你自己去做书的奴隶。                        ——叶圣陶《读书的态度》</p></blockquote><blockquote><p>世间最不行的是读书者，因为他只能看别人的思想艺术，不用自己。这也就是叔本华（Schopenhauer）所谓的“脑子里给别人跑马”。较好的是思索者，但还不免是空想，所以更好的是观察者，他用自己的眼睛去读世间这一部活书。···总之，我们自发的读书，即嗜好的读书——请教别人是大抵无用，只好先行泛览，然后抉择而入于自己所爱的较专的一门或几门；但专读书也有弊病，所以必须和社会接触，使所读的书活起来。        ——鲁迅《读书杂谈》（那看来，我还磕磕绊绊也同样悟出来了，不过早点读到并理解这个经验多好。）</p></blockquote><p>——2019/3/13 夜 to be continued</p><p>功利性阅读别轻易尝试，too boring！！人生苦短，多遇见些合脾性的文与人，少些执拗与judge，take it easy就好。</p><p>——2019/9/21 夜 still on the way</p><p>儒—道—禅，逻辑，客观，非理性</p><p>——2020/4/29 晨 some bullshit ideas</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Echarts </tag>
            
            <tag> 反思 </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国学入门经典书目梳理</title>
      <link href="/2018/11/24/resource/guo-xue-shu-mu/"/>
      <url>/2018/11/24/resource/guo-xue-shu-mu/</url>
      
        <content type="html"><![CDATA[<h3 id="国学最低限度之必读书目-梁启超"><a href="#国学最低限度之必读书目-梁启超" class="headerlink" title="国学最低限度之必读书目   梁启超"></a>国学最低限度之必读书目   梁启超</h3><div id="guoxue" style="width: 850px; height: 800px;"></div><script type="text/javascript" src="/Echarts_js/echarts.js"></script><script type="text/javascript" src="/Echarts_js/guoxue_list.js"></script><p>1923年梁启超应《清华周刊》记者之约，拟就 <a href="http://www.guoxue.com/?p=1739">《国学入门书要目及其读法》</a>，约160种。后来他又为”校课既繁、所治专门”的青年学生精简此书目，开列出《最低限度之必读书目》：</p><span id="more"></span><p><img src="/images/liangqichao.jpg" alt="liangqichao"></p><ol><li><strong>经部</strong>：《四书》（《论语》、《孟子》、《大学》、《中庸》）、《易经》、《书经》、《诗经》、《礼记》、《左传》；</li><li><strong>史部</strong>：《战国策》、《史记》、《汉书》、《后汉书》、《三国志》、《资治通鉴》(或《通鉴纪事本末》)、《宋元明史纪事本末》；</li><li><strong>子部</strong>：《老子》、《墨子》、《庄子》、《荀子》、《韩非子》；</li><li><strong>集部</strong>：《楚辞》、《文选》、《李太白集》、《杜工部集》、《韩昌黎集》、《柳河东集》、《白香山集》。 </li></ol><p>梁启超认为：”<strong>以上各书，无论学矿、学工程，各种职业，皆须一读，若并此未读，真不能为中国学人矣。</strong>“</p><h3 id="中国人必读的9本书-钱穆"><a href="#中国人必读的9本书-钱穆" class="headerlink" title="中国人必读的9本书  钱穆"></a>中国人必读的9本书  钱穆</h3><p>1978年，香港中文大学新亚书院设立”钱宾四先生学术文化讲座”，请钱穆作了系列讲座，在讲演中钱穆指出有9部书是”中国人所人人必读的书”:</p><ul><li><strong>《论语》</strong></li><li><strong>《孟子》</strong></li><li><strong>《大学》</strong></li><li><strong>《中庸》</strong></li><li><strong>《老子》</strong></li><li><strong>《庄子》</strong></li><li><strong>《六祖坛经》</strong></li><li><strong>《近思录》</strong></li><li><strong>《传习录》</strong></li></ul><p><em>钱穆：中国现代著名历史学家、思想家、教育家，中央研究院院士，故宫博物院特聘研究员。中国学术界尊之为“一代宗师”，更有学者谓其为中国最后一位士大夫、国学宗师，<strong>与吕思勉、陈垣、陈寅恪并称为“史学四大家”。</strong>本文引自钱穆《中国文化丛谈·复兴中华文化人人必读的几部书》民国五十六年十二月十七日复兴中国文化会第十次学术讲演，五十七年二月《青年战士报》（有删减）</em></p><p><img src="/images/qianmu.jpg" alt="qianmu"></p><h4 id="第一部《论语》"><a href="#第一部《论语》" class="headerlink" title="第一部《论语》"></a>第一部《论语》</h4><p>我想举的第一部书是《论语》。你若要反对中国文化，那很简单，第一就该打倒孔家店。当时立意要打倒孔家店的人，就都在《论语》里找话柄。</p><p>如说：“唯女子与小人为难养也”，说这是孔子看不起女人。又如说“民可使由之，不可使知之”，说孔子主张愚民政策。</p><p>又如“子见南子”，把来编成剧本表演。拿《论语》里凡可以挑剔出毛病的，都找出来。</p><p>至于如《论语》开卷所说“学而时习之，不亦说乎？”有何毛病呢？这就不管了。</p><p>至少从汉朝开始，那时中国人就普遍读《论语》，像如今天的小学教科书。《论语》、《孝经》、《尔雅》，人人必读。《尔雅》是一部字典，现在我们另外有合用的字典，不需要读《尔雅》。《孝经》今天也不须读，已经经过很多人研究，《孝经》并不是孔子讲的话。</p><p>我想《论语》还应该是我们今天人人必读的一部书。倘使要找一部比《论语》更重要，可以用来了解中国文化，又是人人可读的，我想这不容易。</p><p>只有《论语》，照我刚才所讲条件，从汉朝起，到我们高呼打倒孔家店时为止，本是人人必读的，在中国没有一个读书人不读《论语》，已是经历了两千年。我们要了解一些中国文化，我想至少该看看《论语》。</p><h4 id="第二部《孟子》"><a href="#第二部《孟子》" class="headerlink" title="第二部《孟子》"></a>第二部《孟子》</h4><p>既然要读《论语》，便连带要读《孟子》。讲孔子讲得最好的，莫过于孟子，宋代以后的中国人常合称孔孟。唐朝以前只叫周、孔，不叫孔、孟，这不能说不是中国后代一个大进步。</p><p>说周孔，是看重在政治上。说孔孟，是看重在学术、教育上。至少从宋朝到现在，一般中国人都拿孔孟并称，所以我们读《论语》也该连读《孟子》。</p><p>《论》、《孟》这两本书我现在举出为大家该读之书，读了《论语》有不懂，再读《孟子》，容易帮我们懂孔子。</p><h4 id="第三部《大学》"><a href="#第三部《大学》" class="headerlink" title="第三部《大学》"></a>第三部《大学》</h4><p>既然讲到《论语》和《孟子》，又就联想到《大学》和《中庸》，这在宋代以来合叫做《四书》。</p><p><strong>实际上，《大学》、《中庸》只是两篇文章，收在《小戴礼记》中，不算是两部独立的书。但很早就有人看重这两篇文章。到了宋朝，特别是到了朱夫子，就拿《大学》、《论语》、《孟子》、《中庸》，合称《四书》。</strong></p><p>《大学》是我们开始第一本该读的。中间所讲<strong>格物、致知、诚意、正心、修身、齐家、治国、平天下</strong>，八个大纲领。把中国学术重要之点全包在内。使一个初学的人，开始就可知道我们做学问的大规模，有这样八个纲领。至于如何来讲究这格物、致知、诚意、正心、修身、齐家、治国、平天下这一套，就该进而读《论语》和《孟子》。这样读过以后，才叫我们读《中庸》。</p><p>《中庸》有些话讲得深微奥妙，好像我们今天说太哲学了。所以朱子说，《四书》的顺序，该最后才读《中庸》。</p><p>我的想法，我们既然要读《论语》、《孟子》，兼读《大学》、《中庸》也省事，而且《大学》、《中庸》这两篇文章，也是两千年前已有，中间确也有些很高深的道理。我们不必把它和《语》、《孟》再拆开，说读了《语》、《孟》，便不必读《学》、《庸》，所以我主张还是恢复旧传统旧习惯，依然读《四书》，只把读的方法变动些。</p><h4 id="第四部《中庸》"><a href="#第四部《中庸》" class="headerlink" title="第四部《中庸》"></a>第四部《中庸》</h4><p>不要在开始进学校识字就读，我也不主张在学校里正式开这《四书》一门课。我只希望能在社会上提倡风气，有了高中程度的人，大家应该看看这《四书》。</p><p>尤其重要的，读《四书》一定该读朱子的《注》。提倡《四书》的是朱子，朱子一生，从他开始著作，经历四十年之久，把他全部精力多半放在为《四书》作《注》这一工作上，因此朱子的《论孟集注》、《学庸章句》可以说是一部非常值得读的书。</p><p>我们中国的大学者，多方面有成就，在社会上有最大影响的，所谓“集大成”的学者，上面是孔子，下面是朱子。朱子到今天也已八百年，我们不该不看重这个人。</p><p>《四书》是两千年前的书，今天我们不易读。我们拿八百年前朱子的注来读两千年前的《四书》，这就容易些。直到今天，还没有一个人注《四书》能超过了朱子。</p><p>所以我希望诸位倘使去读《论语》、《孟子》、《大学》、《中庸》，一定要仔细看朱子的《注》。</p><h4 id="第五部《老子》"><a href="#第五部《老子》" class="headerlink" title="第五部《老子》"></a>第五部《老子》</h4><p>但是我要告诉诸位，讲中国文化，也不是儒家一家就可代表得尽，还有《庄子》、《老子》道家一派的思想，从秦开始到清也历两千载。我们最多只能说道家思想不是正面的、不是最重要的。但不能说在中国文化里没有道家思想之成分。儒、道两家思想固有不同，但不能说此两派思想完全违反如水火冰炭不相容。我们要构造一所房子，决不是一根木头能造成的。我们讲文化，也决不是一家思想所能构成。</p><p>儒、道两家在中国传统文化中是一阴一阳，一正一反，一面子，一夹里。虽在宋朝以下，所谓《四书》是《大学》、《中庸》、《论语》、《孟子》，可是我们今天是要讲中华文化，不是单讲儒家思想。儒家思想是中国文化里一根大梁，但其他支撑此文化架构的，也得要。所以我主张大家也不妨可以注意读读《庄》、《老》。</p><p>《老子》只有五千言，其实《论语》也不过一万多字，《孟子》多了，也不过三万多字。今人一动笔，一口气写一篇五千一万三万字的文章并不太困难，读《论语》、《老子》、《孟子》三书合共不超过六万字，这又有什么困难呀！每天看一份报章，也就五六万字一气看下了。</p><h4 id="第六部《庄子》"><a href="#第六部《庄子》" class="headerlink" title="第六部《庄子》"></a>第六部《庄子》</h4><p>只有《庄子》三十三篇较为麻烦一些。但我想，我们读《庄子》，只要读《内篇》七篇，不读其《外篇》、《杂篇》也可以，当然喜欢全读也尽可全读。但《内篇》大体是庄子自己写的，《外篇》、《杂篇》或许也有庄子自己的话，或许更多是庄子的学生及其后学们的话加上去。《内篇》七篇也不到一万字上下，读来很轻松。</p><p>因此我想另外介绍一本注《庄子》的书，那是清代末年的王先谦。他有一部《庄子集解》，这部书商务印书馆有卖，篇幅不大。有两个好处：一是注得简单。庄子是一个哲学家，但他的注不重在哲学，只把《庄子》原文调直一番，加一些字句解释便是。第二个好处是他把《庄子》原文分成一章一节，更易读。若你读郭象《注》，读成玄英《疏》，一篇文章连下去，就较麻烦。</p><p>能分章分节去读便较容易。《论语》、《孟子》、《老子》都是一章一章的，只有《庄子》是一长篇，所以要难读些。也把来分了章，便不难。若这一章读不懂，不妨跳过去读下一章，总有几章能懂的。</p><p>诸位当知，这些都是两千年前人的书，此刻我们来读，定不能一字一句都懂，你又不是在个大学开课设讲座，来讲孔、孟、庄、老。只求略通大义即得。</p><p>纵使大学讲座教授，有学生问，这字怎样讲？教授也可说这字现在还无法确定讲，虽有几个讲法，我都不认为对，且慢慢放在那里，不必字字要讲究。大学教授可以这样，提出博士论文也可以这样。写一本研究《庄子》的书，也可说这里不能讲，讲不通。</p><p><strong>真讲书的人，其实哪本书真能从头到尾讲，每一字都讲得清楚明白呢？这是一件不可能的事。假读书的人，会把这些来难你，叫你不敢读，或者一样来假读不真读。这些话，并不是我故意来开方便之门，从来读书人都如此。</strong></p><h4 id="第七部《六祖坛经》"><a href="#第七部《六祖坛经》" class="headerlink" title="第七部《六祖坛经》"></a>第七部《六祖坛经》</h4><p>以上所讲都是秦朝以前的古书，但我还要讲句话，中国的文化传统里，不仅有孔子、老子，儒家道家，还有佛学。</p><p>因此我要选出唐代禅宗开山的第一部书，那就是《六祖坛经》。这是在中国第一部用白话文来写的书。这书篇幅不大，很易看，也很易懂。而且我们此刻自然有不少人热心想把西洋文化传进中国，那更该一读此书，其中道理，我不想在此详细讲。</p><p>我记得我看《六祖坛经》，第一遍只看了整整一个半天，就看完了，但看得手不忍释。那时很年轻，刚过二十岁，那个星期，恰有些小毛病，觉得无聊，随手翻这本书，我想一个高中学生也就应该能读这本书的了。如此一来，我上面举出的书里，儒、释、道三教都有了。</p><p>也许有人又要问，你为什么专举些儒、释、道三教的书，或说是有关思想方面的书呢？这也有我的理由。若讲历史，讲文学，讲其他，不免都是专门之学，要人去做专家。</p><p>我只是举出一些能影响到整个社会人生方面的书，这些书多讲些做人道理，使人人懂得，即如何去做一个中国人。若能人人都像样做个中国人，自然便是复兴中国文化一条最重要的大道。这是我所以举此诸书之理由。</p><p>这样我上面举了六经，此刻加上《六祖坛经》，可以说是“七经”了。</p><h4 id="第八部《近思录》"><a href="#第八部《近思录》" class="headerlink" title="第八部《近思录》"></a>第八部《近思录》</h4><p>也许有人说我是不是来提倡理学呢？这也不是。在《近思录》的第一卷，朱子自己曾说，这一卷不必读。为何呢？因这中间讲的道理太高深，如讲《太极图》之类，也可说是太哲学了。既不要人人做一哲学家，因此不必要大家读。</p><p>下面讲的只是些做人道理，读一句有一句之用，读一卷有一卷之用，适合于一般人读，不像前面一卷是为专门研究理学的人读的，所以我们尽可只读下面的。我选此书，也不是要人去研究理学，只是盼人注重“做人”，则此书实是有用的。</p><h4 id="第九部《传习录》"><a href="#第九部《传习录》" class="headerlink" title="第九部《传习录》"></a>第九部《传习录》</h4><p>最后一本是明代王阳明先生的《传习录》，这本书也是人人能读的。我劝人读《六祖坛经》，因六祖是一个不识字的人。当然后来他应识得几个字，可是他确实不是读书人。他也不会自己来写一本书。那部《坛经》是他的佛门弟子为他记下，如是的一本书，我说一个高中程度的人应能读。</p><p>至于王阳明自己是一个大学者，但他讲的道理，却说不读书人也能懂，他的话不一定是讲给读书人听，不读书人也能听。而且阳明先生的《传习录》，和朱子的《近思录》，恰恰一面是讲陆王之学的，一面是讲程朱之学。宋明理学中的两大派别，我也平等地选在这里，教人不分门户平等来看。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>以上我所举的书，《论语》、《孟子》、《大学》、《中庸》、《老子》、《庄子》、《六祖坛经》、《近思录》、《传习录》，共九部。</strong></p><p><strong>九部书中，有孔、孟，有庄、老，有佛家，有程、朱，有陆、王，种种派别。</strong></p><p>我们当知中国文化，本不是一个人一家派所建立的。诸位读这九部书，喜欢那一派、喜欢这一派，都可以，而且我举此九部书，更有一个特别重要的，因此九部书其实都不是一部书，都可以分成一章一节。</p><p>诸位果是很忙，没有工夫的话，上毛厕时也可带一本，读上一条也有益，一条是一条。不必从头到尾通体去读。倘使你遇有闲时，一杯清茶，或者一杯咖啡，躺在藤椅子上，随便拿一本，或是《近思录》，或是阳明《传习录》，依然可以看上一条、两条就算了。究看哪些条，这又随你高兴，像抽签一样，抽到哪条就哪条。</p><p>或有人说，中国人的思想就是这么不科学，没系统、无组织。但我认为中国思想之伟大处，也就在这地方，不从一部一部的书来专讲一个道理。我们只是一句一个道理、一条一个道理，但那些道理到后却讲得通，全部都通了。</p><p>西方人喜欢用一大部书来专讲一个道理。像马克斯的《资本论》，老实说，我从没有时间来读它，其实西方人真能从头到尾读它的恐怕也不多，如果马克斯是一个中国人，他受了中国文化影响，我想只很简单两句话就够了，说你这些资本家太不讲人道，赚了这许多钱，也该为你的劳工们想想办法，让他们的生活也得改好些。这就好了。</p><p>如此说来，他的话也是天经地义，一些也没错。但西方习惯，定要成为一家的思想，只此一家，别无分出，于是不免要装头装尾，装出许多话。于是，历史的命定论、唯物史观、阶级斗争种种理论都装上。本是讲经济，讲资本主义，后来不晓得讲到哪里去，毛病就出在这些加上的话。</p><p>我对西洋哲学，当然是外行。但我觉得一部书从头到尾读完，其实也只几句话。但他这几句话，必须用许多话来证。中国书中讲一句是一句，讲两句是两句，不用再有证。只此一句两句已把他要说的道理说完了。</p><p>所以西方哲学，是出乎人生之外的，要放在大学或研究院里去研究，<strong>中国人孔、孟、庄、老所说的话，是只在人生之内的，人人可以读，人人也能懂。从这个门进来，可以从那个门出去，随便哪条路，路路可通。我们中国人认为有最高价值的书应如此。</strong></p><p><strong>这九部书中，也不一定要全读，读八部也可七部也可。只读一部也可。若只读一部，我劝诸位读《论语》。</strong></p><p>最难的是对中国无兴趣，对中国古人古书更无兴趣，那就无话可讲。但如此下去，终必对自己也无兴趣，对中国人一切无兴趣，把中国人的地位全抹杀，中国的前途也真没有了。</p><p>我们今天如何来改造社会转移风气，只有从自己心上做起，我最后可以告诉诸位，至少我自己是得了这几部书的好处，所以我到今天，还能觉得做一中国人也可有光荣。</p><h3 id="其他一些靠谱的阅读建议"><a href="#其他一些靠谱的阅读建议" class="headerlink" title="其他一些靠谱的阅读建议"></a>其他一些靠谱的阅读建议</h3><h4 id="From-易中天-（整理自网络）"><a href="#From-易中天-（整理自网络）" class="headerlink" title="From 易中天 （整理自网络）"></a>From 易中天 （整理自网络）</h4><p> <img src="/images/yizhongtian.jpg" alt="yizhongtian"></p><p>2013年12月，易中天在四川省干部大讲堂上认为，学国学当有门径，梁启超和钱穆推荐的书目都值得参考，不过，所处的时代及读者基础不同，不能一概而论。易中天认为，对于无国学基础的领导干部和企业家，喜欢国学，可依入门次序，读读以下几本：<strong>《论语》、《道德经》、《人生四书》、《曾国藩家书》、《韩非子》、《资治通鉴》</strong>。</p><p>《论语》反映了儒家主要的思想智慧，语录体的，一两句话说一个道理，而且整体上类似一个孔子的传记。分量最重，又最简易。</p><p>《道德经》反映了道家主要的思想智慧，也是语录体，总共81小段，就是一个大思想体系。随便找个注释版本就可以，也是分量最重，又最简易。</p><p>《人生四书》算是“四书”的大众普及版，“四书”包含《论语》、《孟子》、《大学》、《中庸》，南宋朱熹将其编定在一起，意在以相对简易的“四书”来代替古老难学的“五经”，作为推行儒家教化的范本。然后元、明、清三代科举都以“四书”为教材，“四书”就是近八百年中国人的“圣经”，是国学的核心。不过，《孟子》等书都是长篇文言论文，比较难读，可以《人生四书》晓其大概。</p><p>《曾国藩家书》因为是写给家人的，贵在平易、真实。曾国藩是中华传统文化的集大成者，读其家书可以感受到传统经典是怎样落实在工作生活的实地上的。缺点是里面生活琐事的记述较多，需要披沙捡金。可结合入门书《吃透曾国藩》。</p><p>《韩非子》是法家主要的思想智慧。本土的中国传统文化无非儒、道、法，佛教是东汉才传入的。几千年的政治体制中，法家一直是基础，是里子。《韩非子》中有大量的寓言和历史故事，台湾漫画家蔡志忠有一套国学经典的漫画书，其中韩非子的那一本最有趣味，可参照来看。</p><p>《资治通鉴》跨越1000多年历史，历数了周、秦、汉、三国、魏晋、隋、唐、五代等更迭，对于个人与国家的治乱兴废、生死存亡看得最清，涵盖了《史记》多数精华的内容。所以，如果只读一本史书，我推荐通鉴。网上就有白话文版的，每天一小时读一卷，300天就读完了，起码看古装宫廷剧就更明白了。</p><p>如须 再求深致，可参照梁钱书目。</p><h3 id="个人的一些粗浅感悟"><a href="#个人的一些粗浅感悟" class="headerlink" title="个人的一些粗浅感悟"></a>个人的一些粗浅感悟</h3><p>国学经典，好比名山大川，所谓的名著导读，xxx心得，一如上面的旭日图，说到底，就像景点处的宣传彩页，或是他人的游记转述一般，到底只能是个引子。唯有亲历一番，才知高山大泽之奇伟辽阔。</p><p>前人虽已指路，但真正阅读起来，作者其人、时代背景、乃至解读者的种种见解，注疏版本等，都值得细致探索，需要自行甄别。会意者，自能晓得其中乐趣。</p><p>经典之为经典，除了经得住时间的考量，历久而弥新之外，另一大特点便是受得起众生的毁誉，千人千见，永不会说尽，总难被参透。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Resource </category>
          
          <category> 国学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> Echarts </tag>
            
            <tag> Roadmap </tag>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么要写博客？</title>
      <link href="/2018/11/11/thought/motivation-of-writing-blogs/"/>
      <url>/2018/11/11/thought/motivation-of-writing-blogs/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么现在要写博客了？"><a href="#为什么现在要写博客了？" class="headerlink" title="为什么现在要写博客了？"></a>为什么现在要写博客了？</h2><p>​    学生生涯结束至此一年有余，经历了刚开始与工作的磨合，渐渐已经习惯现在的生活节奏，也自知稍嫌乏味单调。工作以后，好多旧时的爱好，也渐渐无暇，或是没有彼时的心境去体味，去沉湎其中了。在告别校园生活后，与社会自然是多了些直接接触，种种经历或愉快、或糟糕，于己而言，总是有些经验积累的。可是这和我现在决定要写博客，有什么关系？好像也没什么直接关系，本来日子就过的糙一些，后知后觉，没有多少筹划反思。不过，写博客这件事，好比颗种子，其实是很久之前，就在心底种下了的······</p><span id="more"></span><p>​    在浏览网站的时候，时常会莫名跳转到某些博客主的独立空间，或分享心得、或展示创作等，当看到让人眼前一亮的内容时，也会逗留品玩一番，心想，他日也要经营个自己的空间，才够独特。之前读书时，曾阅读过一些成长类的书籍，如<strong>《暗时间》</strong>（刘未鹏著）中，提及了坚持写博客的种种好处（详见<strong><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/">为什么你应该（从现在开始就）写博客</a></strong>）。好处确实是显而易见：沉淀思想、分享交流、记录成长等等······  道理都懂，但还是没能促成，我决定任何写博客的实际行动。想想那时，我应该是有其他更好玩的事情去做吧。</p><p>​    后来在日常工作中，常常遇到千奇百怪的问题，而解决问题的一大途径，自然是借助于搜索引擎。各种烦人的技术问题，别人也曾遇到，并被折磨过，很多人都选择将其记录到其博客中，分享其经验。虽然这种信息良莠不齐，但一番筛选尝试之后，也大都能找到行之有效的解决办法。除了常常能帮助解决技术问题外，很多靠谱用心的技术博客，也提供了诸多技能的学习路线指南，资源汇总的等丰富的资讯，令我获益匪浅。这种不时受益于他人技术博客的经历，则真实地促成了我进行博客写作的进一步行动。</p><p>​    秉着古板认真的态度，以及常剑走偏锋的执拗，便不想随随便便，就将自己的感悟，见解轻率地贴在网上。绕树三匝，何枝可依？一番调研之后，最终，选择了博客园，注册账号，趁着新鲜感，拟了几篇草稿，可是真动起笔来，就不似做学习笔记一样，只求自己看懂就好，感觉耗费精力，便又搁置了。本以为博客写作就此会是不了了之了，就像很多其他的爱好一样，三分钟热度。</p><p>​    IT行业技术更迭迅速，一直以来，都是想着利用业余时间充电学习。但更多时候，则是下班回到家中，捧着个手机刷个不停，或者是上网闲逛，通过肤浅的视觉刺激自娱而已。连静下心来阅读的兴致，也大不如从前了，这种虚度时光的焦虑感，一直隐隐地存在着······ 加之近期，对于职业发展，也有些迷茫，而与此同时，也越发感到，展示自我专业技能，对于职业发展，甚至是个人成长的重要。恰当地表达自我的这一想法，也在心头默默酝酿着······</p><p>​    在近期的git学习期间，发现了使用 <strong>github pages</strong> 建立个人网站的诸多优点，没有广告的叨扰，没有博客平台的种种限制，而且也不用费心维护后台等等，这正给了我的博客创作，一个合适的土壤，加上着实想要通过写作，总结反思，展示自我来解决发展困惑这一契机。小经折腾后，一个独立网站算是建成了，发表了第一篇hello world 的文章之后，也正式宣告了该博客的出土破芽，希望以后，会坚持悉心耕耘，使其成长为一片绿荫。</p><p>​    以上絮絮叨叨下来，反观自身，实际上，还是在工作以后，慢慢丢掉了以往的学生思维，单纯的追求有趣好玩，这种事情很少做了，毕竟要为稻粱谋。故而更加注重所谓有用的事情，直白些，便是利益先行，某些事情是否有利可图，是否对长远发展有助益，对此看得更重。<strong>耽于有趣向寻求有用的转变，可以说是工作以来，最明显的转变了。</strong> 由此可见，现已处在冯友兰先生所讲的功利境界之中了。</p><h2 id="写作初衷剖析"><a href="#写作初衷剖析" class="headerlink" title="写作初衷剖析"></a>写作初衷剖析</h2><p>以上是我的关于写博客的思路历程，下面则是对几种写作初衷的剖析：</p><h3 id="一：展示的诉求"><a href="#一：展示的诉求" class="headerlink" title="一：展示的诉求"></a>一：<strong>展示的诉求</strong></h3><p>平时接触的，除了亲友、同事以外，性格使然，很少主动与他人接触。github pages 博客，作为一扇向世界敞开的窗口，能让性格内向者，以一种较为温和的方式，与世界沟通，表达自己的见解，展示自我的能力。既省得天天孤芳自赏，牢骚满腹，也不必只是附和着别人的看法，吟咏着他人的感受，我以我笔书我心，如此。</p><img src="/images/dead_poet_society.jpg"><h3 id="二：文笔的锻炼"><a href="#二：文笔的锻炼" class="headerlink" title="二：文笔的锻炼"></a>二：<strong>文笔的锻炼</strong></h3><p>日常工作中，邮件、报告形式居多，形式单调，限制颇多。而记录在日记中的，不过一些细碎的感受，只言片语，不成篇幅。真正要书我所意时，才发现在遣词造句上的笨拙。正好可以借博文的写作，雕琢一下文字，提升下写作技能。毕竟，若一味地往脑中填塞知识概念或他人见解，而不去思考总结，也只会导致思想的臃肿与平庸。</p><h3 id="三：经验的分享"><a href="#三：经验的分享" class="headerlink" title="三：经验的分享"></a>三：<strong>经验的分享</strong></h3><p>常受益于网络，得以解决一些技术问题，或是获取丰富的学习资料，也想践行下开源精神，创作些高质量的技术类文章，以飨读者。</p><h3 id="四：未知的际遇"><a href="#四：未知的际遇" class="headerlink" title="四：未知的际遇"></a>四：<strong>未知的际遇</strong></h3><p>···在我们心里或许都有一把旺火，可是谁也没有拿它来让自己暖和一下；从旁边经过的人只看见烟筒里冒出一缕青烟，不去理会，现在让我看一看你，应该干什么呢？人必须守护那把心里的火，要稳着点，耐心地等待着，有谁走来，挨近它坐下——大概会停下来吧？···                  ——《亲爱的提奥》</p><img src="/images/vincent.png"><p><strong>Really？I wonder···</strong> </p><h3 id="五：成长的记录"><a href="#五：成长的记录" class="headerlink" title="五：成长的记录"></a>五：<strong>成长的记录</strong></h3><p>在夜深人静时，独坐屏幕前，游思在自己的一片天地之中，默默求索，得以在岁月洪流中，保持一份独立，坚持一份思索。既参与世中，随阅历加深，不时记录些心得体会，又置身其外，时刻提醒，莫要陷入现实的泥沼······</p><p><strong>坚持学习，坚持思考，坚持锻炼，相信以此耕耘数年，必有所成，如此，定是不负青春岁月的。</strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规划 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello 个 world 庆祝一下</title>
      <link href="/2018/11/03/thought/hello-world/"/>
      <url>/2018/11/03/thought/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>​    在很久很久以前，也就是公元200多年前的古希腊，叙拉古的赫农王（King Hieron）让工匠为他打造了一顶纯金王冠，虽然王冠重量和当初交给工匠的金子一样重，但是，还是疑心工匠在其中勾兑掺假，王冠不纯。于是，就让阿基米德来检验王冠。最初阿基米德也无计可施，后来某天洗澡时，坐进浴缸，看到水往外溢，顿悟出——可以利用皇冠在水中的排水量，来测量皇冠的体积。于是兴奋的跳出澡盆，衣服都顾不得穿就跑了出去，大声的喊道：“<strong>尤里卡！尤里卡！</strong>”（ερηκα，意思是“找到了”。）</p><p>​    经过了进一步的实验以后，便来到了王宫，他把王冠和同等重量的纯金放在盛满水的两个盆里，比较两盆溢出来的水，发现放王冠的盆里溢出来的水比另一盆多。这就说明王冠的体积比相同重量的纯金的体积大，密度不相同，所以证明了王冠里掺进了其他金属。</p><p>​    后来，阿基米德从中总结出著名的浮力定律（即——朗朗上口的<strong><em>G = F浮 = ρ液gV排</em></strong>）。而在重大发现之后，忘情高呼Eureka，也作为经典传统，流传开来。在<strong><a href="https://movie.douban.com/subject/1889243/">《星际穿越 Interstellar》</a></strong>中，曾有所致敬：在墨菲（<em>Jessica Chastain</em> 饰）终于破译出，她老爸从四维空间中传来的message后，一路飞奔，将手稿抛向空中，纵情呐喊：Eureka！并开心地解释到：it’s traditional …</p><span id="more"></span><img src="/images/Interstellar.mp4_0.jpg"><img src="/images/Interstellar.mp4_1.jpg"><img src="/images/Interstellar.mp4_2.jpg"><img src="/images/Interstellar.mp4_3.jpg"><img src="/images/Interstellar.mp4_4.jpg"><img src="/images/Interstellar.mp4_5.jpg"><img src="/images/Interstellar.mp4_6.jpg"><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello, world"></a><a href="https://en.wikipedia.org/wiki/"Hello,_World!"_program">hello, world</a></h2><p>​    “Hello, world”呢，则是指在屏幕上输出“Hello，world”这行字符串的计算机程序，因为在Brian Kernighan 和Dennis M. Ritchie合著的《The C Programme Language》中使用它做为第一个演示程序，而广泛流行。所以后来，大家在进行编程相关的学习或测试调试时，也延续了这一传统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main( ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最初的”hello, world”打印内容有个标准，即全小写，有逗号，逗号后空一格，且无感叹号。不过沿用至今，完全遵循传统标准形式的反而很少出现。</p><p><img src="/images/Hello_World_Brian_Kernighan_1978.jpg" alt="Hello_World_Brian_Kernighan_1978"></p><p>​                        *”Hello, world” program by <a href="https://en.wikipedia.org/wiki/Brian_Kernighan">Brian Kernighan</a> (1978)*</p><h2 id="Traditional-celebration"><a href="#Traditional-celebration" class="headerlink" title="Traditional celebration"></a>Traditional celebration</h2><p>​    其实呢，作为传统流传下来，它们现今都已成为一种经典的庆祝方式：前者重在发现，是苦思冥想，终于茅塞顿开的Ah-ha moment，后者重在实践，是折腾尝试，总算大功初成的Oh yeah moment。不过无论是科学发现，还是工程实践，这种激动人心的时刻，真希望人生中能够多体验一些！</p><p>​    经过一番调研与配置，也终于有了自己的一个博客网站，自然也要用最经典的方式庆祝一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>PS：全小写，有逗号，逗号后空一格，且无感叹号 (<strong>讲究！</strong>)。</p><p>​                                                                                   ——2018/11/03 夜</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
